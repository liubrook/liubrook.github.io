<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端笔记</title>
  
  
  <link href="https://github.com/liubrook/liubrook.github.io/atom.xml" rel="self"/>
  
  <link href="https://github.com/liubrook/liubrook.github.io/"/>
  <updated>2020-10-09T02:54:10.353Z</updated>
  <id>https://github.com/liubrook/liubrook.github.io/</id>
  
  <author>
    <name>Brookliu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker简单上手02</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2020/10/08/Docker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B02/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2020/10/08/Docker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B02/</id>
    <published>2020-10-08T02:48:11.000Z</published>
    <updated>2020-10-09T02:54:10.353Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在<a href="https://brookliu.xyz/2020/10/07/Docker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B01/#more" target="_blank" rel="noopener">Docker简单上手01</a>中我们熟悉了常用的docker命令，并成功地容器化了第一个应用。这篇文章我们将实现后端API服务器+数据库的容器化。</p><a id="more"></a> <h3 id="熟悉流程"><a href="#熟悉流程" class="headerlink" title="熟悉流程"></a>熟悉流程</h3><p>下面我们就开始今天的内容学习：</p><h4 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 如果你看了上一篇教程，仓库已经克隆下来了</span><br><span class="line">cd docker-dream</span><br><span class="line">git fetch origin network-start</span><br><span class="line">git checkout network-start</span><br><span class="line"></span><br><span class="line"># 如果你打算直接从这篇教程开始</span><br><span class="line">git clone -b network-start https:&#x2F;&#x2F;github.com&#x2F;tuture-dev&#x2F;docker-dream.git</span><br><span class="line">cd docker-dream</span><br></pre></td></tr></table></figure><div class="note info"><p>提示</p>我直接用的上一篇文章中下载的项目但是在后面容器化的时候一直无法成功，后来发现是上一篇下载的项目和这一篇的不一样，建议直接重新克隆下载项目。</div><p>和之前容器化前端静态页面服务器相比，多了一个难点：服务器和数据库分别是两个独立的容器，但是服务器需要连接和访问数据库，怎么实现跨容器之间的通信？</p><h4 id="Network-类型"><a href="#Network-类型" class="headerlink" title="Network 类型"></a>Network 类型</h4><p>Network，顾名思义就是 “网络”，能够让不同的容器之间相互通信。首先有必要要列举一下 Docker Network 的五种驱动模式（driver）：</p><ul><li>bridge：默认的驱动模式，即 “网桥”，通常用于单机（更准确地说，是单个 Docker 守护进程）。</li><li>overlay：Overlay 网络能够连接多个 Docker 守护进程，通常用于集群，后续讲 Docker Swarm 的文章会重点讲解。</li><li>host：直接使用主机（也就是运行 Docker 的机器）网络，仅适用于 Docker 17.06+ 的集群服务。</li><li>macvlan：Macvlan 网络通过为每个容器分配一个 MAC 地址，使其能够被显示为一台物理设备，适用于希望直连到物理网络的应用程序（例如嵌入式系统、物联网等等）。</li><li>none：禁用此容器的所有网络。</li></ul><p>我们今天将围绕着默认的Bridge网络驱动展开。</p><h4 id="网络准备"><a href="#网络准备" class="headerlink" title="网络准备"></a>网络准备</h4><p>只是这么介绍的话我们还是无法理解，所以我们需要动手试一下来理解和感受Bridge Network。我们来用<a href="https://www.alpinelinux.org/" target="_blank" rel="noopener">Alpine Linux</a>镜像体验下。</p><p>网桥网络分为两类：</p><ul><li>默认网络(Docker运行时自带，不推荐用于生产环境)。</li><li>自定义网络(推荐使用)。</li></ul><h4 id="默认网络"><a href="#默认网络" class="headerlink" title="默认网络"></a>默认网络</h4><p>我们会在默认的 bridge 网络上连接两个容器 alpine1 和 alpine2。 运行以下命令，查看当前已有的网络：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure><p>应该会看到以下输出（注意你机器上的 ID 很有可能不一样）：<br><img src="https://img.brookliu.xyz/blog/docker-2-1.png" alt="网络输出图"></p><p>这三个默认网络分别对应上面的 bridge、host 和 none 网络类型。接下来我们将创建两个容器，分别名为 alpine1 和 alpine2，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --name alpine1 alpine</span><br><span class="line">docker run -dit --name alpine2 alpine</span><br></pre></td></tr></table></figure><p>-dit 是 -d（后台模式）、-i（交互模式）和 -t（虚拟终端）三个选项的合并。通过这个组合，我们可以让容器保持在后台运行而不会退出（没错，相当于是在 “空转”）。</p><p>用 <code>docker ps</code>命令确定以上两个容器均在后台运行：<br><img src="https://img.brookliu.xyz/blog/docker-2-2.png" alt="网络输出图2"></p><p>通过以下命令查看默认的 bridge 网络的详情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure><p>应该会输出 JSON 格式的网络详细数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;4741cab870f168d59a3b5eb1d67251d177dd3af14b8cccc39c130a3f0ec5e3a0&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2020-10-07T11:18:54.983568882+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.17.0.0&#x2F;16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;1af67ce67ec14f57199a6b4e9183330e017014ad33cad0f783b4a3ab9e763bd0&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;client&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;1b800afa81ba8e7d15c806c349166c5f24619d71710825860f4d4eef706badf8&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.2&#x2F;16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;27783577c5b621ff8d2dfdc2982bad4635ac093ed261aa4f4189788f8efe0807&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;alpine2&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;8539c75c6cc44dceb143aac1936e215e2f80f6b6a412c6f10b33722c4f9cf74b&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:04&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.4&#x2F;16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;e7a69f15fa39cdd2434dac9ec9e84f7d7b133f062dfe110cfcde297546830043&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;alpine1&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;0c0310de6ec103386a9485166b54826efa574aa6b3da7996c16385f1d0bb16c5&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.3&#x2F;16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;,</span><br><span class="line">            &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在这一大串信息里我们重点要关注的是两个字段：</p><ul><li>IPAM：IP 地址管理信息（IP Address Management），可以看到网关地址为 172.17.0.1（由于篇幅有限，想要了解网关的同学可自行查阅计算机网络以及 TCP/IP 协议方面的资料）。</li><li>Containers：包括此网络上连接的所有容器，可以看到我们刚刚创建的 alpine1 和 alpine2，它们的 IP 地址分别为 172.17.0.3 和 172.17.0.4（后面的 /16 是子网掩码，暂时不用考虑）。</li></ul><p>进入 alpine1 容器中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach alpine1</span><br></pre></td></tr></table></figure><blockquote><p>attach 命令只能进入设置了交互式运行的容器（也就是在启动时加了 -i 参数）。</p></blockquote><p>如果你看到前面的命令提示符变成 / #，说明我们已经身处容器之中了。我们通过 ping 命令测试一下网络连接情况，首先 ping 一下百度 baidu.com（-c 参数代表发送数据包的数量，这里我们设为 5）：<br><img src="https://img.brookliu.xyz/blog/docker-2-3.png" alt="ping百度"></p><p>看上图，全部都连上了没有丢包(这个取决于你的网络环境)。由此可见，容器内可以访问主机所连接的全部网络（包括 localhost）。</p><p>接下来测试能否连接到 alpine2，在刚才 docker network inspect 命令的输出中找到 alpine2 的 IP 为 172.17.0.3，尝试能否 ping 通：<br><img src="https://img.brookliu.xyz/blog/docker-2-4.png" alt="ping2"><br>完美！我们能够从 alpine1 中访问 alpine2 容器。作为练习，你可以自己尝试一下能否从 alpine2 容器中 ping 通 alpine1 哦。</p><blockquote><p>如果你不想让 alpine1 停下来，记得通过 Ctrl + P + Ctrl + Q（按住 Ctrl，然后依次按 P 和 Q 键）“脱离”（detach，也就是刚才 attach 命令的反义词）容器，而不是按 Ctrl + D 哦。</p></blockquote><h4 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h4><p>默认的 bridge 网络存在一个很大的问题：只能通过 IP 地址相互访问。这毫无疑问是非常麻烦的，当容器数量很多的时候难以管理，而且每次的 IP 都可能发生变化。</p><p>而自定义网络则很好地解决了这一问题。在同一个自定义网络中，每个容器能够通过彼此的名称相互通信，因为 Docker 为我们搞定了 DNS 解析工作，这种机制被称为服务发现（Service Discovery）。具体而言，我们将创建一个自定义网络 my-net，并创建 alpine3 和 alpine4 两个容器，连上 my-net。<br>首先创建自定义网络 my-net：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker network create my-net</span><br><span class="line"># 由于默认网络驱动为 bridge，因此相当于以下命令</span><br><span class="line"># docker network create --driver bridge my-net</span><br></pre></td></tr></table></figure><p>查看当前所有的网络：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure><p>可以看到刚刚创建的 my-net：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">4741cab870f1        bridge              bridge              local</span><br><span class="line">a5ccbe18d2ab        host                host                local</span><br><span class="line">5d8856725e7f        my-net              bridge              local</span><br><span class="line">a18954d078b5        none                null                local</span><br></pre></td></tr></table></figure><p>创建两个新的容器 alpine3 和 alpine4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --name alpine3 --network my-net alpine</span><br><span class="line">docker run -dit --name alpine4 --network my-net alpine</span><br></pre></td></tr></table></figure><p>通过 –network 参数指定容器想要连接的网络（也就是刚才创建的 my-net）。</p><blockquote><p>如果在一开始创建并运行容器时忘记指定网络，那么下次再想指定网络时，可以通过 docker network connect 命令再次连上（第一个参数是网络名称 my-net，第二个是需要连接的容器 alpine3）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect my-net alpine3</span><br></pre></td></tr></table></figure></blockquote><p>进入到 alpine3 中，测试能否 ping 通 alpine4：<br><img src="https://img.brookliu.xyz/blog/docker-2-5.png" alt="ping"></p><p>可以看到 alpine4 被自动解析成了 172.18.0.3。我们可以通过 docker network inspect 来验证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect --format &#39;&#123;&#123;range .Containers&#125;&#125;&#123;&#123;.Name&#125;&#125;: &#123;&#123;.IPv4Address&#125;&#125; &#123;&#123;end&#125;&#125;&#39; my-net</span><br></pre></td></tr></table></figure><h4 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h4><p>通过上面的例子我们明白了默认和自定义网络的一个大致流程，现在可以结束之前创建的容器的使命了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f alpine1 alpine2 alpine3 alpine4</span><br></pre></td></tr></table></figure><p>把创建的 my-net 也删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network rm my-net</span><br></pre></td></tr></table></figure><h3 id="动手实践"><a href="#动手实践" class="headerlink" title="动手实践"></a>动手实践</h3><p>下面我们来正式的进行今天的主题内容:</p><h4 id="容器化服务器"><a href="#容器化服务器" class="headerlink" title="容器化服务器"></a>容器化服务器</h4><p>我们首先对后端服务器也进行容器化。创建 server/Dockerfile，代码如下：<br><font color="blue">注意是在docker-dream目录下哦</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FROM node:10</span><br><span class="line"></span><br><span class="line"># 指定工作目录为 &#x2F;usr&#x2F;src&#x2F;app，接下来的命令全部在这个目录下操作</span><br><span class="line">WORKDIR &#x2F;usr&#x2F;src&#x2F;app</span><br><span class="line"></span><br><span class="line"># 将 package.json 拷贝到工作目录</span><br><span class="line">COPY package.json .</span><br><span class="line"></span><br><span class="line"># 安装 npm 依赖</span><br><span class="line">RUN npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line"># 拷贝源代码</span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line"># 设置环境变量（服务器的主机 IP 和端口）</span><br><span class="line">ENV MONGO_URI&#x3D;mongodb:&#x2F;&#x2F;dream-db:27017&#x2F;todos</span><br><span class="line">ENV HOST&#x3D;0.0.0.0</span><br><span class="line">ENV PORT&#x3D;4000</span><br><span class="line"></span><br><span class="line"># 开放 4000 端口</span><br><span class="line">EXPOSE 4000</span><br><span class="line"></span><br><span class="line"># 设置镜像运行命令</span><br><span class="line">CMD [ &quot;node&quot;, &quot;index.js&quot; ]</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以发现这次的Dockerfile比[上一篇教程]中的要复杂不少。每一行的含义已经注释在代码中了，我们看下多了哪些新东西：</p><ul><li>RUN 指令用于在容器中运行任何命令，这里我们通过 npm install 安装所有项目依赖（当然之前配置了一下 npm 镜像，可以安装得快一点）。</li><li>ENV 指令用于向容器中注入环境变量，这里我们设置了 数据库的连接字符串 MONGO_URI（注意这里给数据库取名为 <strong>dream-db</strong>，后面就会创建这个容器），还配置了服务器的 HOST 和 PORT。</li><li>EXPOSE 指令用于开放端口 4000。之前在用 Nginx 容器化前端项目时没有指定，是因为 Nginx 基础镜像已经开放了 8080 端口，无需我们设置；而这里用的 Node 基础镜像则没有开放，需要我们自己去配置。</li><li>CMD 指令用于指定此容器的启动命令（也就是 docker ps 查看时的 COMMAND 一列），对于服务器来说当然就是保持运行状态。</li></ul><div class="note warning"><p>注意</p>初次尝试容器的朋友很容易犯的一个错误就是忘记将服务器的 host 从 localhost（127.0.0.1）改成 0.0.0.0，导致服务器无法在容器之外被访问到。</div><p>与之前前端容器化类似，创建 server/.dockerignore 文件，忽略服务器日志 access.log 和 node_modules，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">access.log</span><br></pre></td></tr></table></figure><p>然后项目根目录下运行以下命令，构建服务器镜像，指定名称为 dream-server：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t dream-server server</span><br></pre></td></tr></table></figure><p>然后就会自动开始下载构建，这个时候我们需要等一会儿。</p><h4 id="连接服务器与数据库"><a href="#连接服务器与数据库" class="headerlink" title="连接服务器与数据库"></a>连接服务器与数据库</h4><p>首先创建一个自定义网络dream-net</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create dream-net</span><br></pre></td></tr></table></figure><p>然后使用官方的mongo镜像创建并运行MongoDB容器。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name dream-db --network dream-net -d mongo</span><br></pre></td></tr></table></figure><p>我们指定容器名称为 dream-db，所连接的网络为 dream-net，并且在后台模式下运行（-d）。</p><div class="note info"><p>提示</p>在同一自定义网络中的所有容器会互相暴露所有端口，不同的应用之间可以更轻松地相互通信；同时，除非通过 -p（--publish）手动开放端口，网络之外无法访问网络中容器的其他端口，实现了良好的隔离性。网络之内的互操作性和网络内外的隔离性也是 Docker Network 的一大优势所在。</div><div class="note danger"><p>危险</p>这里我们在开启 MongoDB 数据库容器时没有设置任何鉴权措施（例如设置用户名和密码），所有连接数据库的请求都可以任意修改数据，在生产环境是极其危险的。后续文章中我们会讲解如何在容器中管理机密信息（例如密码）。</div><p>然后运行服务器容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:4000 --name dream-api --network dream-net -d dream-server</span><br></pre></td></tr></table></figure><p>查看服务器容器的日志输出，确定 MongoDB 连接成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs dream-api</span><br></pre></td></tr></table></figure><p>看到输出下面的信息就代表成功了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Server is running on http:&#x2F;&#x2F;0.0.0.0:4000</span><br><span class="line">Mongoose connected.</span><br></pre></td></tr></table></figure><h4 id="容器化前端页面"><a href="#容器化前端页面" class="headerlink" title="容器化前端页面"></a>容器化前端页面</h4><p>在项目根目录下，通过以下命令进行容器化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t dream-client client</span><br></pre></td></tr></table></figure><p>然后运行容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:80 --name client -d dream-client</span><br></pre></td></tr></table></figure><p>可以通过 <code>docker ps</code> 命令检验三个容器是否全部正确开启：</p><p>最后，访问 localhost:8080(服务器域名:8080)就可以看到，我们在最后刷新了几次页面，数据记录也都还在，说明我们带有数据库的全栈应用跑起来了！</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在&lt;a href=&quot;https://brookliu.xyz/2020/10/07/Docker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B01/#more&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker简单上手01&lt;/a&gt;中我们熟悉了常用的docker命令，并成功地容器化了第一个应用。这篇文章我们将实现后端API服务器+数据库的容器化。&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://github.com/liubrook/liubrook.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://github.com/liubrook/liubrook.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker简单上手01</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2020/10/07/Docker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B01/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2020/10/07/Docker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B01/</id>
    <published>2020-10-07T03:43:52.000Z</published>
    <updated>2020-10-07T09:58:38.107Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前也有听说过docker但是因为没有具体的业务接触所以并没有具体的去了解过，最近手头的工作也暂时没有那么急所以趁着时间来看下。</p><a id="more"></a> <h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>系统：CentOS 7.6 64位</p><h4 id="查看Linux核心版本，3-10版本及以上才可以安装docker"><a href="#查看Linux核心版本，3-10版本及以上才可以安装docker" class="headerlink" title="查看Linux核心版本，3.10版本及以上才可以安装docker"></a>查看Linux核心版本，3.10版本及以上才可以安装docker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><h4 id="更新yum包"><a href="#更新yum包" class="headerlink" title="更新yum包"></a>更新yum包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><h4 id="查看docker是否曾经安装过"><a href="#查看docker是否曾经安装过" class="headerlink" title="查看docker是否曾经安装过"></a>查看docker是否曾经安装过</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">whereis docker</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果安装过，则删除之前的版本</span><br><span class="line">yum remove docker docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure><h4 id="安装需要的软件包"><a href="#安装需要的软件包" class="headerlink" title="安装需要的软件包"></a>安装需要的软件包</h4><p>yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><h4 id="设置yum源"><a href="#设置yum源" class="headerlink" title="设置yum源"></a>设置yum源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>默认安装最新版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure><p>安装某特定版本需增加版本号（如18.06.3.ce-3.el7）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce-18.06.3.ce</span><br></pre></td></tr></table></figure><h4 id="配置用户"><a href="#配置用户" class="headerlink" title="配置用户"></a>配置用户</h4><p>将 docker 的权限移交给非 root 用户，这样使用 docker 就不需要每次都 sudo 了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>注销用户或者重启之后就会生效。然后通过 systemd 服务配置 Docker 开机启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><h4 id="验证安装是否成功"><a href="#验证安装是否成功" class="headerlink" title="验证安装是否成功"></a>验证安装是否成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><p>如果存在Client和Server则成功<br><img src="https://tothers.top1buyer.com/docker-1-2.png" alt="安装成功"></p><h4 id="下载并安装-docker-compose"><a href="#下载并安装-docker-compose" class="headerlink" title="下载并安装 docker-compose"></a>下载并安装 docker-compose</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L &quot;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.27.4&#x2F;docker-compose-$(uname -s)-$(uname -m)&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><h4 id="配置并测试docker-compose"><a href="#配置并测试docker-compose" class="headerlink" title="配置并测试docker-compose"></a>配置并测试docker-compose</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br><span class="line"></span><br><span class="line">docker-compose version</span><br></pre></td></tr></table></figure><p><img src="https://tothers.top1buyer.com/WeChatf12c620346c9dac34e1fb7e84c0bb781.png" alt="成功图"></p><h4 id="配置镜像仓库"><a href="#配置镜像仓库" class="headerlink" title="配置镜像仓库"></a>配置镜像仓库</h4><p>默认的镜像仓库 Docker Hub 在国外，国内拉取速度比较感人。建议参考<a href="https://yeasy.gitbook.io/docker_practice/install/mirror" target="_blank" rel="noopener">这篇文章</a>配置镜像加速</p><p>到这里前期的准备和环境安装工作就完成了，下面就开始上手实践吧！</p><h3 id="上手实验"><a href="#上手实验" class="headerlink" title="上手实验"></a>上手实验</h3><h4 id="实例一：Hello-World"><a href="#实例一：Hello-World" class="headerlink" title="实例一：Hello World!"></a>实例一：Hello World!</h4><p>按照惯例，我们运行胰腺癌来自Docker的Hello World：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p><img src="https://tothers.top1buyer.com/docker-1-3.png" alt="运行图"></p><p>这个过程中Docker做了以下事情：</p><ul><li>检查本地是否有指定的 hello-world:latest 镜像（latest 是镜像标签，后面会细讲），如果没有，执行第 2 步，否则直接执行第 3 步。</li><li>本地没有指定镜像（Unable to find xxx locally），从 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 下载到本地。</li><li>根据本地的 hello-world:latest 镜像创建一个新的容器并运行其中的程序。</li><li>运行完毕后，容器退出，控制权返回给用户。</li></ul><h4 id="实例二：运行一个Nginx服务器"><a href="#实例二：运行一个Nginx服务器" class="headerlink" title="实例二：运行一个Nginx服务器"></a>实例二：运行一个Nginx服务器</h4><p>运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:80 nginx</span><br></pre></td></tr></table></figure><p><img src="https://tothers.top1buyer.com/docker-1-4.png" alt="Nginx运行图"></p><p>运行之后，你会发现一直卡住，也没有任何输出，但放心你的电脑并没有死机。让我们打开浏览器访问localhost:8080(如果像我一样用的服务器可以打开服务器域名:8080来查看)</p><p>打开链接会看到Welecome to nginx！我们可以继续访问一些不存在的路由，比如localhost:8080/index，同样会提示404。这个时候我们运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>可以看到Docker容器的输出，就有内容了。<br>总结下刚才Docker做的事情：</p><ul><li>检查本地是否有指定的 nginx:latest 镜像（关于 latest 标签，后面会细讲），如果没有，执行第 2 步，否则直接执行第 3 步。</li><li>本地没有指定镜像（Unable to find xxx locally），从 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 下载到本地。</li><li>根据本地的 nginx:latest 镜像创建一个新的容器，并通过 <code>**-p（--publish**）</code>参数建立本机的 8080 端口与容器的 80 端口之间的映射，然后运行其中的程序。</li><li>Nginx 服务器程序保持运行，容器也不会退出。</li></ul><h4 id="实例三：后台运行Nginx"><a href="#实例三：后台运行Nginx" class="headerlink" title="实例三：后台运行Nginx"></a>实例三：后台运行Nginx</h4><p>看上去很酷，不过像 Nginx 服务器这样的进程我们更希望把它抛到后台一直运行。按 Ctrl + C 退出当前的容器，然后再次运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:80 --name my-nginx -d nginx</span><br></pre></td></tr></table></figure><p>注意到与之前不同的是，我们：</p><ul><li>加了一个参数 –name，用于指定容器名称为 my-nginx。</li><li>加了一个选项 -d（–detach），表示 “后台运行”。</li></ul><blockquote><p>容器的名称必须是唯一的，如果已经存在同一名称的容器（即使已经不再运行）就会创建失败。如果遇到这种情况，可以删除之前不需要的容器（后面会讲解怎么删除）。</p></blockquote><p>Docker 会输出一串长长的 64 位容器 ID，然后把终端的控制权返回给了我们。我们试着访问 localhost:8080(服务器域名:8080)，还能看到那一串熟悉的 Welcome to nginx!，说明服务器真的在后台运行起来了。</p><p>那我们怎么管理这个服务器呢？就像熟悉的 UNIX ps 命令一样，docker ps 命令可以让我们查看当前容器的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>输出结果是这样的:<br><img src="https://tothers.top1buyer.com/docker-1-5.png" alt="ps输出"></p><p>从这张表中，就可以清晰地看到了我们在后台运行的 Nginx 服务器容器的一些信息：</p><ul><li>容器 ID（Container ID）为 f104751ca7db（你机器上的可能不一样）。</li><li>所用镜像（Image）为 nginx。</li><li>运行命令 / 程序（Command）为 nginx -g ‘daemon of…，这个是 Nginx 镜像自带的运行命令，暂时不用关心。</li><li>创建时间（Created）为 an hour ago（一小时之前）。</li><li>当前状态（Status）为 Up About an hout（已运行 超过一小时）。</li><li>端口（Ports）为 0.0.0.0:8080-&gt;80/tcp，意思是访问本机的 0.0.0.0:8080 的所有请求会被转发到该容器的 TCP 80 端口。</li><li>名称（Names）为刚才指定的 my-nginx。</li></ul><p>如果我们要让容器停下来，通过 docker stop 命令指定容器名称或 ID 进行操作即可，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop my-nginx</span><br></pre></td></tr></table></figure><h4 id="实例四：交互式运行"><a href="#实例四：交互式运行" class="headerlink" title="实例四：交互式运行"></a>实例四：交互式运行</h4><p>运行以下命令，让我们进入到一个 Ubuntu 镜像中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name dreamland ubuntu</span><br></pre></td></tr></table></figure><p>可以看到我们加了 -it 选项，等于是同时指定 -i（–interactive，交互式模式）和 -t（–tty，分配一个模拟终端） 两个选项。以上命令的输出如下：<br><img src="https://tothers.top1buyer.com/docker-1-6.png" alt="ubuntu输出图"></p><p>这时我们已经在这个Ubuntu镜像中了，可以运行一些命令来看一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br><span class="line"></span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>按 Ctrl + D （或者输入 exit 命令）即可退出。你可以在 docker ps 的终端再次检查容器是否已经被关闭了。</p><h4 id="销毁容器"><a href="#销毁容器" class="headerlink" title="销毁容器"></a>销毁容器</h4><p>我们刚才创建的 Docker 容器也只是用于初步探索，后续不会再用到。由于 Docker 容器是直接存储在我们本地硬盘上的，及时清理容器也能够让我们的硬盘压力小一些。我们可以通过以下命令查看所有容器（包括已经停止的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>类似 Shell 中的 rm 命令，我们可以通过 docker rm 命令销毁容器，例如删除我们之前创建的 dreamland 容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm dreamland</span><br><span class="line"># 或者指定容器 ID，记得替换成自己机器上的</span><br><span class="line"># docker rm f104751ca7db（你机器上的可能不一样）。</span><br></pre></td></tr></table></figure><p>但如果我们想要销毁所有容器怎么办？一次次输入 docker rm 删除显然不方便，可以通过以下命令轻松删除所有容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>docker ps -aq 会输出所有容器的 ID，然后作为参数传给 docker rm 命令，就可以根据 ID 删除所有容器啦。</p><p>删除运行中的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f dreamland</span><br></pre></td></tr></table></figure><p>同样的，我们可以删除所有容器，无论处于什么状态:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -aq)</span><br></pre></td></tr></table></figure><h3 id="容器化第一个应用：开启筑梦之旅"><a href="#容器化第一个应用：开启筑梦之旅" class="headerlink" title="容器化第一个应用：开启筑梦之旅"></a>容器化第一个应用：开启筑梦之旅</h3><p>在之前的步骤中，我们体验了别人为我们提前准备好的镜像（例如 hello-world、nginx 和 ubuntu），这些镜像都可以在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 镜像仓库中找到。在这一步，我们将开始筑梦之旅：学习如何容器化（Containerization）你的应用。</p><p>运行以下命令来获取代码，然后进入项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone -b start-point https:&#x2F;&#x2F;github.com&#x2F;tuture-dev&#x2F;docker-dream.git</span><br><span class="line">cd docker-dream</span><br></pre></td></tr></table></figure><p>如果没有安装git，可以运行 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><p>来安装，也可以到<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">GIT官网</a>来查看如何安装你所对应的平台。</p><p>在这一步中，我们将容器化这个用 React 编写的前端应用，用 Nginx 来提供前端页面的访问。</p><h4 id="什么是容器化"><a href="#什么是容器化" class="headerlink" title="什么是容器化"></a>什么是容器化</h4><p>什么是容器化:</p><ul><li>编写代码：我们已经提供了写好的代码。</li><li>构建镜像。</li><li>创建和运行容器：通过容器的方式运行我们的应用。</li></ul><h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><p>构建 Docker 镜像主要包括两种方式：</p><ul><li>手动：根据现有的镜像创建并运行一个容器，进入其中进行修改，然后运行 docker commit 命令根据修改后的容器创建新的镜像。</li><li>自动：创建 Dockerfile 文件，指定构建镜像的命令，然后通过 docker build 命令直接创建镜像。</li></ul><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>我们先把前端项目 client 构建成一个静态页面。确保你的机器上已经安装 Node 和 npm（点击<a href="https://nodejs.org/en/" target="_blank" rel="noopener">这里</a>下载，或使用 <a href="https://github.com/nvm-sh/nvm">nvm</a>），然后进入到 client 目录下，安装所有依赖，并构建项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd client</span><br><span class="line">npm install</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>如果安装node和npm出现问题的可以看下我之前的这篇文章<a href="https://brookliu.xyz/2019/12/27/Linux%E4%B8%8B%E5%AE%89%E8%A3%85node/#more" target="_blank" rel="noopener">Linux安装Node</a>。</p><p>等待一阵子后，你应该可以看到 client/build 目录，存放了我们要展示的前端静态页面。</p><p>创建 Nginx 配置文件 client/config/nginx.conf，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    root &#x2F;www;</span><br><span class="line">    index index.html;</span><br><span class="line">    sendfile on;</span><br><span class="line">    sendfile_max_chunk 1M;</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">    gzip_static on;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        try_files $uri $uri&#x2F; &#x2F;index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置大致意思是：监听 80 端口，网页根目录在 /www，首页文件是 index.html，如果访问 / 则提供文件 index.html。</p><h4 id="创建-Dockerfile"><a href="#创建-Dockerfile" class="headerlink" title="创建 Dockerfile"></a>创建 Dockerfile</h4><p>然后就是这一步骤中最重要的代码：Dockerfile！创建 client/Dockerfile 文件，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx:1.13</span><br><span class="line"></span><br><span class="line"># 删除 Nginx 的默认配置</span><br><span class="line">RUN rm &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf</span><br><span class="line"></span><br><span class="line"># 添加自定义 Nginx 配置</span><br><span class="line">COPY config&#x2F;nginx.conf &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;</span><br><span class="line"></span><br><span class="line"># 将前端静态文件拷贝到容器的 &#x2F;www 目录下</span><br><span class="line">COPY build &#x2F;www</span><br></pre></td></tr></table></figure><p>可以看到我们用了 Dockerfile 中的三个指令：</p><ul><li>FROM 用于指定基础镜像，这里我们基于 nginx:1.13 镜像作为构建的起点。</li><li>RUN 命令用于在容器内运行任何命令（当然前提是命令必须存在）。</li><li>COPY 命令用于从 Dockerfile 所在的目录拷贝文件到容器指定的路径。</li></ul><p>现在可以来构建我们的镜像了，运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 如果你已经在 client 目录中</span><br><span class="line">#（注意最后面有个点，代表当前目录）</span><br><span class="line">docker build -t dream-client .</span><br><span class="line"></span><br><span class="line"># 如果你回到了项目根目录</span><br><span class="line">docker build -t dream-client client</span><br></pre></td></tr></table></figure><p>可以看到我们指定了 -t（–tag，容器标签）为 dream-client，最后指定了构建容器的上下文目录（也就是 当前目录 . 或 client）。</p><p>运行以上的命令之后，你会发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon  289.4MB</span><br></pre></td></tr></table></figure><p>接着运行了一系列的 Step（4 个），然后提示镜像构建成功。</p><p>为什么这个构建上下文（Build Context）这么大？因为我们把比 “黑洞” 还 “重” 的 node_modules 也加进去了！（忍不住想起了下面这张图）<br><img src="https://tothers.top1buyer.com/docker-1-7.png" alt="构建"></p><p>Docker 提供了类似 .gitignore 的机制，让我们可以在构建镜像时忽略特定的文件或目录。创建 client/.dockerignore 文件（注意 dockerignore 前面有一个点）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br></pre></td></tr></table></figure><p>再次运行构建命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t dream-client .</span><br></pre></td></tr></table></figure><p><img src="https://tothers.top1buyer.com/docker-1-7.png" alt="再次构建构建"><br>可以看到这次只有1.217MB，而且速度也明显快了很多.</p><h4 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h4><p>终于到了容器化的最后一步 —— 创建并运行我们的容器！通过以下命令运行刚才创建的 dream-client 镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:80 --name client -d dream-client</span><br></pre></td></tr></table></figure><p>与之前类似，我们还是设定端口映射规则为 8080:80，容器名称为 client，并且通过 -d 设置为后台运行。然后访问 localhost:8080(老样子–服务器域名:8080)：<br><img src="https://tothers.top1buyer.com/docker-1-7.png" alt="运行容器"><br>可以看到如图所示的页面，表示容器运行成功.</p><h4 id="关于镜像标签"><a href="#关于镜像标签" class="headerlink" title="关于镜像标签"></a>关于镜像标签</h4><p>在刚才的实战中，你也许已经注意到在拉取和构建镜像时，Docker 总是会为我们加上一个 :latest 标签，这个 :latest 的含义便是 “最新” 的意思。和软件的版本机制一样，镜像也可以通过标签实现 “版本化”。</p><p>实际上，我们完全可以在拉取或构建镜像时指定标签（通常被认为是一种好的做法）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:1.13</span><br><span class="line">docker build -t dream-client:1.0.0</span><br></pre></td></tr></table></figure><p>还可以给现有的镜像打上标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 把默认的 latest 镜像打上一个 newest 标签</span><br><span class="line">docker tag dream-client dream-client:newest</span><br><span class="line"># 甚至可以同时修改镜像的名称和标签</span><br><span class="line">docker tag dream-client:1.0.0 dream-client2:latest</span><br></pre></td></tr></table></figure><p>可以看到，标签未必一定是版本，还可以是任何字符串（当然最好要有意义，否则过了一阵子你也不记得这个打了这个标签的容器有什么作用了）。</p><h4 id="关于-Dockerfile"><a href="#关于-Dockerfile" class="headerlink" title="关于 Dockerfile"></a>关于 Dockerfile</h4><p>Dockerfile 实际上是默认名称，我们当然可以取一个别的名字，例如 myDockerfile，然后在构建镜像时指定 -f（–file）参数即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f myDockerfile -t dream-client .</span><br></pre></td></tr></table></figure><p>这里举两个经典的使用场景：</p><ul><li>例如在 Web 开发时，分别创建 Dockerfile.dev 用于构建开发镜像，创建 Dockerfile.prod 构建生产环境下的镜像；</li><li>在训练 AI 模型时，创建 Dockerfile.cpu 用于构建用 CPU 训练的镜像，创建 Dockerfile.gpu 构建用 GPU 训练的镜像。</li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这篇文章是我跟着图灵社区的流程走了一遍所记录的过程，<a href="https://tuture.co/2020/01/01/442cc8d/" target="_blank" rel="noopener">点击这里查看图灵社区</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前也有听说过docker但是因为没有具体的业务接触所以并没有具体的去了解过，最近手头的工作也暂时没有那么急所以趁着时间来看下。&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://github.com/liubrook/liubrook.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://github.com/liubrook/liubrook.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Webpack上传腾讯云</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2020/09/18/Webpack%E4%B8%8A%E4%BC%A0%E8%85%BE%E8%AE%AF%E4%BA%91/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2020/09/18/Webpack%E4%B8%8A%E4%BC%A0%E8%85%BE%E8%AE%AF%E4%BA%91/</id>
    <published>2020-09-18T09:08:16.000Z</published>
    <updated>2020-09-18T09:31:41.160Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>我们公司之前的项目一直都是打包之后上传七牛，但是最近一段时间总是出现打包文件找不到的情况，中间过程就省略了，最后决定把项目文件放到腾讯云上。</p><a id="more"></a><h3 id="腾讯云准备工作"><a href="#腾讯云准备工作" class="headerlink" title="腾讯云准备工作"></a>腾讯云准备工作</h3><ul><li>进入腾讯云控制台。</li><li>打开对象存储。</li><li>点击存储桶列表-创建存储桶。</li><li>在存储桶列表里点击刚创建的桶-点击右侧权限管理-存储桶访问权限-公有读私有写。<br>如果有CDN加速需求的话。<ul><li>点击右侧域名与传输管理-自定义CDN加速域名-添加域名(这一步看你是想要采用默认CDN加速域名还是自定义的)。</li><li>如果是自定义加速域名的话除了域名的HTTPS配置，在腾讯云上还要进行配置:<ul><li>控制台-点击内容分发网络-左侧证书管理-配置对应的证书。(我开始不知道要做这一步，文件上传到腾讯云之后一直无法访问，后来提了工单才知道，耽误了几个小时)。</li></ul></li></ul></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i tencent-cloud-webpack-plugin</span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>支持的配置项:</p><ul><li><code>secretId</code> COS SecretId</li><li><code>secretKey</code> COS SecretKey</li><li><code>bucket</code> COS 存储对象名称，格式为对象名称加应用 ID，如：<code>bucket-1250000000</code></li><li><code>region</code> COS 存储地域，参见<a href="https://cloud.tencent.com/document/product/436/6224" target="_blank" rel="noopener">官方文档</a></li><li><code>path</code> 存储路径， 默认为 <code>[hash]</code>，也可以指定 hash 长度，如: <code>[hash:8]</code></li><li><code>exclude</code> 可选，排除特定文件，正则表达式，如: <code>/index\.html$/</code></li><li><code>include</code> 可选，指定要上传的文件，正则表达式，如: <code>/app\.js$/</code></li><li><code>batch</code> 可选，批量上传文件并发数，默认 20</li></ul><p><strong><em>注: Webpack 的 <code>output.publicPath</code> 要指向 COS（或自定义的）域名地址</em></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">const</span> CosPlugin = <span class="built_in">require</span>(<span class="string">'cos-webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里用项目名加上时间戳用来在腾讯云中区分标识</span></span><br><span class="line"><span class="keyword">const</span> fileName = <span class="string">'projectName/'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 Plugin</span></span><br><span class="line"><span class="keyword">const</span> cosPlugin = <span class="keyword">new</span> CosPlugin(&#123;</span><br><span class="line">    secretId: defaultSettings.tencent.secretId,</span><br><span class="line">    secretKey: defaultSettings.tencent.secretKey,</span><br><span class="line">    bucket: defaultSettings.tencent.bucket,</span><br><span class="line">    region: defaultSettings.tencent.region,</span><br><span class="line">    path: fileName</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Webpack 的配置</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> output: &#123;</span><br><span class="line">    publicPath: IS_PROD ? defaultSettings.tencent.publicPath + fileName + <span class="string">'/dist'</span> : <span class="string">'/'</span>,</span><br><span class="line">    outputDir: <span class="string">'dist'</span>,</span><br><span class="line">    assetsDir: <span class="string">'static'</span>,</span><br><span class="line"> &#125;,</span><br><span class="line"> plugins: [</span><br><span class="line">   cosPlugin</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"> ]</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><a href="https://github.com/liubrook/tencent-cloud-webpack">示例项目</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;我们公司之前的项目一直都是打包之后上传七牛，但是最近一段时间总是出现打包文件找不到的情况，中间过程就省略了，最后决定把项目文件放到腾讯云上。&lt;/p&gt;</summary>
    
    
    
    <category term="Webpack" scheme="https://github.com/liubrook/liubrook.github.io/categories/Webpack/"/>
    
    
    <category term="Webpack" scheme="https://github.com/liubrook/liubrook.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>浏览器输入URL后发生了什么？</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2020/01/15/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2020/01/15/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2020-01-15T12:10:24.000Z</published>
    <updated>2020-09-24T03:38:17.516Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器输入URL之后大体上可以分为六步:<br>合成URL-DNS域名解析-建立TCP连接-发送请求，返回结果-关闭TCP连接-浏览器渲染</p><a id="more"></a>  <h3 id="合成URL"><a href="#合成URL" class="headerlink" title="合成URL"></a>合成URL</h3><p>用户输入URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL。</p><h3 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h3><p>在网络世界，记住网站的名称很容易，但是记住网站的IP地址却很难。这时候我们就需要一个地址簿，就是DNS服务器。DNS服务器是高可用、高并发和分布式的，它是树状结构，如图：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/1.png" alt="DNS图"></p><ul><li>根DNS服务器：返回顶级域DNS服务器的IP地址.</li><li>顶级域DNS服务器：返回权威DNS服务器的IP地址.</li><li>权威DNS服务器：返回相应主机的IP地址.</li></ul><p>DNS的域名查找，在客户端和浏览器、本地DNS之间的查询方式是递归查询；在本地DNS服务器与根域及其子域之间的查询方式迭代查询；<br>递归过程：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/2.png" alt="DNS查询图"></p><p>在客户端输入URL之后，会有一个递归查找的过程，从浏览器缓存中查找-&gt;本地的hosts文件查找-&gt;在本地DNS解析器缓存查找-&gt;本地DNS服务器查找，这个过程中任何一步找到了都会结束查找流程。</p><p>如果本地DNS服务器无法查询到，则根据本地DNS服务器设置的转发器进行查询。若未用转发模式，则迭代查找过程如下图：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/2.png" alt="迭代查找图"></p><p>结合起来的过程，可以用一个图表示：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/4.png" alt="DNS图"></p><p>在查找过程中，有以下优化点：</p><ul><li><p>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种：浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存。</p></li><li><p>在域名和IP的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均很，也可以根据地址和运营商做全局的负载均衡。</p><h3 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h3><p>首先，判断是不是HTTPS，如果是的话则HTTPS其实是HTTP+SSL/TLS两部分组成，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户短的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。</p></li></ul><p>进行三次握手，建立TCP连接：</p><ul><li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后客户端今日SYN_SEND状态，等待服务器的确认。</li><li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段)中，一并发送给客户端，此时服务器进入SYN_RECV状态。</li><li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</li></ul><p>SSL握手过程：</p><ul><li>第一阶段：建立安全能力，包括协议版本、会话Id、密码构件、压缩方法、初始随机数。</li><li>第二阶段：服务器发送证书、密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号。</li><li>第三阶段：如果有证书请求客户端发送此证书，之后客户端发送密钥交换数据，也可以发送证书验证消息。</li><li>第四阶段：变更密码构件和结束握手协议。</li></ul><p>完成了之后，客户端和服务器端就可以开始传送数据。</p><p><font color="blue">备注：</font></p><p>ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0。TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1。</p><p>SYN(SYNchronization)：在连接建立时用来同步序号。当SYN=1而ACK=0时，表示这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1.因此，SYN置为1就表示这是一个连接请求或连接接受报文。</p><p>FIN(finis)：用来释放一个连接。当FIN=1时，表示此报文段的发送方的数据已经发送完毕，并要求释放连接。</p><h3 id="发送HTTP请求，服务器处理请求，返回响应结果"><a href="#发送HTTP请求，服务器处理请求，返回响应结果" class="headerlink" title="发送HTTP请求，服务器处理请求，返回响应结果"></a>发送HTTP请求，服务器处理请求，返回响应结果</h3><p>TCP连接建立后，浏览器就可以利用HTTP/HTTPS协议向服务器发送请求了。服务器接收到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200。</p><h3 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h3><ul><li>第一次分手：主机1(可以是客户端，也可以是服务器端)，设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了。</li><li>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1返回一个ACK报文段，ACKnowledgment Number为Sequence Number + 1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我同意你的关闭请求。</li><li>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2今日LAST_ACK状态。</li><li>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1今日TIME_WAIT状态，主机2收到主机1的ACK报文段以后就关闭连接。此时，主机1等到2MSL后仍然没有收到回复，则证明主机2已正常关闭，主机1也可以关闭连接了。</li></ul><h3 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h3><p>按照渲染的时间顺序，流水线可分为如下几个子阶段：构建DOM树、样式计算、布局阶段、分层、栅格化、限时。如图：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/5.png" alt="渲染图"></p><ul><li>渲染进程将HTML内容转换为能够读懂DOM树结构。</li><li>渲染引擎将CSS样式表转换为浏览器可以理解的styleSheets，计算出DOM节点的样式。</li><li>创建布局树，并计算元素的布局信息。</li><li>对布局树进行分层，并生成分层树。</li><li>为每个图层生成绘制列表，并将其提交到合成线程，合成线程将图层分图块，并栅格化将图块转换成位图。</li><li>合成线程发送绘制图块命令给浏览器进程，浏览器进程根据指令生成页面，并显示到显示器上。</li></ul><h4 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h4><p>浏览器从网络或硬盘中获得HTML字节数据后会经过一个流程将字节解析为DOM树，先讲HTML的原始字节数据转换为文件指定编码的自负，然后浏览器会根据HTML规范来讲字符串转换成各种令牌标签，如html、body等。最终解析成一个树状的对象模型，就是dom树。<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/6.png" alt="DOM"></p><p>具体步骤：</p><ul><li>转码(Bytes-&gt;Characters)–读取接收到的HTML二进制数据，按照指定编码格式将字节转换为HTML字符串。</li><li>Tokens转化(Characters-&gt;Tokens)–解析HTML，将HTML字符串转换为结构清晰的Tokens，每个Token都有特殊的含义同时有自己的一套规则。</li><li>构建Node(Tokens-&gt;Nodes)–每个Node都添加特定的属性(或属性访问器)，通过指针能够确定Node的父子兄弟关系和所属treeScope。</li><li>构建DOM树(Nodes-&gt;DOM Tree)–最重要的工作是建立起每个节点的父子兄弟关系。</li></ul><h4 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h4><p>渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。</p><p>CSS样式来源主要有3种，分别是通过link引用的外部CSS文件、style标签内的CSS、元素的style属性内嵌的CSS，其样式计算过程主要为：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/7.png" alt="CSS"></p><p>可以看到上面的CSS文本中有很多属性值，如2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化，处理完成后再处理样式的继承和层叠， 有些文章将这个过程成为CSSOM的构建过程。</p><h4 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h4><p>布局过程，即排除<code>&lt;script&gt;、&lt;meta&gt;</code>等功能化、非视觉节点，排除display:none的节点，计算元素的位置信息，确定元素的位置，构建一颗只包含可见元素布局树，如图：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/8.png" alt="布局图"></p><p>这个过程需要注意的是回流和重绘。</p><h4 id="生成分层树"><a href="#生成分层树" class="headerlink" title="生成分层树"></a>生成分层树</h4><p>页面中有很多复杂的效果，如一些复杂的3D变化、页面滚动，或者使用z-indexing做z轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成占用的图层，并生成一颗对应的图层树(LayerTree)。</p><p>如果你熟悉PS，相信你会很容易理解图层的概念，正是这些图层添加在一起构成了最终的页面图像，在浏览器中，你可以打开Chrome的‘开发者工具’，选择‘layers’标签。渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。</p><p>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。</p><h4 id="栅格化"><a href="#栅格化" class="headerlink" title="栅格化"></a>栅格化</h4><p>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。</p><p>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口(viewport)。在有些情况下，有的图层可以很大比如有的页面你使用滚动条要滚动到好久才能到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p><h4 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h4><p>最后，合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上，渲染过程完成。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;浏览器输入URL之后大体上可以分为六步:&lt;br&gt;合成URL-DNS域名解析-建立TCP连接-发送请求，返回结果-关闭TCP连接-浏览器渲染&lt;/p&gt;</summary>
    
    
    
    <category term="浏览器" scheme="https://github.com/liubrook/liubrook.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="https://github.com/liubrook/liubrook.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Javascript数组去重</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2020/01/05/Javascript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2020/01/05/Javascript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</id>
    <published>2020-01-05T12:47:48.000Z</published>
    <updated>2020-09-24T02:57:54.263Z</updated>
    
    <content type="html"><![CDATA[<p>常见的Javascript数组去重的12种方法</p><a id="more"></a>  <h4 id="利用ES6-Set去重-ES6中最常用"><a href="#利用ES6-Set去重-ES6中最常用" class="headerlink" title="利用ES6 Set去重(ES6中最常用)"></a>利用ES6 Set去重(ES6中最常用)</h4><p>不考虑兼容性，这种去重的方法代码最少。这种方法无法去掉“{}”空对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    return Array.from(new Set(arr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用for嵌套for，然后splice去重-ES5中最常用"><a href="#利用for嵌套for，然后splice去重-ES5中最常用" class="headerlink" title="利用for嵌套for，然后splice去重(ES5中最常用)"></a>利用for嵌套for，然后splice去重(ES5中最常用)</h4><p>双重循环，外层循环元素，内层循环时比较值。值相同时，则删除这个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        for (var j &#x3D; i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">            if (arr[i] &#x3D;&#x3D; arr[j]) &#123;</span><br><span class="line">                &#x2F;&#x2F; 第一个等同于第二个，splice方法删除第二个</span><br><span class="line">                arr.splice(j, 1);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用indexOf去重"><a href="#利用indexOf去重" class="headerlink" title="利用indexOf去重"></a>利用indexOf去重</h4><p>新建一个空的结果数组，for循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进结果数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#39;type error!&#39;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var array &#x3D; [];</span><br><span class="line">    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (array.indexOf(arr[i]) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">            array.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用sort"><a href="#利用sort" class="headerlink" title="利用sort()"></a>利用sort()</h4><p>利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&quot;type error!&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    arr &#x3D; arr.sort()</span><br><span class="line">    var array &#x3D; [arr[0]];</span><br><span class="line">    for (var i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i] !&#x3D;&#x3D; arr[i - 1]) &#123;</span><br><span class="line">            array.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用对象的属性不能相同的特点进行去重-这种数组去重的方法有问题，不建议用，有待改进"><a href="#利用对象的属性不能相同的特点进行去重-这种数组去重的方法有问题，不建议用，有待改进" class="headerlink" title="利用对象的属性不能相同的特点进行去重(这种数组去重的方法有问题，不建议用，有待改进)"></a>利用对象的属性不能相同的特点进行去重(这种数组去重的方法有问题，不建议用，有待改进)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#39;type error!&#39;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var array &#x3D; [];</span><br><span class="line">    var obj &#x3D; &#123;&#125;;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (!obj[arr[i]]) &#123;</span><br><span class="line">            array.push(arr[i])</span><br><span class="line">            obj[arr[i]] &#x3D; 1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            obj[arr[i]]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用includes"><a href="#利用includes" class="headerlink" title="利用includes"></a>利用includes</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#39;type error!&#39;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var array &#x3D; [];</span><br><span class="line">    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (!array.includes(arr[i])) &#123;</span><br><span class="line">            array.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用hasOwnProperty判断是否存在对象属性"><a href="#利用hasOwnProperty判断是否存在对象属性" class="headerlink" title="利用hasOwnProperty判断是否存在对象属性"></a>利用hasOwnProperty判断是否存在对象属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    var obj &#x3D; &#123;&#125;;</span><br><span class="line">    return arr.filter(function(item, index, arr) &#123;</span><br><span class="line">        return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] &#x3D; true)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用filter"><a href="#利用filter" class="headerlink" title="利用filter"></a>利用filter</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    return arr.filter(function(item, index, arr) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当前元素，在原始数组中的第一个索引&#x3D;&#x3D;当前索引值，否则返回当前元素</span><br><span class="line">        return arr.indexOf(item, 0) &#x3D;&#x3D;&#x3D; index;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用递归去重"><a href="#利用递归去重" class="headerlink" title="利用递归去重"></a>利用递归去重</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    var array &#x3D; arr;</span><br><span class="line">    var len &#x3D; array.length;</span><br><span class="line">    arr.sort((a, b) &#x3D;&gt; a - b)</span><br><span class="line">    function loop(index) &#123;</span><br><span class="line">        if (index &gt;&#x3D; 1) &#123;</span><br><span class="line">            if (array[index] &#x3D;&#x3D;&#x3D; array[index - 1]) &#123;</span><br><span class="line">                array.splice(index, 1)</span><br><span class="line">            &#125;</span><br><span class="line">            loop(index - 1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    loop(len - 1);</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用Map数据结构去重"><a href="#利用Map数据结构去重" class="headerlink" title="利用Map数据结构去重"></a>利用Map数据结构去重</h4><p>创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function arraynonRepeatfy(arr) &#123;</span><br><span class="line">    let map &#x3D; new Map();</span><br><span class="line">    let array &#x3D; new Array();</span><br><span class="line">    for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (map.has(arr[i])) &#123;</span><br><span class="line">            map.set(arr[i], true)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.set(arr[i], false)</span><br><span class="line">            array.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用reduce-includes"><a href="#利用reduce-includes" class="headerlink" title="利用reduce+includes"></a>利用reduce+includes</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    return arr.reduce((prev, cur) &#x3D;&gt; prev.includes(cur) ? prev : [...prev, cur], [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="…new-Set-arr"><a href="#…new-Set-arr" class="headerlink" title="[…new Set(arr)]"></a>[…new Set(arr)]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...new Set(arr)]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;常见的Javascript数组去重的12种方法&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>前端常见面试题-1</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2020/01/02/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-1/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2020/01/02/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-1/</id>
    <published>2020-01-02T02:47:48.000Z</published>
    <updated>2020-09-24T02:51:58.745Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1，http的状态码中，499是什么？如何出现499？如何排查解决？"><a href="#1，http的状态码中，499是什么？如何出现499？如何排查解决？" class="headerlink" title="1，http的状态码中，499是什么？如何出现499？如何排查解决？"></a>1，http的状态码中，499是什么？如何出现499？如何排查解决？</h3><p>499对应的是“client has closed connection”，客户端请求等待连接已经关闭，这很有可能是因为服务器端处理的时间过长，客户端等的‘不耐烦了’。还可能是因为两次提交post请求过快就会出现499。<br>解决方法:</p><ul><li>前端将timeout最大等待时间设置大一些。</li><li>nginx上配置proxt_ignore_client_abort on;<a id="more"></a>  <h3 id="2，如何遍历一个dom树"><a href="#2，如何遍历一个dom树" class="headerlink" title="2，如何遍历一个dom树"></a>2，如何遍历一个dom树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function traversal(node) &#123;</span><br><span class="line">    &#x2F;&#x2F; 对node的处理</span><br><span class="line">    if (node &amp;&amp; node.nodeType &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">        console.log(node.tagName);</span><br><span class="line">    &#125;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; node.childNodes.length; i++) &#123;</span><br><span class="line">        const item &#x3D; node.childNodes[i];</span><br><span class="line">        if (item.nodeType &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; 递归先序遍历子节点</span><br><span class="line">            traversal(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3，new操作符都做了什么？"><a href="#3，new操作符都做了什么？" class="headerlink" title="3，new操作符都做了什么？"></a>3，new操作符都做了什么？</h3><p>四大步骤：</p><ul><li>创建一个空对象，并且this变量引用该对象。</li><li>继承了函数的原型。</li><li>属性和方法被加入到this引用的对象中，并且执行了该函数func。</li><li>新创建的对象由this所引用，并且最后隐式的返回this。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function new(func) &#123;</span><br><span class="line">    let target &#x3D; &#123;&#125;;</span><br><span class="line">    target.__proto__ &#x3D; func.prototype;</span><br><span class="line">    let res - func.call(target);</span><br><span class="line">    if (typeof(res) &#x3D;&#x3D; &#39;object&#39; &#125;&#125; typeof(res) &#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4，简单实现call"><a href="#4，简单实现call" class="headerlink" title="4，简单实现call"></a>4，简单实现call</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; es3</span><br><span class="line">Function.prototype.call2 &#x3D; function (context) &#123;</span><br><span class="line">    var context &#x3D; context || window; &#x2F;&#x2F; 因为传进来的context有可能是null</span><br><span class="line">    context.fn &#x3D; this;</span><br><span class="line">    var args &#x3D; [];</span><br><span class="line">    for (var i &#x3D; 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">        args.push(&quot;arguments[&quot; + i + &quot;]&quot;); &#x2F;&#x2F;不这么做的话 字符串的引号会被自动去掉 变成了变量 导致报错</span><br><span class="line">    &#125;</span><br><span class="line">    args &#x3D; args.join(&quot;,&quot;);</span><br><span class="line">    var result &#x3D; eval(&quot;context.fn(&quot; + args + &quot;)&quot;); &#x2F;&#x2F;相当于执行了context.fn(arguments[1], arguments[2]);</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result; &#x2F;&#x2F; 因为有可能this函数会有返回值return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; es6</span><br><span class="line">Function.prototype.call2 &#x3D; function (context) &#123;</span><br><span class="line">    context &#x3D; context ? Object(context) : window;</span><br><span class="line">    context.fn &#x3D; this;</span><br><span class="line">    let args &#x3D; [...arguments].slice(1)</span><br><span class="line">    let result &#x3D; context.fn(...args);</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5，简单实现apply"><a href="#5，简单实现apply" class="headerlink" title="5，简单实现apply"></a>5，简单实现apply</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; es3</span><br><span class="line">Function.prototype.apply2 &#x3D; function(context, arr) &#123;</span><br><span class="line">    context &#x3D; context ? Object(context) : window;</span><br><span class="line">    context.fn &#x3D; this;</span><br><span class="line">    var result;</span><br><span class="line">    &#x2F;&#x2F; 判断是否存在第二个参数</span><br><span class="line">    if (!arr) &#123;</span><br><span class="line">        result &#x3D; context.fn();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var args &#x3D; [];</span><br><span class="line">        for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            args.push(&quot;arr[&quot; + i + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        result &#x3D; eval(&quot;context.fn(&quot; + args + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; es6</span><br><span class="line">Function.prototype.apply2 &#x3D; function(context, arr) &#123;</span><br><span class="line">    context &#x3D; context ? Object(context) : window;</span><br><span class="line">    context.fn &#x3D; this;</span><br><span class="line">    let result;</span><br><span class="line">    if (!arr) &#123;</span><br><span class="line">        result &#x3D; context.fn();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        result &#x3D; context.fn(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6，简单实现bind"><a href="#6，简单实现bind" class="headerlink" title="6，简单实现bind"></a>6，简单实现bind</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line">    var _this &#x3D; this;</span><br><span class="line">    var argsParent &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var args &#x3D; argsParent.contact(Array.prototype.slice.call(arguments));</span><br><span class="line">        _this.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7，https对称加密和非对称加密"><a href="#7，https对称加密和非对称加密" class="headerlink" title="7，https对称加密和非对称加密"></a>7，https对称加密和非对称加密</h3><p>对称加密：发送方和接收方需要持有同一把密钥，发送消息和接收消息均使用该密钥。相对于非加密对称，加密对称具有更高的加解密速度，但双方都需要实现知道密钥，密钥在传输过程中可能会被窃取，因此安全性没有非对称加密高。</p><p>非对称加密；接收方在发送消息前需要事先生成公钥和私钥，然后将公钥发送给发送方，发送方收到公钥后，将待发送数据用公钥加密，发送给接收方。接收方收到数据后，用私钥解密。在这个过程中，公钥负责加密，私钥负责解密，数据在传输过程中即使被截获，攻击者由于没有私钥也无法破解数据。非对称加密算法的加解密速度低于对称加密算法，但是安全性更高。</p><h3 id="8，简单实现promise"><a href="#8，简单实现promise" class="headerlink" title="8，简单实现promise"></a>8，简单实现promise</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 简易版本的promise</span><br><span class="line">&#x2F;&#x2F; 第一步：列出三大块 this.then resolve&#x2F;reject fn(resolve, reject)</span><br><span class="line">&#x2F;&#x2F; 第二步：this.then负责注册所有的函数 resolve&#x2F;reject负责执行所有函数</span><br><span class="line">&#x2F;&#x2F; 第三步：在resolve&#x2F;reject里面要加上setTimeout，防止还没尽兴then注册，就直接执行resolve了</span><br><span class="line">&#x2F;&#x2F; 第四步：resolve&#x2F;reject里面要返回this，这样就可以链式调用了</span><br><span class="line">&#x2F;&#x2F; 第五步：三个状态的管理 pending fulfilled rejected</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  *****promise的链式调用，在then里面return一个promise这样才能then里面加上异步函数</span><br><span class="line">&#x2F;&#x2F; 加上了catch</span><br><span class="line">function PromiseM(fn) &#123;</span><br><span class="line">    var value &#x3D; null;</span><br><span class="line">    var callbacks &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F; 加入状态，为了解决在Promise异步操作成功之后调用的then注册的回调不会执行的问题</span><br><span class="line">    var state &#x3D; &#39;pending&#39;;</span><br><span class="line">    var _this &#x3D; this;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 注册所有的回调函数</span><br><span class="line">    this.then &#x3D; function (fulfilled, rejected) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果想链式promise，那就要在这边return一个new Promise</span><br><span class="line">        return new PromiseM(function (resolve, reject) &#123;</span><br><span class="line">            &#x2F;&#x2F; 异常处理</span><br><span class="line">            try &#123;</span><br><span class="line">                if (state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                    callbacks.push(fulfilled);</span><br><span class="line">                    &#x2F;&#x2F; 实现链式调用</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;) &#123;</span><br><span class="line">                    var data &#x3D; fulfilled(value);</span><br><span class="line">                    &#x2F;&#x2F; 为了能够让两个promise连接起来</span><br><span class="line">                    resolve(data);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (state &#x3D;&#x3D;&#x3D; &#39;rejected&#39;) &#123;</span><br><span class="line">                    var data &#x3D; rejected(data);</span><br><span class="line">                    &#x2F;&#x2F; 为了能让两个promise连接起来</span><br><span class="line">                    resolve(data);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">                _this.catch(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 执行所有的回调函数</span><br><span class="line">    function resolve(valueNew) &#123;</span><br><span class="line">        value &#x3D; valueNew;</span><br><span class="line">        state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">        execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 执行所有的回调函数</span><br><span class="line">    function reject(valueNew) &#123;</span><br><span class="line">        value &#x3D; valueNew;</span><br><span class="line">        state &#x3D; &#39;rejected&#39;;</span><br><span class="line">        execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function execute() &#123;</span><br><span class="line">        &#x2F;&#x2F; 加入延时机制，防止promise里面有同步函数导致resolve先执行，then还没注册上函数</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            callbacks.forEach(function(cb) &#123;</span><br><span class="line">                value &#x3D; cb(value);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.catch &#x3D; function (e) &#123;</span><br><span class="line">        console.log(JSON.stringify(e));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 经典 实现异步回调</span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1，http的状态码中，499是什么？如何出现499？如何排查解决？&quot;&gt;&lt;a href=&quot;#1，http的状态码中，499是什么？如何出现499？如何排查解决？&quot; class=&quot;headerlink&quot; title=&quot;1，http的状态码中，499是什么？如何出现499？如何排查解决？&quot;&gt;&lt;/a&gt;1，http的状态码中，499是什么？如何出现499？如何排查解决？&lt;/h3&gt;&lt;p&gt;499对应的是“client has closed connection”，客户端请求等待连接已经关闭，这很有可能是因为服务器端处理的时间过长，客户端等的‘不耐烦了’。还可能是因为两次提交post请求过快就会出现499。&lt;br&gt;解决方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端将timeout最大等待时间设置大一些。&lt;/li&gt;
&lt;li&gt;nginx上配置proxt_ignore_client_abort on;</summary>
    
    
    
    <category term="面试题" scheme="https://github.com/liubrook/liubrook.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面试题" scheme="https://github.com/liubrook/liubrook.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JS计算精度丢失问题</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/12/28/JS%E8%AE%A1%E7%AE%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/12/28/JS%E8%AE%A1%E7%AE%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/</id>
    <published>2019-12-28T15:41:05.000Z</published>
    <updated>2020-09-24T02:45:48.517Z</updated>
    
    <content type="html"><![CDATA[<p>JS运算中经常会遇到精度丢失的问题，对于这种情况可以采用以下方法来编写公共方法。</p><a id="more"></a>  <h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jQuery.add &#x3D; function(arg1, arg2) &#123;</span><br><span class="line"></span><br><span class="line">    var r1, r2, m;</span><br><span class="line">    </span><br><span class="line">    try &#123; r1 &#x3D; arg1.toString().split(&quot;.&quot;)[1].length &#125; catch (e) &#123; r1 &#x3D; 0 &#125;</span><br><span class="line">   </span><br><span class="line">    try &#123; r2 &#x3D; arg2.toString().split(&quot;.&quot;)[1].length &#125; catch (e) &#123; r2 &#x3D; 0 &#125;</span><br><span class="line">    </span><br><span class="line">    m &#x3D; Math.pow(10, Math.max(r1, r2))</span><br><span class="line">    </span><br><span class="line">    return (arg1 * m + arg2 * m) &#x2F; m</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">jQuery.cut &#x3D; function(arg1, arg2) &#123;</span><br><span class="line"> </span><br><span class="line">   var r1, r2, m, n;</span><br><span class="line"> </span><br><span class="line">   try &#123; r1 &#x3D; arg1.toString().split(&quot;.&quot;)[1].length &#125; catch (e) &#123; r1 &#x3D; 0 &#125;</span><br><span class="line"></span><br><span class="line">   try &#123; r2 &#x3D; arg2.toString().split(&quot;.&quot;)[1].length &#125; catch (e) &#123; r2 &#x3D; 0 &#125;</span><br><span class="line"></span><br><span class="line">   m &#x3D; Math.pow(10, Math.max(r1, r2));</span><br><span class="line">    &#x2F;&#x2F;last modify by deeka</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;动态控制精度长度</span><br><span class="line"></span><br><span class="line">    n &#x3D; (r1 &gt;&#x3D; r2) ? r1 : r2;</span><br><span class="line"></span><br><span class="line">    return ((arg1 * m - arg2 * m) &#x2F; m).toFixed(n);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.mul &#x3D; function(arg1, arg2) &#123;</span><br><span class="line"></span><br><span class="line">    var m &#x3D; 0, s1 &#x3D; arg1.toString(), s2 &#x3D; arg2.toString();</span><br><span class="line"></span><br><span class="line">    try &#123; m +&#x3D; s1.split(&quot;.&quot;)[1].length &#125; catch (e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    try &#123; m +&#x3D; s2.split(&quot;.&quot;)[1].length &#125; catch (e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    return Number(s1.replace(&quot;.&quot;, &quot;&quot;)) * Number(s2.replace(&quot;.&quot;, &quot;&quot;)) &#x2F; Math.pow(10, m)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">jQuery.div &#x3D; function(arg1, arg2) &#123;</span><br><span class="line"></span><br><span class="line">    var t1 &#x3D; 0, t2 &#x3D; 0, r1, r2;</span><br><span class="line"></span><br><span class="line">    try &#123; t1 &#x3D; arg1.toString().split(&quot;.&quot;)[1].length &#125; catch (e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    try &#123; t2 &#x3D; arg2.toString().split(&quot;.&quot;)[1].length &#125; catch (e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    with (Math) &#123;</span><br><span class="line"></span><br><span class="line">        r1 &#x3D; Number(arg1.toString().replace(&quot;.&quot;, &quot;&quot;))</span><br><span class="line"></span><br><span class="line">        r2 &#x3D; Number(arg2.toString().replace(&quot;.&quot;, &quot;&quot;))</span><br><span class="line"></span><br><span class="line">        return (r1 &#x2F; r2) * pow(10, t2 - t1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;JS运算中经常会遇到精度丢失的问题，对于这种情况可以采用以下方法来编写公共方法。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Linux下安装node</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/12/27/Linux%E4%B8%8B%E5%AE%89%E8%A3%85node/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/12/27/Linux%E4%B8%8B%E5%AE%89%E8%A3%85node/</id>
    <published>2019-12-27T09:05:45.000Z</published>
    <updated>2020-10-07T09:37:07.171Z</updated>
    
    <content type="html"><![CDATA[<p>今天在学习docker方面的知识，需要在服务器上安装node和npm，安装过程中碰到了一些问题，做一下记录。</p><a id="more"></a>  <h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>服务器系统：CentOS 7.6 64位</p><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><ul><li>打开node下载地址<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">Node下载</a>。</li><li>选择长期支持版-Linux二进制文件(x64)-(64-bit).(这个根据自己的系统来选择)。</li><li>右键复制链接地址。</li><li>打开服务器- cd /usr/local (这个看你习惯把这些工具安装到哪里)。</li><li>wget <a href="https://nodejs.org/dist/v12.18.4/node-v12.18.4-linux-x64.tar.xz(这里是你刚才复制的链接地址)。" target="_blank" rel="noopener">https://nodejs.org/dist/v12.18.4/node-v12.18.4-linux-x64.tar.xz(这里是你刚才复制的链接地址)。</a></li><li>下载完成后 tar xf node-v12.18.4-linux-x64.tar.xz(解压)</li><li>解压后把Node的路径链接到环境里</li><li>export NODE_HOME=/usr/local/node-v12.18.4-linux-x64/bin(注意这里是你安装的版本，不要搞错了)</li><li>export PATH=$NODE_HOME:$PATH</li></ul><p>这个时候你用node -v或者npm -v就可以查看了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天在学习docker方面的知识，需要在服务器上安装node和npm，安装过程中碰到了一些问题，做一下记录。&lt;/p&gt;</summary>
    
    
    
    <category term="Node" scheme="https://github.com/liubrook/liubrook.github.io/categories/Node/"/>
    
    
    <category term="Node" scheme="https://github.com/liubrook/liubrook.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序常见问题(1)</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/12/24/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-1/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/12/24/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-1/</id>
    <published>2019-12-24T01:54:28.000Z</published>
    <updated>2020-09-24T02:45:30.045Z</updated>
    
    <content type="html"><![CDATA[<p>以下是在做小程序开发过程中碰到的一些常见问题.</p><a id="more"></a>  <p>1、如果你在微信开发者工具中发现并没有换行，不要惊讶，利用真机预览一下，就可以看到效果了。<br>接下来看看代码，其实很简单，代码中使用了大家熟知的\r\n</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wx.showModal(&#123;</span><br><span class="line">    title: &#39;提示&#39;,</span><br><span class="line">    content: &#39;第一行内容\r\n第二行内容\r\n第三行内容\r\n第四行内容&#39;,</span><br><span class="line">    success: function (res) &#123; </span><br><span class="line">    if (res.confirm) &#123;</span><br><span class="line">            console.log(&#39;用户点击确定&#39;)</span><br><span class="line">        &#125; else if (res.cancel) &#123;</span><br><span class="line">            console.log(&#39;用户点击取消&#39;)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2、使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button::after&#123; border: none; &#125;</span><br></pre></td></tr></table></figure><p>来去除边框</p><p>3、text自动换行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word-break: keep-all;</span><br><span class="line">word-wrap: break-word</span><br></pre></td></tr></table></figure><p>4、弹出框禁止底层页面滚动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catchtouchmove&#x3D;&quot;true&quot;</span><br></pre></td></tr></table></figure><p>开发者工具上测试无效，真机有效</p><p>5、微信小程序隐藏scroll-view滚动条的简单实现就是在wxss里加入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">::-webkit-scrollbar&#123;</span><br><span class="line">  width: 0;</span><br><span class="line">  height: 0;</span><br><span class="line">  color: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;以下是在做小程序开发过程中碰到的一些常见问题.&lt;/p&gt;</summary>
    
    
    
    <category term="微信小程序" scheme="https://github.com/liubrook/liubrook.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="https://github.com/liubrook/liubrook.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript-15-DOM-4</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/12/20/Javascript-15-DOM-4/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/12/20/Javascript-15-DOM-4/</id>
    <published>2019-12-20T14:34:35.000Z</published>
    <updated>2020-09-24T02:46:40.279Z</updated>
    
    <content type="html"><![CDATA[<h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>为了让开发人员更方便地控制页面，“DOM2级遍历和范围”模块定义了“范围”(range)接口。通过范围可以选择文档中的一个区域，而不必考虑修改节点的界限。</p><a id="more"></a>  <h4 id="DOM中的范围"><a href="#DOM中的范围" class="headerlink" title="DOM中的范围"></a>DOM中的范围</h4><p>DOM2级在Document类型中定义了createRange()方法。在兼容DOM的浏览器中，这个方法属于document对象。使用hasFeature()或者直接检测该方法，都可以确定浏览器是否支持范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var supportsRange &#x3D; document.implementation.hasFeature(&quot;Range&quot;, &quot;2.0&quot;);</span><br><span class="line">var alsoSupportsRange &#x3D; (typeof document.createRange &#x3D;&#x3D; &quot;function&quot;);</span><br><span class="line">&#x2F;&#x2F; 如果浏览器支持，那么就可以使用createRange()来创建DOM范围。</span><br><span class="line">var range &#x3D; document.createRange();</span><br></pre></td></tr></table></figure><p>新创建的范围也直接与创建它的文档关联在一起，不能用于其他文档。创建了范围之后，接下来就可以使用它在后台选择文档中的特定部分。而创建范围并设置了其位置之后，还可以针对范围的内容执行很多种操作，从而实现对底层DOM树的更精细的控制。</p><p>每个范围由一个Range类型的实例表示，这个实例拥有很多属性和方法。</p><ul><li>startContainer:包含范围起点的节点(即选区中第一个节点的父节点)。</li><li>startOffset：范围在startContainer中起点的偏移量。如果startContainer是文本姐弟哪、注释节点或CDATA节点，那么startOffset就是范围起点之前跳过的字符数量。否则。startOffset就是范围中第一子节点的索引。</li><li>endContainer：包含范围终点的节点(即选区中最后一个节点的父节点)。</li><li>endOffset：范围在endContainer中终点的偏移量(与startOffset遵循相同的取值规则)。</li><li>commonAncestorContainer: startContainer和endContainer共同的祖先节点在文档树中位置最深的那个。<br>在把防伪放到文档中特定的位置时，这些属性都会被赋值。    </li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;范围&quot;&gt;&lt;a href=&quot;#范围&quot; class=&quot;headerlink&quot; title=&quot;范围&quot;&gt;&lt;/a&gt;范围&lt;/h3&gt;&lt;p&gt;为了让开发人员更方便地控制页面，“DOM2级遍历和范围”模块定义了“范围”(range)接口。通过范围可以选择文档中的一个区域，而不必考虑修改节点的界限。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript-15-DOM-3</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/12/15/Javascript-15-DOM-3/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/12/15/Javascript-15-DOM-3/</id>
    <published>2019-12-15T07:16:42.000Z</published>
    <updated>2020-09-15T09:57:09.683Z</updated>
    
    <content type="html"><![CDATA[<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>“DOM2级遍历和范围”模块定义了两个用于辅助完成顺序遍历DOM结构的类型：NodeIterator和TreeWalker。这两个类型能够基于给定的起点对DOM结构执行深度优先(depth-first)的遍历操作。在于DOM兼容的浏览器中都可以访问到这些类型的对象。IE不支持DOM遍历。使用下列代码可以检测浏览器对DOM2级遍历能力的支持情况。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var supportsTraversals &#x3D; document.implementation.hasFeature(&quot;Traversal&quot;, &quot;2.0&quot;);</span><br><span class="line">var supportsNodeIterator &#x3D; (typeof document.createNodeIterator &#x3D;&#x3D; &quot;function&quot;);</span><br><span class="line">var supportsTreeWalker &#x3D; (typeof document.createTreeWalker &#x3D;&#x3D; &quot;function&quot;);</span><br></pre></td></tr></table></figure><p>如前所述，DOM遍历是深度优先的DOM结构遍历，也就是说，移动的方向至少有两个(取决于使用的遍历类型)。遍历以给定节点为根，不可能向上超出DOM树的根节点。</p><h4 id="NodeIterator"><a href="#NodeIterator" class="headerlink" title="NodeIterator"></a>NodeIterator</h4><p>可以使用document.createNodeIterator()方法创建它的新实例。接受以下4个参数。</p><ul><li>root：想要作为搜索起点的树中的节点。</li><li>whatToShow：表示想要访问哪些节点的数字代码。</li><li>filter：是一个NodeFilter对象，或者一个表示应该接受还是拒绝某种特定节点的函数。</li><li>entityReferenceExpansion：布尔值，表示是否要拓展实体引用。这个参数在HTML中没有用，因为其中的实体引用不能拓展。</li></ul><p>whatToShow参数是一个位掩码，通过应用一或多个过滤器(filter)来确定要访问哪些节点。这个参数的值以常量的形式在NodeFilter类型中定义，如下所示：</p><ul><li><p>NodeFilter.SHOW_ALL：显示所有类型的节点。</p></li><li><p>NodeFilter.SHOW_ELEMENT：显示元素节点。</p></li><li><p>NodeFilter.SHOW_ATTRIBUTE：显示特性节点。由于DOM结构原因，实际上不能使用这个值。</p></li><li><p>NodeFilter.SHOW_TEXT：显示文本节点。</p></li><li><p>NodeFilter.SHOW_CDATA_SECTION：显示CDATA节点。对HTML页面没用。</p></li><li><p>NodeFilter.SHOW_ENTITY_REFERENCE：显示实体引用节点。对HTML页面没用。</p></li><li><p>NodeFilter.SHOW_ENTITYE：显示实体节点。对HTML页面没用。</p></li><li><p>NodeFilter.SHOW_PROCESSING_INSTRUCTION：显示处理指令节点。对HTML页面没用。</p></li><li><p>NodeFilter.SHOW_COMMENT：显示注释节点。</p></li><li><p>NodeFilter.SHOW_DOCUEMNT：显示文档节点。</p></li><li><p>NodeFilter.SHOW_DOCUMENT_TYPE：显示文档类型节点。</p></li><li><p>NodeFilter.SHOW_DOCUMENT_FRAGMENT：显示文档片段节点。对HTML页面没用。</p></li><li><p>NodeFilter.SHOW_NOTATION：显示符号节点。对HTML页面没用。</p><p>除了NodeFilter.SHOW_ALL之外，可以使用按位或操作符来组合多个选项。</p><p>可以通过createNodeIterator()方法的filter参数来指定自定义的NodeFilter对象，或者指定一个功能类似节点过滤器(node filter)的函数，每个NOdeFilter对象只有一个方法，即acceptNode()；如果应该访问给定的节点，该方法返回NodeFilter.FILTER_ACCEPT，如果不应该访问给定的节点，该方法返回NodeFilter.FILTER_SKIP。由于NodeFilter是一个抽象的类型，因此不能直接创建它的实例。在必要时，只要创建一个包含acceptNode()方法的对象，然后将这个对象传入createNodeIterator()中即可。</p><p>NodeIterator类型的两个主要方法是nextNode()和previousNode()。顾名思义，在深度优先的DOM子树遍历中，nextNode()方法主要用于向前前进一步，而previousNode()用于向后后退一步。在刚刚创建的NodeIterator对象中，有一个内部指针指向根节点，因此第一次调用nextNode()会返回根节点。当遍历到DOM子树的最后一个节点时，nextNode()返回null。previousNode()方法的工作机制类似。当遍历到DOM子树的最后一个节点，且previousNode()返回根节点之后，再次调用它就会返回null。</p><p>由于nextNode()和previousNode()方法都基于NodeIterator在DOM结构中的内部指针工作，所以DOM结构的变化会反映在遍历的结果中。</p><h4 id="TreeWalker"><a href="#TreeWalker" class="headerlink" title="TreeWalker"></a>TreeWalker</h4><p>TreeWalker是NodeIterator的一个更高级的版本。除了包括nextNode()和previousNode()在内的相同的功能之外，这个类型还提供了下列用于在不同方向上遍历DOM结构的方法。</p><ul><li>parentNode()：遍历到当前节点的父节点。</li><li>firstChild()：遍历到当前节点的第一个子节点。</li><li>lastChild()：遍历到当前节点的最后一个子节点。</li><li>nextSibing()：遍历到当前节点的下一个同辈节点。</li><li>previousSibing()：遍历到当前节点的上一个同辈节点。</li></ul></li></ul><p>创建TreeWalker对象要使用document.createTreeWalker()方法，这个方法接受的4个参数与document.createNodeIterator()方法相同：作为遍历起点的根节点、要显示的节点类型、过滤器、一个表示是否拓展实体引用的布尔值。</p><p>TreeWalker真正强大的地方在于能够在DOM结构中沿任何方向移动。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;遍历&quot;&gt;&lt;a href=&quot;#遍历&quot; class=&quot;headerlink&quot; title=&quot;遍历&quot;&gt;&lt;/a&gt;遍历&lt;/h3&gt;&lt;p&gt;“DOM2级遍历和范围”模块定义了两个用于辅助完成顺序遍历DOM结构的类型：NodeIterator和TreeWalker。这两个类型能够基于给定的起点对DOM结构执行深度优先(depth-first)的遍历操作。在于DOM兼容的浏览器中都可以访问到这些类型的对象。IE不支持DOM遍历。使用下列代码可以检测浏览器对DOM2级遍历能力的支持情况。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript-15-DOM-2</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/12/05/Javascript-15-DOM-2/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/12/05/Javascript-15-DOM-2/</id>
    <published>2019-12-05T14:24:32.000Z</published>
    <updated>2020-09-15T09:56:26.774Z</updated>
    
    <content type="html"><![CDATA[<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p>在HTML中定义样式的方式有3种：</p><ul><li>通过<code>&lt;link/&gt;</code>元素包含外部样式表文件。</li><li>使用<code>&lt;style/&gt;</code>元素定义嵌入式样式。</li><li>使用style特性定义针对特定元素的样式。<a id="more"></a><h4 id="访问元素的样式"><a href="#访问元素的样式" class="headerlink" title="访问元素的样式"></a>访问元素的样式</h4></li></ul><p>任何支持style特性的HTML元素在Javascript中都有一个对应的style属性。这个style对象是CSSStyleDeclaration的实例，包含着通过HTML的style特性指定的所有样式信息，但不包含与外部样式表或嵌入样式表经层叠而来的样式。在style特性中指定的任何CSS属性都将表现为这个style对象的相应属性。对于使用短划线(分割不同词汇，例如background-image)的CSS属性名，必须将其转换成驼峰大小写形式，才能通过Javascript来访问。</p><p>多数情况下，都可以通过简单地转换属性名的格式来实现转换。其中一个不能直接转换的CSS属性就是float。由于float是JavaScript的保留字，因此不能用作属性名。</p><h5 id="DOM样式属性和方法"><a href="#DOM样式属性和方法" class="headerlink" title="DOM样式属性和方法"></a>DOM样式属性和方法</h5><ul><li>cssText：如前所述，通过它能够访问到style特性中的CSS代码。</li><li>length：应用给元素的CSS属性的数量。</li><li>parentRule：表示CSS信息的CSSRule对象。</li><li>getPropertyCSSValue(propertyName)：返回包含给定属性值的CSSValue类型。</li><li>getPropertyPriority(propertyName)：如果给定的属性使用了！important设置，则返回“important”；否则，则返回空字符串。</li><li>getPropertyValue(propertyName)：返回给定属性的字符串值。</li><li>item(index)：返回给定位置的CSS属性的名称。</li><li>removeProperty(propertyName)：从样式中删除给定属性。</li><li>setProperty(propertyName, value, priority)：将给定属性设置为相应的值，并加上优先权标志(“important”或者一个空字符串)。</li></ul><p>通过cssText属性可以访问style特性中的CSS代码。在读取模式下，cssText的值会重写整个styl特性的值；也就是说，以前通过style特性指定的样式信息都将丢失。</p><h5 id="计算的样式"><a href="#计算的样式" class="headerlink" title="计算的样式"></a>计算的样式</h5><p>getComputedStyle()方法接受两个参数：要取得计算样式的元素和一个伪元素字符串。如果不需要伪元素信息，第二个参数可以是null。该方法返回一个CSSStyleDeclaration对象(与style属性的类型相同)，其中包含当前元素的所有计算的样式。</p><p>无论在哪个浏览器中，最重要的一条是要记住所有计算的样式都是只读的；不能修改计算后样式对象中的CSS属性。此外，计算后的样式也包含属于浏览器内部样式表的样式信息，因此任何具有默认值的CSS属性都会表现在计算后的样式中。</p><h4 id="操作样式表"><a href="#操作样式表" class="headerlink" title="操作样式表"></a>操作样式表</h4><p>CSSStyleSheet类型表示的是样式表，包括通过<code>&lt;link&gt;</code>元素包含的样式表和在<code>&lt;style&gt;</code>元素中定义的样式表。它只表示样式表，而不管这些样式表在HTML中是如何定义的。</p><p>CSSStyleSheet继承自StyleSheet，后者可以作为一个基础接口来定义非CSS样式表。从StyleSheet接口继承而来的属性如下：</p><ul><li>disabled：表示样式表是否被禁用的布尔值。这个属性是可读/写的，将这个值设置为true可以禁用样式表。</li><li>href：如果样式表是通过<code>&lt;link&gt;</code>包含的，则是样式表的URL，否则是null；</li><li>media：当前样式表支持的所有媒体类型的集合。与所有DOM集合一样，这个集合也有一个length属性和一个item()方法。也可以使用方括号语法取得集合中特定的项。如果集合是空列表，表示样式表适用于所有媒体。</li><li>ownerNode：指向拥有当前样式表的节点的指针，样式表可能是在HTML中通过<code>&lt;link&gt;</code>或<code>&lt;style&gt;</code>引入的(在XML中可能使用过处理指令引入的)。如果当前样式表是其他样式表通过@import导入的，则这个属性为null。IE不支持这个属性。</li><li>parentStyleSheet：在当前样式表是通过@import导入的情况下，这个属性是一个指向导入它的样式表的指针。</li><li>title：ownerNode中title属性的值。</li><li>type：表示样式表类型的字符串。对CSS样式表而言，这个字符串是“type/css”。<br>除了disabled属性之外，其他属性都是只读的。在支持以上所有这些属性的基础上，CSSStyleSheet类型还支持下列属性和方法：</li><li>cssRules：样式表中包含的样式规则的集合。IE不支持这个属性，但有一个类似的rules属性。</li><li>ownerRule：如果样式表是通过@import导入的，这个属性就是一个指针，指向表示导入的规则，否则，值为null。IE不支持这个属性。</li><li>deleteRule(index)：删除cssRules集合中指定位置的规则。IE不支持这个方法，但支持一个类似的removeRule()方法。</li><li>insertRule(rule，index)：向cssRules中指定的位置插入rule字符串。IE不支持这个方法，但支持一个类似的addRule()方法。</li></ul><p>应用与文档的所有样式表是通过document.styleSheets集合来表示的。通过这个集合的length属性可以获知文档中样式表的数量，而通过方括号语法或item()方法可以访问每一个样式表。</p><h4 id="元素大小"><a href="#元素大小" class="headerlink" title="元素大小"></a>元素大小</h4><h5 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h5><p>偏移量(offset dimension)，包括元素在屏幕上占用的所有可见的空间。元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条、边框大小(不包括外边距)。通过下列4个属性可以取得元素的偏移量：</p><ul><li>offsetHeight：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、(可见的)水瓶滚动条的高度、上边框高度和下边框高度。</li><li>offsetWidth：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、(可见的)垂直滚动条的宽度、左边框宽度和右边框宽度。</li><li>offsetLeft：元素的左外边框至包含元素的左内边框之间的像素距离。</li><li>offsetTop：元素的上外边框至包含元素的上内边框之间的像素距离。</li></ul><h5 id="客户区大小"><a href="#客户区大小" class="headerlink" title="客户区大小"></a>客户区大小</h5><p>元素的客户区大小(client dimension)指的是元素内容及其内边距所占据的空间大小。</p><ul><li>clientWidth：元素内容区宽度加上左右内边距宽度。</li><li>clientHeight：元素内容区高度加上上下内边距高度。</li></ul><h5 id="滚动大小"><a href="#滚动大小" class="headerlink" title="滚动大小"></a>滚动大小</h5><p>滚动大小(scroll dimension)，指的是包含滚动内容的元素的大小。以下4个与滚动大小相关的属性：</p><ul><li>scrollHeight：在没有滚动条的情况下，元素内容的总高度。</li><li>scrollWidth：在没有滚动条的情况下，元素内容的总宽度。</li><li>scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。</li><li>scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。</li></ul><h5 id="确定元素大小"><a href="#确定元素大小" class="headerlink" title="确定元素大小"></a>确定元素大小</h5><p>getBoundingClientRect()方法，该方法返回一个矩形对象，包含4个属性：left、top、right、bottom。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;样式&quot;&gt;&lt;a href=&quot;#样式&quot; class=&quot;headerlink&quot; title=&quot;样式&quot;&gt;&lt;/a&gt;样式&lt;/h3&gt;&lt;p&gt;在HTML中定义样式的方式有3种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过&lt;code&gt;&amp;lt;link/&amp;gt;&lt;/code&gt;元素包含外部样式表文件。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;&amp;lt;style/&amp;gt;&lt;/code&gt;元素定义嵌入式样式。&lt;/li&gt;
&lt;li&gt;使用style特性定义针对特定元素的样式。</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript-15-DOM-1</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/12/04/Javascript-15-DOM-1/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/12/04/Javascript-15-DOM-1/</id>
    <published>2019-12-04T11:33:10.000Z</published>
    <updated>2020-09-15T09:55:41.447Z</updated>
    
    <content type="html"><![CDATA[<p>DOM1级主要定义的是HTML和XML文档的底层结构。DOM2和DOM3级则在这个结构的基础上引入了更多的交互能力，也支持了更高级的XML特性。为此，DOM2和DOM3级分为许多模块(模块之间具有某种关联)，分别描述了DOM的某个非常具体的子集。这些模块如下：</p><ul><li>DOM2级核心：在1级核心基础上构建，为节点添加了更多的方法和属性。</li><li>DOM2级视图：为文档定义了基于样式信息的不同视图。</li><li>DOM2级事件：说明了如何使用事件与DOM文档交互。</li><li>DOM2级样式：定义了如何以编程方式来访问和改变CSS样式信息。</li><li>DOM2级遍历和范围：引入了遍历DOM文档和选择其特定部分的新接口。</li><li>DOM2级HTML：在1级HTML基础上构建，添加了更多属性、方法、新接口。<a id="more"></a><h3 id="DOM变化"><a href="#DOM变化" class="headerlink" title="DOM变化"></a>DOM变化</h3></li></ul><p>DOM2级和3级的目的在于扩展DOM API，以满足操作XML的所有需求，同时提供更好的错误处理及特性检测能力。从某种意义上讲，实现这一目的很大程度意味着对命名空间的支持。“DOM2级核心”没有引入新类型，它只是在DOM1级的基础上通过增加新方法和新属性来增加了既有类型。“DOM3级核心”同样增强了既有类型，但也引入了一些新类型，</p><p>类似地，“DOM2 级视图”和“DOM2 级HTML”模块也增强了DOM 接口，提供了新的属性和方法。由于这两个模块很小，因此我们将把它们与“DOM2 级核心”放在一起，讨论基本JavaScript 对象的变化。可以通过下列代码来确定浏览器是否支持这些DOM 模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var supportsDOM2Core &#x3D; document.implementation.hasFeature(&quot;Core&quot;, &quot;2.0&quot;);</span><br><span class="line">var supportsDOM3Core &#x3D; document.implementation.hasFeature(&quot;Core&quot;, &quot;3.0&quot;);</span><br><span class="line">var supportsDOM2HTML &#x3D; document.implementation.hasFeature(&quot;HTML&quot;, &quot;2.0&quot;);</span><br><span class="line">var supportsDOM2Views &#x3D; document.implementation.hasFeature(&quot;Views&quot;, &quot;2.0&quot;);</span><br><span class="line">var supportsDOM2XML &#x3D; document.implementation.hasFeature(&quot;XML&quot;, &quot;2.0&quot;);</span><br></pre></td></tr></table></figure><h4 id="针对XML命名空间的变化"><a href="#针对XML命名空间的变化" class="headerlink" title="针对XML命名空间的变化"></a>针对XML命名空间的变化</h4><p>有了XML命名空间，不同XML文档的元素就可以混合在一起，共同构成格式良好的文档，而不必担心发生命名冲突。从技术上说，HTML不支持XML命名空间，但XHTML支持XML命名空间。</p><p>XHTML的命名空间是<a href="http://www.w3.org/1999/xhtml，在任何格式良好XHTML页面中，都应该将其包含在`" target="_blank" rel="noopener">http://www.w3.org/1999/xhtml，在任何格式良好XHTML页面中，都应该将其包含在`</a><html>`元素中，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;Example XHTML page&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        Hello world!</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h5 id="Node类型的变化"><a href="#Node类型的变化" class="headerlink" title="Node类型的变化"></a>Node类型的变化</h5><p>在DOM2级中，Node类型包含下列特定于命名空间的属性。</p><ul><li>localName：不带命名空间前缀的节点名称。</li><li>namespaceURI：命名空间URI或者(在未指定的情况下是)null.</li><li>prefix：命名空间前缀或者(在未指定的情况下是)null。</li></ul><p>DOM3级在此基础上更进一步，又引入了下列与命名空间有关的方法。</p><ul><li>isDefaultNamespace(namespaceURI)：在指定的namespaceURI是当前节点的默认命名空间的情况下返回true。</li><li>lookupNamespaceURI(prefix)：返回给定prefix的命名空间。</li><li>lookupPrefix(namespaceURI)：返回给定namespaceURI的前缀。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">alert(document.body.isDefaultNamespace(&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;); &#x2F;&#x2F;true</span><br><span class="line">&#x2F;&#x2F;假设svg 中包含着对&lt;s:svg&gt;的引用</span><br><span class="line">alert(svg.lookupPrefix(&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot;)); &#x2F;&#x2F;&quot;s&quot;</span><br><span class="line">alert(svg.lookupNamespaceURI(&quot;s&quot;)); &#x2F;&#x2F;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Document类型的变化"><a href="#Document类型的变化" class="headerlink" title="Document类型的变化"></a>Document类型的变化</h5><p>DOM2级中的Document类型也发生了变化，包含下列与命名空间有关的方法。</p><ul><li>createElementNS(namespaceURI, tagName)：使用给定的tagName创建一个属于命名空间namespaceURI的新元素。</li><li>createAttributeNS(namespaceURI, attributeName)：使用给定的attributeName创建一个属于命名空间namespaceURI的新特性。</li><li>getElementsBytagNameNS(namespaceURI, tagName)：返回属于命名空间namespaceURI的tagName元素的NodeList。</li></ul><p>使用这些方法时需要传入表示命名空间的URI(而不是命名空间前缀)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建一个新的SVG 元素</span><br><span class="line">var svg &#x3D; document.createElementNS(&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot;,&quot;svg&quot;);</span><br><span class="line">&#x2F;&#x2F;创建一个属于某个命名空间的新特性</span><br><span class="line">var att &#x3D; document.createAttributeNS(&quot;http:&#x2F;&#x2F;www.somewhere.com&quot;, &quot;random&quot;);</span><br><span class="line">&#x2F;&#x2F;取得所有XHTML 元素</span><br><span class="line">var elems &#x3D; document.getElementsByTagNameNS(&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;, &quot;*&quot;);tps:&#x2F;&#x2F;blog.csdn.net&#x2F;Jane617_min&#x2F;article&#x2F;details&#x2F;49683873</span><br></pre></td></tr></table></figure><h5 id="Element类型的变化"><a href="#Element类型的变化" class="headerlink" title="Element类型的变化"></a>Element类型的变化</h5><ul><li>getAttributeNS(namespaceURI,localName)：取得属于命名空间namespaceURI 且名为localName 的特性。</li><li>getAttributeNodeNS(namespaceURI,localName)：取得属于命名空间namespaceURI 且名为localName 的特性节点。</li><li>getElementsByTagNameNS(namespaceURI, tagName)：返回属于命名空间namespaceURI的tagName 元素的NodeList。</li><li>hasAttributeNS(namespaceURI,localName)：确定当前元素是否有一个名为localName的特性，而且该特性的命名空间是namespaceURI。注“DOM2 级核心”也增加了一个hasAttribute()方法，用于不考虑命名空间的情况。</li><li>removeAttriubteNS(namespaceURI,localName)：删除属于命名空间namespaceURI 且名为localName 的特性。</li><li>setAttributeNS(namespaceURI,qualifiedName,value)：设置属于命名空间namespaceURI 且名为qualifiedName 的特性的值为value。</li><li>setAttributeNodeNS(attNode)：设置属于命名空间namespaceURI 的特性节点。<br>除了第一个参数之外，这些方法与DOM1 级中相关方法的作用相同；第一个参数始终都是一个命名空间URI。</li></ul><h5 id="NameNodeMap类型的变化"><a href="#NameNodeMap类型的变化" class="headerlink" title="NameNodeMap类型的变化"></a>NameNodeMap类型的变化</h5><p>NamedNodeMap 类型也新增了下列与命名空间有关的方法。由于特性是通过NamedNodeMap 表示的，因此这些方法多数情况下只针对特性使用。</p><ul><li>getNamedItemNS(namespaceURI,localName)：取得属于命名空间namespaceURI 且名为localName 的项。</li><li>removeNamedItemNS(namespaceURI,localName)：移除属于命名空间namespaceURI 且名为localName 的项。</li><li>setNamedItemNS(node)：添加node，这个节点已经事先指定了命名空间信息。<br>由于一般都是通过元素访问特性，所以这些方法很少使用。</li></ul><h4 id="其他方面的变化"><a href="#其他方面的变化" class="headerlink" title="其他方面的变化"></a>其他方面的变化</h4><h5 id="DocumentType类型的变化"><a href="#DocumentType类型的变化" class="headerlink" title="DocumentType类型的变化"></a>DocumentType类型的变化</h5><p>DOcumentType类型新增了3个属性：publicId、systemId、internalSubset。其中，前两个属性表示的是文档类型声明中的两个信息段，这两个信息段在DOM1级中是没有办法访问到的。</p><h5 id="Document类型的变化-1"><a href="#Document类型的变化-1" class="headerlink" title="Document类型的变化"></a>Document类型的变化</h5><p>Document类型的变化中唯一与命名空间无关的方法是importNode()。这个方法的用途是从一个文档中取得一个节点，然后将其导入另一个文档，使其成为这个文档结构的一部分。需要注意的是，每个节点都有一个ownerDocument属性，表示所属文档。如果调用appendChild()时传入的节点属于不同的文档(ownerDocument属性的值不一样)，则会导致错误。但在调用importNode()时传入不同文档的节点则会返回一个新节点，这个新节点的所有权归当前文档所有。</p><p>importNode()方法与Element的cloneNode()方法非常相似，它接受两个参数：要复制的节点和一个表示是否复制子节点的布尔值。返回的结果是原来节点的副本，但能够在当前文档中使用。</p><p>createDocumenttype()方法用于创建一个新的Documenttype节点，接受三个参数：文档类型名称、publicId、systemId。由于既有文档的文档类型不能改变，因此createDocumentType()只在创建新文档时有用；创建新文档需要用到createDocument()方法。这个方法接受3个参数：针对文档中元素的namespaceURI、文档元素的标签名、新文档的文档类型。</p><p>createHTML-Document()方法用来创建一个完整的HTML文档，包括<code>&lt;html&gt;、&lt;head&gt;、&lt;title&gt;、&lt;body&gt;</code>元素。这个方法只接受一个参数，即新创建文档的标题(放在<code>&lt;title&gt;</code>元素中的字符串)，返回新的HTML文档。</p><h5 id="Node类型的变化-1"><a href="#Node类型的变化-1" class="headerlink" title="Node类型的变化"></a>Node类型的变化</h5><p>Node类型中唯一与命名空间无关的变化，就是添加了isSupported()方法。与DOM1级为document.implementation引入的hasFeature()方法类似，isSupported()方法用于确定当前节点具有什么能力。这个方法接受两个参数：特性名和版本号。如果浏览器实现了相应特性，而且能够基于给定节点执行该特性，isSupported()就返回true。由于不同实现在决定对什么特性返回true或false时并不一致，这个方法同样也村子啊与hasFeature()方法相同的问题。为此，建议在确定某个特性是否可用时，最好还是使用能力检测。</p><p>DOM3级引入了两个辅助比较节点的方法：isSameNode()和isEuqalNode()。这两个方法都接受一个节点参数，并在传入节点与引用的节点相同或相等时返回true。所谓相同，值得时两个节点引用的时同一个对象。所谓相等，指的是两个节点是相同的类型，具有相等的属性(nodeName、nodeValue等)，而且它们的attributes和childNodes属性也相等(相同位置包含相同的值)。</p><p>setUserData()方法会将数据指定给节点，它接受三个参数：要设置的键、实际的数据和处理函数。</p><h5 id="框架的变化"><a href="#框架的变化" class="headerlink" title="框架的变化"></a>框架的变化</h5><p>框架和内嵌框架分别用HTMLFrameElement和HTMLIFrameElement表示，它们在DOM2级中都有了一个新属性-contentDocument。这个属性包含一个指针，指向表示框架内容的文档对象。在此之前，无法直接通过元素取得这个文档对象</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;DOM1级主要定义的是HTML和XML文档的底层结构。DOM2和DOM3级则在这个结构的基础上引入了更多的交互能力，也支持了更高级的XML特性。为此，DOM2和DOM3级分为许多模块(模块之间具有某种关联)，分别描述了DOM的某个非常具体的子集。这些模块如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOM2级核心：在1级核心基础上构建，为节点添加了更多的方法和属性。&lt;/li&gt;
&lt;li&gt;DOM2级视图：为文档定义了基于样式信息的不同视图。&lt;/li&gt;
&lt;li&gt;DOM2级事件：说明了如何使用事件与DOM文档交互。&lt;/li&gt;
&lt;li&gt;DOM2级样式：定义了如何以编程方式来访问和改变CSS样式信息。&lt;/li&gt;
&lt;li&gt;DOM2级遍历和范围：引入了遍历DOM文档和选择其特定部分的新接口。&lt;/li&gt;
&lt;li&gt;DOM2级HTML：在1级HTML基础上构建，添加了更多属性、方法、新接口。</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript-14-DOM-4</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/11/28/Javascript-14-DOM-4/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/11/28/Javascript-14-DOM-4/</id>
    <published>2019-11-28T02:14:18.000Z</published>
    <updated>2020-09-15T09:54:55.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h3><p>注释在DOM中是通过Comment类型来表示的。Comment节点具有下列特征：</p><a id="more"></a><ul><li>nodeType的值为8；</li><li>nodeName的值为“#comment”；</li><li>nodeValue的值是注释的内容；</li><li>parentNode可能是Document或Element；</li><li>不支持(没有)子节点；</li></ul><p>Comment类型与Text类型继承自相同的基类，因此它拥有除了splitText()之外所有字符串操作方法。与Text类型相似，也可以通过nodeValue或data属性来取得注释的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注释节点可以通过其父节点来访问，以下面的代码为例</span><br><span class="line">&lt;div id&#x3D;&quot;myDiv&quot;&gt;&lt;!-- A comment --&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#x2F;&#x2F; 在此，注释节点是&lt;div&gt;元素的一个子节点，因此可以通过下面的代码来访问它</span><br><span class="line">var div &#x3D; document.getElementById(&#39;myDiv&#39;);</span><br><span class="line">var comment &#x3D; div.firstChild;</span><br><span class="line">alert(comment.data); &#x2F;&#x2F; &quot;A comment&quot;</span><br></pre></td></tr></table></figure><p>使用document.createComment()并为其传递注释文本也可以创注释节点，如下面的例子所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var comment &#x3D; document.createComment(&quot;A comment&quot;);</span><br></pre></td></tr></table></figure><h3 id="CDATASection类型"><a href="#CDATASection类型" class="headerlink" title="CDATASection类型"></a>CDATASection类型</h3><p>CDATASection类型只针对基于XML的文档，表示的是CDATA区域。与Comment类似，继承自Text类型，因此拥有除了splitText()之外的所有字符串操作方法。具有以下特征：</p><ul><li>nodeType的值为4；</li><li>nodeName的值为“#cdata-section”；</li><li>nodeValue的值是CDATA区域中的内容；</li><li>parentNode可能是Document或Element；</li><li>不支持(没有)子节点；</li></ul><p>在真正的XML文档中，可以使用document.createCDATASection()来创建CDATA区域，只需为其传入节点的内容即可。</p><h3 id="DucumentType类型"><a href="#DucumentType类型" class="headerlink" title="DucumentType类型"></a>DucumentType类型</h3><p>该类型在Web浏览器中并不常用，仅有Firefox、Safari、Opera支持。DocumentType包含着与文档的doctype有关的所有信息，它具有下列特征：</p><ul><li>nodeType的值为10;</li><li>nodeName的值为doctype的名称；</li><li>nodeValue的值为null；</li><li>parentNode是Document；</li><li>不支持(没有)子节点；</li></ul><h3 id="DocumentFragment类型"><a href="#DocumentFragment类型" class="headerlink" title="DocumentFragment类型"></a>DocumentFragment类型</h3><p>在所有节点类型中，只有DocumentFragment在文档中没有对应的标记。Dom规定文档片段(document fragment)是一种“轻量级”的文档，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。DocumentFragment节点具有下列特征：</p><ul><li>nodeType的值为11;</li><li>nodeName的值为“#document-fragment”;</li><li>nodeValue的值为null；</li><li>parentNode的值为null；</li><li>子节点可以是Element、ProcessingInstruction、Comment、Text、CDATASection或EntityReference。</li></ul><h3 id="Attr类型"><a href="#Attr类型" class="headerlink" title="Attr类型"></a>Attr类型</h3><p>元素的特性在DOM中以Attr类型来表示。在所有浏览器中(包括IE8)，都可以访问Attr类型的构造函数和原型。从技术角度讲，特性就是存在于元素的attributes属性中的节点。特性节点具有下列特征：</p><ul><li>nodeType的值为2；</li><li>nodeName的值是特性的名称；</li><li>nodeValue的值是特性的值；</li><li>parentNode的值为null；</li><li>在HTML中不支持(没有)子节点；</li><li>在XML中子节点可以是Text或EntityReference。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Comment类型&quot;&gt;&lt;a href=&quot;#Comment类型&quot; class=&quot;headerlink&quot; title=&quot;Comment类型&quot;&gt;&lt;/a&gt;Comment类型&lt;/h3&gt;&lt;p&gt;注释在DOM中是通过Comment类型来表示的。Comment节点具有下列特征：&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript-14-DOM-3</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/11/24/Javascript-14-DOM-3/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/11/24/Javascript-14-DOM-3/</id>
    <published>2019-11-24T15:53:29.000Z</published>
    <updated>2020-09-15T09:53:56.064Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h3><p>Element类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。具有以下特征：</p><a id="more"></a><ul><li>nodeType的值为1；</li><li>nodeName的值为元素的标签名；</li><li>nodeValue的值为null；</li><li>parentNode可能是Document或Element；</li><li>其子节点可能是Element、Text、Comment、ProcessingInstruction、CDATASection或EnttyReference。</li></ul><p>要访问元素的标签名，可以使用nodeName属性，也可以使用tagName属性；这两个属性会返回相同的值。</p><h4 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h4><p>所有HTML元素都由HTMLElement类型表示，不是直接通过这个类型，也是通过它的子类型来表示。HTMLElement类型直接继承自Element并添加了一些属性。添加的这些属性分别对应于每个HTML元素中都存在的下列标准特性：</p><ul><li>id，元素在文档中的唯一标识符。</li><li>title，有关元素的附加说明信息，一版通过工具提示条显示出来。</li><li>lang，元素内容的语言代码，很少使用。</li><li>dir，语言的方向，值为“ltr”(left-to-right，从左至右)或“rtl”(right-to-left，从右至左)，也很少使用。</li><li>className，与元素的class特性对应，即为元素指定的CSS类。没有讲这个属性命名为class，是因为class是JS的保留字。</li></ul><h4 id="取得特性"><a href="#取得特性" class="headerlink" title="取得特性"></a>取得特性</h4><p>每个元素都有一或多个特性，这些特性的用途是给出相应元素或其内容的附加信息，操作特性的DOM方法主要有三个，分别是getAttribute()、serAttribute()、removeAttribute()。这三个方法可以针对任何特性使用，包括那些以HTMLElement类型属性定义的特性。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var div &#x3D; document.getElementById(&#39;myDiv&#39;);</span><br><span class="line">alert(div.getAttribute(&#39;id&#39;)); &#x2F;&#x2F; &quot;myDiv&quot;</span><br><span class="line">alert(div.getAttribute(&#39;class&#39;)); &#x2F;&#x2F; &quot;bd&quot;</span><br><span class="line">alert(div.getAttribute(&#39;title&#39;)); &#x2F;&#x2F; &quot;Body text&quot;</span><br><span class="line">alert(div.getAttribute(&#39;lang&#39;)); &#x2F;&#x2F; &quot;en&quot;</span><br><span class="line">alert(div.getAttribute(&#39;dir&#39;)); &#x2F;&#x2F; &quot;ltr&quot;</span><br></pre></td></tr></table></figure><p>注意，传递给getAttribute()的特性名与实际的特性名相同。因此想要得到class特性值，应该传入“class”而不是“className”，后者只有在通过对象属性访问特性时采用。如果给定名称的特性不存在，则返回null。</p><p>特性的名称是不区分大小写的，即“ID”和‘id’代表的是同一个特性。另外也要注意，根据HTML5规范，自定义特性应该加上data-前缀以便验证。</p><p>有两类特殊的特性，它们虽然有对应的属性名，但属性的值与通过getAttribute()返回的值并不相同。第一类特性就是style，用于通过CSS为元素指定样式。在通过getAttribute()访问时，返回的style特性值中包含的是CSS文本，而通过属性来访问它则会返回一个对象，由于style属性是用于以编程方式访问元素样式的，因此并没有直接映射到style特性。</p><p>第二类与众不同的特性是onclick这样的事件处理程序。当在元素上使用时，onclick特性中包含的是JS代码，如果通过getAttribute()访问，则会返回相应代码的字符串。而在访问onclick属性时，则会返回一个JS函数(如果未在元素中指定相应特性，则返回null)。这是因为onclick及其他事件处理程序本身就应该被赋予函数值。</p><h4 id="设置特性"><a href="#设置特性" class="headerlink" title="设置特性"></a>设置特性</h4><p>setAttribute()，这个方法接受两个参数：要设置的特性名和值。如果特性已经存在，会以指定的值替换现有的值；如果特性不存在，则会创建该属性并设置相应的值。</p><p>removeAttribute()，用于彻底删除元素的特性，调用这个方法不仅会清楚特性的值，而且也会从元素中完全删除特性。</p><h4 id="attributes属性"><a href="#attributes属性" class="headerlink" title="attributes属性"></a>attributes属性</h4><p>Element类型是使用attributes属性的唯一一个DOM节点类型。attributes属性中包含一个NameNodeMap，与nodeList类似，也是一个“动态”集合。元素的每一个特性都由一个Attr节点表示，每个节点都保存在NameNodeMap对象中。NameNodeMap对象拥有下列方法。</p><ul><li>getNamedItem(name)：返回nodeName属性等于name的节点。</li><li>removeNamedItem(name)：从列表中移除nodeName属性等于name的节点。</li><li>setNamedItem(node)：向列表中添加节点，以节点的nodeName属性为索引。</li><li>item(pos)：返回位于数字pos位置处的节点，</li></ul><h4 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h4><p>使用document.createElement()方法可以创建新元素，这恶搞方法只接受一个参数，即要创建元素的标签名。这个标签名在HTML文档中不区分大小写，而在XML(包括XHTML)文档中，则是区分大小写的。</p><p>在使用createElement()方法创建新元素的同时，也为新元素设置了ownerDocument属性。此外，还可以操作元素的特性，为它添加更多的子节点，以及执行其他操作。在新元素上设置这些特性只是给它们赋予了相应的信息。由于新元素尚未被添加到文档树中，因此设置这些特性不会影响浏览器的显示。要把新元素添加到文档树，可以使用appendChild()、insertBefore()、replaceChild()方法。</p><p>一旦将元素添加到文档树中，浏览器就会立即呈现该元素。此后，对这个元素所作的任何修改都会实时反映在浏览器中。</p><h4 id="元素的子节点"><a href="#元素的子节点" class="headerlink" title="元素的子节点"></a>元素的子节点</h4><p>元素可以有任意数目的子节点和后代节点，因为元素可以是其他元素的子节点。元素的childNodes属性中包含了它的所有子节点，这些子节点可能是元素、文本节点、注释、处理指令。</p><h3 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h3><p>文本节点由Text类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的HTML字符，但不能包含HTML代码。Text节点具有以下特征：</p><ul><li>nodeType的值为3；</li><li>nodeName的值为“#text”；</li><li>nodeValue的值为节点所包含的文本；</li><li>parentNode是一个Element；</li><li>不支持子节点</li></ul><p>可以通过nodeValue属性或data属性访问Text节点中包含的文本，这两个属性中包含的值相同。对nodeValue的修改也会通过data反映出来，反之亦然。使用下列方法可以操作节点中的文本。</p><ul><li>appendData(text): 将text添加到节点的末尾。</li><li>deleteData(offset, count)：从offset指定的位置开始嘶喊出count个字符。</li><li>insertData(offset, text)：在offset指定的位置插入text。</li><li>replaceData(offset, count, text)：用text替换从offset指定的位置开始到offset+count为止处的文本。</li><li>splitText(offset)：从offset指定的位置将当前文本节点分成两个文本节点。</li><li>substringData(offset, count)：提取从offset指定的位置开始到offset+count为止处的字符串。</li></ul><h4 id="创建文本节点"><a href="#创建文本节点" class="headerlink" title="创建文本节点"></a>创建文本节点</h4><p>document.createTextNode()创建新文本节点，这个方法接受一个参数–要插入节点中的文本。与设置已有文本节点的值一样，作为参数的文本也将按照HTML或XML的格式进行编码。</p><h4 id="规范化文本节点"><a href="#规范化文本节点" class="headerlink" title="规范化文本节点"></a>规范化文本节点</h4><p>DOM文档中存在相邻的同胞文本节点很容易导致混乱，因为分不清哪个文本节点表示哪个字符串。另外，DOM文档中出现相邻文本节点的情况也不在少数，于是就催生了一个能够将相邻文本节点合并的方法。这个方法是由Node类型定义的(因而在所有节点类型中都存在)，名叫normalize()。如果在一个包含两个或多个文本节点的父元素上调用normalize()方法，则会将所有文本节点合并成一个节点，结果节点的nodeValue等于将合并前每个文本节点的nodevalue值拼接起来的值。</p><p>浏览器在解析文档时永远不会创建相邻的文本节点。这种情况只会作为执行DOM操作的结果出现。</p><h4 id="分割文本节点"><a href="#分割文本节点" class="headerlink" title="分割文本节点"></a>分割文本节点</h4><p>splitText()：将一个文本节点分成两个文本节点，即按照执行的位置分割nodeValue值。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点与愿节点的parentNode相同。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Element类型&quot;&gt;&lt;a href=&quot;#Element类型&quot; class=&quot;headerlink&quot; title=&quot;Element类型&quot;&gt;&lt;/a&gt;Element类型&lt;/h3&gt;&lt;p&gt;Element类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。具有以下特征：&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript-14-DOM-2</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/11/18/Javascript-14-DOM-2/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/11/18/Javascript-14-DOM-2/</id>
    <published>2019-11-18T13:33:54.000Z</published>
    <updated>2020-09-15T09:53:13.653Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h3><p>JS通过Document类型表示文档。在浏览器中，document对象是HTMLDocument(继承自Document类型)的一个实例，表示整个HTML页面。其中，document对象是window对象的一个属性，因此可以将其作为全局对象来访问，Document节点具有以下特征：</p><a id="more"></a><ul><li>nodeType的值为9；</li><li>nodeName的值为“#document”；</li><li>nodeValue的值为null；</li><li>parentNode的值为null；</li><li>ownerDocument的值为null；</li><li>其子节点可能是一个DocumentType(最多一个)、Element(最多一个)、ProcessingInstruction或Comment。</li></ul><p>Document类型可以表示HTML页面或者其他基于XML的文档。不过，最常见的应用还是作为HTMLDocument实例的document对象。通过这个文档对象，不仅可以取得与页面有关的信息，而且还能操作页面的外观及其底层结构。</p><h4 id="文档的子节点"><a href="#文档的子节点" class="headerlink" title="文档的子节点"></a>文档的子节点</h4><p>虽然DOM标准规定Document节点的子节点可以是DocumentType、Element、ProcessingInstruction或Comment，但还有两个内置的访问其子节点的快捷方式。第一个就是DocumentElement属性，该属性始终指向HTML页面中的<code>&lt;html&gt;</code>元素。另一个就是通过ChildNodes列表访问文档元素。</p><p>作为HTMLDocument的实例，document对象还有一个body属性，直接指向<code>&lt;body&gt;</code>元素。</p><p>所有浏览器都支持document.documentElement和document.body属性。</p><h4 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h4><p>作为HTMLDocument的一个实例，document对象还有一些标准的Document对象所没有的属性。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 取得文档标题</span><br><span class="line">var originalTitle &#x3D; document.title;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置文档标题</span><br><span class="line">document.title &#x3D; &quot;New page title&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取得完整的URL</span><br><span class="line">var url &#x3D; document.URL;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取得域名</span><br><span class="line">var domain &#x3D; document.domain;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取得来源页面的URL</span><br><span class="line">var referrer &#x3D; document.referrer;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 假设页面来自p2p.wrox.com域</span><br><span class="line">document.domain &#x3D; &quot;wrox.com&quot;; &#x2F;&#x2F; 成功</span><br><span class="line"></span><br><span class="line">document.domain &#x3D; &quot;nczonline.net&quot;; &#x2F;&#x2F; 出错</span><br></pre></td></tr></table></figure><h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><p>Document类型提供了两个方法。</p><p>1，getElementById()，接收一个参数：要取得元素的ID，找到则返回该元素，不存在则返回null。注意，这里的ID必须与页面中元素的id严格匹配，包括大小写。</p><p>2，getElementsByTagName()，接收一个参数：要取得元素的标签名，而返回的是包含零或多个元素的NodeList。</p><p>只有HTMLDocument类型才有的方法：getElementsByName()，返回带有给定name特性的所有元素。</p><h4 id="特殊集合"><a href="#特殊集合" class="headerlink" title="特殊集合"></a>特殊集合</h4><ul><li>document.anchors，包含文档中所有带name特性的<code>&lt;a&gt;</code>元素。</li><li>document.applets，包含文档中所有的<code>&lt;applet&gt;</code>元素，因为不再推荐使用<code>&lt;applet&gt;</code>元素，所以这个集合已经不建议使用了。</li><li>document.forms，包含文档中所有的<code>&lt;form&gt;</code>元素，与document.getElementsByTagName(‘form’)得到的结果相同。</li><li>document.images，包含文档中所有的<code>&lt;img&gt;</code>元素，与document.getElementsByTagName(‘img’)得到的结果相同。</li><li>document.links，包含文档中所有带href特性的<code>&lt;a&gt;</code>元素。</li></ul><h4 id="DOM一致性检测"><a href="#DOM一致性检测" class="headerlink" title="DOM一致性检测"></a>DOM一致性检测</h4><p>由于DOM分为多个级别，也包含多个部分，因此检测浏览器实现了DOM的哪些部分就十分必要。document.implementation属性就是这些提供相应信息和功能的对象。与浏览器对DOM的实现直接对应。、DOM1级只为document.implementation规定了一个方法，即hasFeature()。这个方法接受两个参数:要检测的DOM功能的名称及版本号。如果浏览器支持给定名称和版本的功能，则该方法返回true。</p><p>下表列出了可以检测的不同的值及版本号：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZS1zdGF0aWMuc2VnbWVudGZhdWx0LmNvbS8yODgvNjgyLzI4ODY4MjY2My01N2NmNmZlNTEwY2QyX2FydGljbGV4?x-oss-process=image/format,png" alt=""></p><h4 id="文档写入"><a href="#文档写入" class="headerlink" title="文档写入"></a>文档写入</h4><ul><li><p>write();</p></li><li><p>writeIn();</p></li><li><p>open();</p></li><li><p>close();</p><p>write()和writeIn()接受一个字符串参数，既要写入到输出流的文本。write()会原样写入，而writeIn()则会在字符串的末尾添加一个换行符(\n)。</p><p>open()和close()分别用于打开和关闭网页的输出流。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Document类型&quot;&gt;&lt;a href=&quot;#Document类型&quot; class=&quot;headerlink&quot; title=&quot;Document类型&quot;&gt;&lt;/a&gt;Document类型&lt;/h3&gt;&lt;p&gt;JS通过Document类型表示文档。在浏览器中，document对象是HTMLDocument(继承自Document类型)的一个实例，表示整个HTML页面。其中，document对象是window对象的一个属性，因此可以将其作为全局对象来访问，Document节点具有以下特征：&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript-14-DOM-1</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/11/07/Javascript-14-DOM-1/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/11/07/Javascript-14-DOM-1/</id>
    <published>2019-11-07T03:41:12.000Z</published>
    <updated>2020-09-15T09:42:01.410Z</updated>
    
    <content type="html"><![CDATA[<p>DOM(文档对象模型)是针对HTML和XML文档的一个API。DOM描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。DOM脱胎于DHTML(动态HTML)，但现在它已经成为表现和操作页面标记的真正的跨平台、语言中立的方式。</p><p><font color=red>注意：IE中的所有DOM对象都是以COM对象的形式实现的，这意味折IE中的DOM对象与原生JS对象的行为或活动特点并不一致。</font></p><a id="more"></a><h3 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h3><p>DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。节点分为几种不同的类型，每种类型分别表示文档中不同的信息及标记。每个节点都拥有各自的特点、数据和方法，另外也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的属性结构。</p><p>文档节点是每个文档的根节点。文档节点的子节点称之为文档元素。文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。<font color=red>每个文档只能有一个文档元素。在HTML页面中，文档元素始终都是<code>&lt;hmtl&gt;</code>元素。在XML中，没有预定义的元素，因此任何元素都可能成为文档元素。</font></p><p>每一段标记都可以通过树中的一个节点来表示：HTML元素通过元素节点表示，特性通过特性节点表示，文档类型通过文档类型节点表示，而注释通过注释节点表示。总共有12中节点类型，这些类型都继承自一个基类型。</p><h4 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h4><p>DOM1级定义了一个Node接口，该接口将由DOM中的所有节点实现。这个Node接口在JS中是作为Node类型实现的；除了IE之外，在其他所有浏览器中都可以访问到这个类型。JS中的所有节点类型都继承自Node类型，因此所有节点类型都共享者相同的基本属性和方法。</p><p>每个节点都有一个nodeType类型，用于表明节点的类型。节点类型由在Node类型中定义的下列12个数值常量来表示，任何节点类型必居其一：</p><ul><li>Node.ELEMENT_NODE(1);</li><li>Node.ATTRIBUTE_NODE(2);</li><li>Node.TEXT_NODE(3);</li><li>Node.CDATA_SECTION_NODE(4);</li><li>Node.ENTITY_REFERENCE_NODE(5);</li><li>Node.ENTITY_NODE(6);</li><li>Node.PROCESSING_INSTRUCTION_NODE(7);</li><li>Node.COMMENT_NODE(8);</li><li>Node.DOCUMENT_NODE(9);</li><li>Node.DOCUMENT_TYPE_NODE(10);</li><li>Node.DOCUMENT_FRAGMENT_NODE(11);</li><li>Node.NOTATION_NODE(12);</li></ul><h5 id="nodeName和nodeValue属性"><a href="#nodeName和nodeValue属性" class="headerlink" title="nodeName和nodeValue属性"></a>nodeName和nodeValue属性</h5><p>要了解节点的具体信息，可以使用nodeName和nodeValue这两个属性。这两个属性的值完全取决于节点的类型。在使用之前要先检测一下节点的类型。</p><h5 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h5><p>节点间的关系可以用传统的家族关系来描述，相当于把文档树比喻成家谱。</p><p>每个节点都有一个childNodes属性，其中保存着一个NodeList对象。NodeList是一种累数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。NodeList对象的独特之处在于，它实际上是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映在NodeList对象中，</p><p>每个节点都有一个parentNode属性，该属性指向文档树中的父节点。包含在childNodes列表中的所有节点都具有相同的父节点，因此它们的parentNode属性都指向同一个节点。此外，包含在childNodes列表中的每个节点相互之间都是同胞节点。通过使用列表中每个节点的previousSibling和nextSibling属性，可以访问同一列表中的其他节点。列表中第一个节点的previousSibling属性和最后一个节点的nextSibling属性为null。</p><p>父节点的firstChild和lastChild属性分别指向其childNodes列表中的第一个和最后一个节点，</p><p>hasChildNodes()在节点包含一个或多个子节点的情况下返回true。所有节点都有的最后一个属性是ownerDocument，该属性指向表示整个文档的文档节点。这种关系表示的是任何节点都属于它所在的文档，任何节点都不能同时存在于两个或更多个文档中。通过这个属性可以直接访问文档节点。</p><h5 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h5><p>appendChild()用于向childNodes列表的末尾添加一个节点。添加完成后appendChild()返回新增的节点，</p><p>insertBefore()插入节点，接受两个参数：要插入的节点和作为参照的节点。</p><p>replaceChild()替换节点，接受两个参数：要插入的节点和要替换的节点。</p><p>removeChild()移除节点。</p><p>cloneNode()用于创建调用这个方法的节点的一个完全相同的副本，接受一个布尔值参数表示是否执行深复制。true复制节点及其整个子节点树；false只复制节点本身，、。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;DOM(文档对象模型)是针对HTML和XML文档的一个API。DOM描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。DOM脱胎于DHTML(动态HTML)，但现在它已经成为表现和操作页面标记的真正的跨平台、语言中立的方式。&lt;/p&gt;
&lt;p&gt;&lt;font color=red&gt;注意：IE中的所有DOM对象都是以COM对象的形式实现的，这意味折IE中的DOM对象与原生JS对象的行为或活动特点并不一致。&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript-13-客户端检测</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/11/03/Javascript-13-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/11/03/Javascript-13-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B/</id>
    <published>2019-11-03T14:08:24.000Z</published>
    <updated>2020-09-15T09:40:51.108Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器提供商虽然在实现公共接口方面投入了很多精力，但结果仍然是每一种浏览器都有各自的长处，也都有各自的缺点。即使是那些跨平台的浏览器，虽然从技术上看版本相同，也照样存在不一致性问题。因此客户端检测是一种补救措施，不到万不得已就不要使用客户端检测。</p><a id="more"></a><h3 id="能力检测"><a href="#能力检测" class="headerlink" title="能力检测"></a>能力检测</h3><p>能力检测的目的不是检测浏览器类型，而是检测浏览器是否有该功能。举例来说IE5.0之前的版本不支持document.getElementById()这个DOM方法，但是可以用document.all属性去实现这个功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function getElement(id) &#123;</span><br><span class="line">       if (document.getElementById) &#123;</span><br><span class="line">           return document.getElementById(id);</span><br><span class="line">       &#125; else if (document.all) &#123;</span><br><span class="line">           return document.all[id];</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           throw new Error(&quot;No way to retrieve element!&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>使用能力检测有两点要注意：1.把更通用的，性能更佳的方法写在前面。2.必须测试实际用到的特性。不能以为有document.all就认为它是IE而去使用IE拥有的特征。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getWindowWidth() &#123;</span><br><span class="line">       if (document.all) &#123; &#x2F;&#x2F;假设是IE</span><br><span class="line">           return document.documentElement.clientWidth;&#x2F;&#x2F;错误的用法</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return window.innerWidth;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="更可靠的能力检测"><a href="#更可靠的能力检测" class="headerlink" title="更可靠的能力检测"></a>更可靠的能力检测</h4><p>使用typeof操作符的确能让检测更加可靠，但是也有例外。在IE8及以前的版本中DOM对象的方法的类型是object而不是function。这是因为DOM对象是宿主对象，IE的早期版本中宿主对象是通过COM而非JScript实现的。因此像document.createElement()函数在IE早期的确是一个COM对象而非function。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;IE8及以前不行</span><br><span class="line">  function hasCreateElement() &#123;</span><br><span class="line">      return typeof document.createElement &#x3D;&#x3D; &quot;function&quot;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>仅IE支持的ActiveX对象与其他对象的差异也很大。例如，不适用typeof检测某个属性会导致错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new ActiveXObject(&quot;Microsoft.XMLHttp&quot;);</span><br><span class="line">    if (xhr.open) &#123; &#x2F;&#x2F;书上说这里会出错，但IE9 xhr.open为undefined</span><br><span class="line">        &#x2F;&#x2F;执行操作</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">function isHostMethod(object, property) &#123;</span><br><span class="line">        var t &#x3D; typeof object[property];</span><br><span class="line">        return t &#x3D;&#x3D; &quot;function&quot; || t &#x3D;&#x3D; &quot;unknown&quot; &#x2F;&#x2F;IE对typeof xhr.open 会返回&quot;unknown&quot;</span><br><span class="line">            || !!(t &#x3D;&#x3D; &quot;object&quot; &amp;&amp; object[property]);&#x2F;&#x2F;是COM对象 且不为null</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="能力检测，不是浏览器检测"><a href="#能力检测，不是浏览器检测" class="headerlink" title="能力检测，不是浏览器检测"></a>能力检测，不是浏览器检测</h4><p>在实际开发中，应该将能力检测作为确定下一步解决方案的依据，而不是用它来判断用户使用的是什么浏览器。下面是两个典型误用和两个正确用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;错误！还不够具体。且后期Safari也实现了相同的属性。</span><br><span class="line">    var isFirefox &#x3D; !!(navigator.vendor &amp;&amp; navigator.vendorSub);</span><br><span class="line">    &#x2F;&#x2F;错误！假设过头了。假设了IE将来版本也会实现这两个属性，且其他浏览器不会实现。</span><br><span class="line">    var isIE &#x3D; !!(document.all &amp;&amp; document.uniqueID);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;确认浏览器是否支持Netscape风格插件</span><br><span class="line">    var hasNSPlugins &#x3D; !!(navigator.plugins &amp;&amp; navigator.plugins.length);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;确定浏览器是否具有DOM1级规定的能力</span><br><span class="line">    var hasDOM1 &#x3D; !!(document.getElementById &amp;&amp; document.createElement &amp;&amp; document.getElementsByTagName);</span><br></pre></td></tr></table></figure><h3 id="怪癖检测"><a href="#怪癖检测" class="headerlink" title="怪癖检测"></a>怪癖检测</h3><p>怪癖检测的目标是识别浏览器的特殊行为。耽于能力检测确认浏览器支持什么能力不同，怪癖检测是想要知道浏览器存在什么缺陷（即bug）。通常要尝试运行一段代码，以确定某一特性不能正常工作。例如在IE8及其早期版本中，如果某个实例属性和原来标记为不可枚举的属性同名，那么该属性就不会出现在for-in循环中。还有Safari3以前版本中会枚举被隐藏的属性。可以通过下面的例子来检测怪癖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var hasDontEnumQuirk &#x3D; function()&#123;</span><br><span class="line">       var o &#x3D; &#123; toString : function()&#123;&#125; &#125;;</span><br><span class="line">       for (var prop in o)&#123;</span><br><span class="line">           if (prop &#x3D;&#x3D; &quot;toString&quot;)&#123;</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;();&#x2F;&#x2F;匿名函数直接执行</span><br><span class="line">   var hasEnumShadowsQuirk &#x3D; function()&#123;</span><br><span class="line">       var o &#x3D; &#123; toString : function()&#123;&#125; &#125;;</span><br><span class="line">       var count &#x3D; 0;</span><br><span class="line">       for (var prop in o)&#123;</span><br><span class="line">           if (prop &#x3D;&#x3D; &quot;toString&quot;)&#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return (count &gt; 1);</span><br><span class="line">   &#125;();&#x2F;&#x2F;匿名函数直接执行</span><br><span class="line">   alert(hasDontEnumQuirk);</span><br><span class="line">   alert(hasEnumShadowsQuirk);</span><br></pre></td></tr></table></figure><h3 id="用户代理检测"><a href="#用户代理检测" class="headerlink" title="用户代理检测"></a>用户代理检测</h3><p>以下是完整的用户代理字符串检测脚本，包括检测呈现引擎、平台、Windows 操作系统、移动设备和游戏系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">var client &#x3D; function()&#123;</span><br><span class="line">&#x2F;&#x2F;呈现引擎</span><br><span class="line">var engine &#x3D; &#123;</span><br><span class="line">ie: 0,</span><br><span class="line">gecko: 0,</span><br><span class="line">webkit: 0,</span><br><span class="line">khtml: 0,</span><br><span class="line">opera: 0,</span><br><span class="line">&#x2F;&#x2F;完整的版本号</span><br><span class="line">ver: null</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;浏览器</span><br><span class="line">var browser &#x3D; &#123;</span><br><span class="line">&#x2F;&#x2F;主要浏览器</span><br><span class="line">ie: 0,</span><br><span class="line">firefox: 0,</span><br><span class="line">safari: 0,</span><br><span class="line">konq: 0,</span><br><span class="line">opera: 0,</span><br><span class="line">chrome: 0,</span><br><span class="line">&#x2F;&#x2F;具体的版本号</span><br><span class="line">ver: null</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;平台、设备和操作系统</span><br><span class="line">var system &#x3D; &#123;</span><br><span class="line">win: false,</span><br><span class="line">mac: false,</span><br><span class="line">x11: false,</span><br><span class="line">&#x2F;&#x2F;移动设备</span><br><span class="line">iphone: false,</span><br><span class="line">ipod: false,</span><br><span class="line">ipad: false,</span><br><span class="line">ios: false,</span><br><span class="line">android: false,</span><br><span class="line">nokiaN: false,</span><br><span class="line">winMobile: false,</span><br><span class="line">&#x2F;&#x2F;游戏系统</span><br><span class="line">wii: false,</span><br><span class="line">ps: false</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;检测呈现引擎和浏览器</span><br><span class="line">var ua &#x3D; navigator.userAgent;</span><br><span class="line">if (window.opera)&#123;</span><br><span class="line">engine.ver &#x3D; browser.ver &#x3D; window.opera.version();</span><br><span class="line">engine.opera &#x3D; browser.opera &#x3D; parseFloat(engine.ver);</span><br><span class="line">&#125; else if (&#x2F;AppleWebKit\&#x2F;(\S+)&#x2F;.test(ua))&#123;</span><br><span class="line">engine.ver &#x3D; RegExp[&quot;$1&quot;];</span><br><span class="line">engine.webkit &#x3D; parseFloat(engine.ver);</span><br><span class="line">&#x2F;&#x2F;确定是Chrome 还是Safari</span><br><span class="line">if (&#x2F;Chrome\&#x2F;(\S+)&#x2F;.test(ua))&#123;</span><br><span class="line">browser.ver &#x3D; RegExp[&quot;$1&quot;];</span><br><span class="line">browser.chrome &#x3D; parseFloat(browser.ver);</span><br><span class="line">&#125; else if (&#x2F;Version\&#x2F;(\S+)&#x2F;.test(ua))&#123;</span><br><span class="line">browser.ver &#x3D; RegExp[&quot;$1&quot;];</span><br><span class="line">browser.safari &#x3D; parseFloat(browser.ver);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;近似地确定版本号</span><br><span class="line">var safariVersion &#x3D; 1;</span><br><span class="line">if (engine.webkit &lt; 100)&#123;</span><br><span class="line">safariVersion &#x3D; 1;</span><br><span class="line">&#125; else if (engine.webkit &lt; 312)&#123;</span><br><span class="line">safariVersion &#x3D; 1.2;</span><br><span class="line">&#125; else if (engine.webkit &lt; 412)&#123;</span><br><span class="line">safariVersion &#x3D; 1.3;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">safariVersion &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line">browser.safari &#x3D; browser.ver &#x3D; safariVersion;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (&#x2F;KHTML\&#x2F;(\S+)&#x2F;.test(ua) || &#x2F;Konqueror\&#x2F;([^;]+)&#x2F;.test(ua))&#123;</span><br><span class="line">engine.ver &#x3D; browser.ver &#x3D; RegExp[&quot;$1&quot;];</span><br><span class="line">engine.khtml &#x3D; browser.konq &#x3D; parseFloat(engine.ver);</span><br><span class="line">&#125; else if (&#x2F;rv:([^\)]+)\) Gecko\&#x2F;\d&#123;8&#125;&#x2F;.test(ua))&#123;</span><br><span class="line">engine.ver &#x3D; RegExp[&quot;$1&quot;];</span><br><span class="line">engine.gecko &#x3D; parseFloat(engine.ver);</span><br><span class="line">&#x2F;&#x2F;确定是不是Firefox</span><br><span class="line">if (&#x2F;Firefox\&#x2F;(\S+)&#x2F;.test(ua))&#123;</span><br><span class="line">browser.ver &#x3D; RegExp[&quot;$1&quot;];</span><br><span class="line">browser.firefox &#x3D; parseFloat(browser.ver);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (&#x2F;MSIE ([^;]+)&#x2F;.test(ua))&#123;</span><br><span class="line">engine.ver &#x3D; browser.ver &#x3D; RegExp[&quot;$1&quot;];</span><br><span class="line">engine.ie &#x3D; browser.ie &#x3D; parseFloat(engine.ver);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;检测浏览器</span><br><span class="line">browser.ie &#x3D; engine.ie;</span><br><span class="line">browser.opera &#x3D; engine.opera;</span><br><span class="line">&#x2F;&#x2F;检测平台</span><br><span class="line">var p &#x3D; navigator.platform;</span><br><span class="line">system.win &#x3D; p.indexOf(&quot;Win&quot;) &#x3D;&#x3D; 0;</span><br><span class="line">system.mac &#x3D; p.indexOf(&quot;Mac&quot;) &#x3D;&#x3D; 0;</span><br><span class="line">system.x11 &#x3D; (p &#x3D;&#x3D; &quot;X11&quot;) || (p.indexOf(&quot;Linux&quot;) &#x3D;&#x3D; 0);</span><br><span class="line">&#x2F;&#x2F;检测Windows 操作系统</span><br><span class="line">if (system.win)&#123;</span><br><span class="line">if (&#x2F;Win(?:dows )?([^do]&#123;2&#125;)\s?(\d+\.\d+)?&#x2F;.test(ua))&#123;</span><br><span class="line">if (RegExp[&quot;$1&quot;] &#x3D;&#x3D; &quot;NT&quot;)&#123;</span><br><span class="line">switch(RegExp[&quot;$2&quot;])&#123;</span><br><span class="line">case &quot;5.0&quot;:</span><br><span class="line">system.win &#x3D; &quot;2000&quot;;</span><br><span class="line">break;</span><br><span class="line">case &quot;5.1&quot;:</span><br><span class="line">system.win &#x3D; &quot;XP&quot;;</span><br><span class="line">break;</span><br><span class="line">case &quot;6.0&quot;:</span><br><span class="line">system.win &#x3D; &quot;Vista&quot;;</span><br><span class="line">break;</span><br><span class="line">case &quot;6.1&quot;:</span><br><span class="line">system.win &#x3D; &quot;7&quot;;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">system.win &#x3D; &quot;NT&quot;;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (RegExp[&quot;$1&quot;] &#x3D;&#x3D; &quot;9x&quot;)&#123;</span><br><span class="line">system.win &#x3D; &quot;ME&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">system.win &#x3D; RegExp[&quot;$1&quot;];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;移动设备</span><br><span class="line">system.iphone &#x3D; ua.indexOf(&quot;iPhone&quot;) &gt; -1;</span><br><span class="line">system.ipod &#x3D; ua.indexOf(&quot;iPod&quot;) &gt; -1;</span><br><span class="line">system.ipad &#x3D; ua.indexOf(&quot;iPad&quot;) &gt; -1;</span><br><span class="line">system.nokiaN &#x3D; ua.indexOf(&quot;NokiaN&quot;) &gt; -1;</span><br><span class="line">&#x2F;&#x2F;windows mobile</span><br><span class="line">if (system.win &#x3D;&#x3D; &quot;CE&quot;)&#123;</span><br><span class="line">system.winMobile &#x3D; system.win;</span><br><span class="line">&#125; else if (system.win &#x3D;&#x3D; &quot;Ph&quot;)&#123;</span><br><span class="line">if(&#x2F;Windows Phone OS (\d+.\d+)&#x2F;.test(ua))&#123;;</span><br><span class="line">system.win &#x3D; &quot;Phone&quot;;</span><br><span class="line">system.winMobile &#x3D; parseFloat(RegExp[&quot;$1&quot;]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;检测iOS 版本</span><br><span class="line">if (system.mac &amp;&amp; ua.indexOf(&quot;Mobile&quot;) &gt; -1)&#123;</span><br><span class="line">if (&#x2F;CPU (?:iPhone )?OS (\d+_\d+)&#x2F;.test(ua))&#123;</span><br><span class="line">system.ios &#x3D; parseFloat(RegExp.$1.replace(&quot;_&quot;, &quot;.&quot;));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">system.ios &#x3D; 2; &#x2F;&#x2F;不能真正检测出来，所以只能猜测</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;检测Android 版本</span><br><span class="line">if (&#x2F;Android (\d+\.\d+)&#x2F;.test(ua))&#123;</span><br><span class="line">system.android &#x3D; parseFloat(RegExp.$1);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;游戏系统</span><br><span class="line">system.wii &#x3D; ua.indexOf(&quot;Wii&quot;) &gt; -1;</span><br><span class="line">system.ps &#x3D; &#x2F;playstation&#x2F;i.test(ua);</span><br><span class="line">&#x2F;&#x2F;返回这些对象</span><br><span class="line">return &#123;</span><br><span class="line">engine: engine,</span><br><span class="line">browser: browser,</span><br><span class="line">system: system</span><br><span class="line">&#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;浏览器提供商虽然在实现公共接口方面投入了很多精力，但结果仍然是每一种浏览器都有各自的长处，也都有各自的缺点。即使是那些跨平台的浏览器，虽然从技术上看版本相同，也照样存在不一致性问题。因此客户端检测是一种补救措施，不到万不得已就不要使用客户端检测。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript-12-BOM-2</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/11/02/Javascript-12-BOM-2/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/11/02/Javascript-12-BOM-2/</id>
    <published>2019-11-02T13:39:18.000Z</published>
    <updated>2020-09-15T09:39:53.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><p>location对象是最有用的BOM对象之一，它提供了与当前窗口加载的文档有关的信息，还提供了一些导航功能。location对象既是window对象的属性，也是document对象的属性；换句话说，window.location和document.location引用的是同一个对象。location对象的用处不只表现在它保存着当前文档的信息，还表现在它将URL解析为独立的片段，让我们可以通过不同的属性访问这些片段。下表列出了location对象的所有属性(省略了每个属性前面的location前缀)。</p><a id="more"></a><p><img src="https://img-blog.csdn.net/20160923152459667" alt=""></p><h4 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h4><p>虽然可以通过location.search得到从问号到URL末尾的所有内容，但却没办法逐个访问，因此可以像下面这样创建一个函数，用以解析每个字符串，然后返回包含所有参数的一个对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function getQueryStringArgs() &#123;</span><br><span class="line">    &#x2F;&#x2F; 取得查询字符串并去掉开头的问号</span><br><span class="line">    var qs &#x3D; location.search.length&gt;0? location.search.substring(1):&quot;&quot;;</span><br><span class="line">    &#x2F;&#x2F; 保存数据的对象</span><br><span class="line">    var args &#x3D; &#123;&#125;;</span><br><span class="line">    &#x2F;&#x2F; 取得每一项</span><br><span class="line">    var items &#x3D; qs.length?qs.split(&quot;&amp;&quot;):[];</span><br><span class="line">    var item &#x3D; null;</span><br><span class="line">    var name &#x3D; null;</span><br><span class="line">    var value &#x3D; null;</span><br><span class="line"></span><br><span class="line">    for (var i &#x3D; 0; i &lt; items.length; i++) &#123;</span><br><span class="line">        item &#x3D; items[i].split(&quot;&#x3D;&quot;);</span><br><span class="line">        name &#x3D; decodeURIComponent(item[0]);</span><br><span class="line">        value &#x3D; decodeURIComponent(items[1]);</span><br><span class="line"></span><br><span class="line">        if (name.length) &#123;</span><br><span class="line">            args[name] &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h4><ul><li><p>assign()：立即打开新URL并在浏览器的历史记录中生成一条记录</p></li><li><p>replace()：导航到新URL，但不会在历史记录中生成新纪录，即，用户不能返回到前一个页面</p></li><li><p>reload()：重新加载当前显示的页面</p><h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><p>navigator对象包含有关浏览器的信息，是识别客户端浏览器的事实标准。下表列出了存在于所有浏览器中的属性和方法，以及支持它们的浏览器版本。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3N0YXRpYy5vc2NoaW5hLm5ldC91cGxvYWRzL3NwYWNlLzIwMTQvMDgyOC8xODAyMTBfOFRYWF8yMDA0MTcxLmpwZw?x-oss-process=image/format,png" alt=""><br>表中的这些navigator对象的属性通常用于检测显示网页的浏览器类型。</p><h4 id="检测插件"><a href="#检测插件" class="headerlink" title="检测插件"></a>检测插件</h4><p>在非IE浏览器下检测插件(利用navigator.plugins数组进行检测)<br>navigator.plugins数组有如下属性：</p><ul><li>name：插件的名字</li><li>description：插件的描述</li><li>filename：插件的文件名</li><li>length：插件所处理的MIME类型数量<br>一般来说，name属性中会包含检测插件必需的所有信息，但有时候也不完全如此。在检测插件时，需要像下面这样循环迭代每个插件并将插件的name与给定的名字进行比较。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 不支持IE</span><br><span class="line">function hasPlugin(name) &#123;</span><br><span class="line">    name &#x3D; name.toLowerCase();</span><br><span class="line">    var pluginsArray &#x3D; navigator.plugins;</span><br><span class="line">    for (var i &#x3D; 0, pluginLength &#x3D; pluginsArray.length; i &lt; pluginLength; i++) &#123;</span><br><span class="line">        if (pluginsArray[i].name.toLowerCase().indexOf(name) &gt; -1) &#123;</span><br><span class="line">        return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 检测flash</span><br><span class="line">hasPlugin(&quot;Flash&quot;);</span><br><span class="line">&#x2F;&#x2F; 检测QuickTime</span><br><span class="line">hasPlugin(&quot;QuickTime&quot;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>检测IE中的插件比较麻烦，因为IE不支持Natscape式的插件。在IE中检测插件的唯一方式就是使用专有的ActiveXObject类型，并尝试创建一个特定插件的实例。IES是以COM对象的方式实现插件的，而COM对象使用唯一标识符来标识。因此，要想检查特定的插件，就必须知道其COM标识符。例如，Flash的标识符是ShockwaveFlash.ShockwaveFlash。知道唯一标识符后，就可以编写类似下面的函数来检测IE中是否安装相应的插件了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 检测IE中的插件</span><br><span class="line">function hasIEPlugin(name) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        new ActiveXObject(name);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; catch(e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鉴于检测这两种插件的方法差别太大，因此典型的做法是针对每个插件分别创建检测函数，而不是使用前面介绍的通用检测方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 检测所有浏览器中的Flash</span><br><span class="line">function hasFlash() &#123;</span><br><span class="line">    var resultFlag &#x3D; hasPlugin(&quot;Flash&quot;);</span><br><span class="line">    if (!resultFlag) &#123;</span><br><span class="line">        resultFlag &#x3D; hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return resultFlag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>navigator.plugins.refresh（）：用于刷新最新安装插件plugins的集合<br>navigator.plugins.refresh（true）:更新插件集合，以及重新加载包含插件集合的所有页面。</p><h3 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h3><p>screen对象基本上只用来标明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。下表列出了所有属性及支持相应属性的浏览器。</p><table><thead><tr><th>属 性</th><th>说 明</th><th>IE</th><th>Firefox</th><th>Safari/Chrome</th><th>Opera</th></tr></thead><tbody><tr><td>availHeight</td><td>屏幕的像素高度减系统部件高度之后的值（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>availLeft</td><td>未被系统部件占用的最左侧的像素值（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>availTop</td><td>未被系统部件占用的最上方的像素值（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>availWidth</td><td>屏幕的像素宽度减系统部件宽度之后的值（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>bufferDepth</td><td>读、写用于呈现屏外位图的位数</td><td></td><td></td><td></td><td></td></tr><tr><td>colorDepth</td><td>用于表现颜色的位数；多数系统都是32（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>deviceXDPI</td><td>屏幕实际的水平DPI（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>deviceYDPI</td><td>屏幕实际的垂直DPI（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>fontSmoothingEnabled</td><td>表示是否启用了字体平滑（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>height</td><td>屏幕的像素高度</td><td></td><td></td><td></td><td></td></tr><tr><td>left</td><td>当前屏幕距左边的像素距离</td><td></td><td></td><td></td><td></td></tr><tr><td>logicalXDPI</td><td>屏幕逻辑的水平DPI（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>logicalYDPI</td><td>屏幕逻辑的垂直DPI（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>pixelDepth</td><td>屏幕的位深（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>top</td><td>当前屏幕距上边的像素距离</td><td></td><td></td><td></td><td></td></tr><tr><td>updateInterval</td><td>读、写以毫秒表示的屏幕刷新时间间隔</td><td></td><td></td><td></td><td></td></tr><tr><td>width</td><td>屏幕的像素宽度</td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="hostory对象"><a href="#hostory对象" class="headerlink" title="hostory对象"></a>hostory对象</h3><p>history对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。由于安全方面的考虑，开发人员无法得到用户浏览器的URL，但借由用户访问过的页面列表，可以在不知道实际URL的情况下实现后退和前进。</p><p>使用go()方法可以在用户的历史记录中任意跳转。这个方法接收一个参数，表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转(类似于后退按钮)，正数表示向前跳转(类似于前进按钮)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;后退一页</span><br><span class="line">history.go(-1)</span><br><span class="line">&#x2F;&#x2F;前进一页</span><br><span class="line">history.go(1);</span><br><span class="line">&#x2F;&#x2F;前进两页</span><br><span class="line">history.go(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;刷新当前页面</span><br><span class="line">history.go();</span><br><span class="line">&#x2F;&#x2F;刷新当前页面</span><br><span class="line">history.go(0);</span><br></pre></td></tr></table></figure><p>back()方法用于模仿浏览器的后退按钮，相当于history.go(-1)。</p><p>forward()方法用于模仿浏览器的前进按钮，相当于history.go(1)。</p><p>history.length属性保存着历史记录的URL数量。初始时，该值为1。如果当前窗口先后访问了三个网址，history.length属性等于3。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;location对象&quot;&gt;&lt;a href=&quot;#location对象&quot; class=&quot;headerlink&quot; title=&quot;location对象&quot;&gt;&lt;/a&gt;location对象&lt;/h3&gt;&lt;p&gt;location对象是最有用的BOM对象之一，它提供了与当前窗口加载的文档有关的信息，还提供了一些导航功能。location对象既是window对象的属性，也是document对象的属性；换句话说，window.location和document.location引用的是同一个对象。location对象的用处不只表现在它保存着当前文档的信息，还表现在它将URL解析为独立的片段，让我们可以通过不同的属性访问这些片段。下表列出了location对象的所有属性(省略了每个属性前面的location前缀)。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript-12-BOM-1</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/10/25/Javascript-12-BOM-1/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/10/25/Javascript-12-BOM-1/</id>
    <published>2019-10-25T01:38:21.000Z</published>
    <updated>2020-09-15T09:39:03.557Z</updated>
    
    <content type="html"><![CDATA[<h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><p>BOM的核心对象是window，他表示浏览器的一个实例。在浏览器中，window对象有双重角色，它既是通过Jacascript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。这意味着在网页中定义的任何一个对象、变量和函数，都以window作为其Global对象，因此有权访问parseInt()等方法。</p><a id="more"></a><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>由于window对象同时扮演者ECMAScript中Global对象的角色，因此所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法。抛开全局变量会成为window对象的属性不谈，定义全局变量与在window对象上直接定义属性还是有一点差别：全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性可以。</p><p>尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的变量是否存在。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里会抛出错误，因为oldValue未定义</span><br><span class="line">var newValue &#x3D; oldValue;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里不会抛出错误，因为这是一次属性查询</span><br><span class="line">&#x2F;&#x2F; newValue的值是undefined</span><br><span class="line">var newValue &#x3D; window.oldValue;</span><br></pre></td></tr></table></figure><h4 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h4><p>如果页面中包含框架，则每个框架都拥有自己饿winodw对象，并且保存在frames集合中。在frames集合中，可以通过数值索引(从0开始，从左至右，从上到下)或者框架名称来访问相应的window对象。每个window对象都有一个name属性，其中包含框架的名称。</p><p>top对象始终指向最高(最外)层的框架，也就是浏览器窗口。使用它可以确保在一个框架中正确地访问另一个框架。因为对于在一个框架中编写的任何代码来说，其中的window对象指向的都是那个框架的特定实例，而非最高层的框架。</p><p>与top相对的另一个window对象是parent。顾名思义，parent(父)对象始终指向当前框架的直接上层框架。在某些情况下，parent有可能等于top；但在没有框架的情况下，parent一定等于top(此时它们都等于window)。</p><p>与框架有关的最后一个对象是self，它始终指向window；实际上，self和window对象可以互换使用。引入self对象的目的只是为了与top和parent对象对应起来，因此它不格外包含其他值。</p><p>所有这些对象都是window对象的属性，可以通过window.parent、window.top等形式来访问。同时，这也意味着可以将不同层次的window对象连缀起来，例如<code>window.parent.parent.frames[0]</code>.</p><h4 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h4><p>用来确定和修改window 对象位置的属性和方法有很多。IE、Safari、Opera 和Chrome 都提供了<br>screenLeft 和screenTop 属性，分别用于表示窗口相对于屏幕左边和上边的位置。Firefox 则在<br>screenX 和screenY 属性中提供相同的窗口位置信息，Safari 和Chrome 也同时支持这两个属性。Opera<br>虽然也支持screenX 和screenY 属性，但与screenLeft 和screenTop 属性并不对应，因此建议大<br>家不要在Opera 中使用它们。使用下列代码可以跨浏览器取得窗口左边和上边的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var leftPos &#x3D; (typeof window.screenLeft &#x3D;&#x3D; &quot;number&quot;) ?</span><br><span class="line">window.screenLeft : window.screenX;</span><br><span class="line">var topPos &#x3D; (typeof window.screenTop &#x3D;&#x3D; &quot;number&quot;) ?</span><br><span class="line">window.screenTop : window.screenY;</span><br></pre></td></tr></table></figure><p>这个例子运用二元操作符首先确定screenLeft 和screenTop 属性是否存在，如果是（在IE、<br>Safari、Opera 和Chrome 中），则取得这两个属性的值。如果不存在（在Firefox 中），则取得screenX<br>和screenY 的值。<br>在使用这些值的过程中，还必须注意一些小问题。在IE、Opera 中，screenLeft 和screenTop 中保存<br>的是从屏幕左边和上边到由window 对象表示的页面可见区域的距离。换句话说，如果window 对象是<br>最外层对象，而且浏览器窗口紧贴屏幕最上端——即y 轴坐标为0，那么screenTop 的值就是位于页面<br>可见区域上方的浏览器工具栏的像素高度。但是，在Chrome、Firefox 和Safari 中，screenY 或screenTop<br>中保存的是整个浏览器窗口相对于屏幕的坐标值，即在窗口的y 轴坐标为0 时返回0。<br>更让人捉摸不透是，Firefox、Safari 和Chrome 始终返回页面中每个框架的top.screenX 和<br>top.screenY 值。即使在页面由于被设置了外边距而发生偏移的情况下，相对于window 对象使用<br>screenX 和screenY 每次也都会返回相同的值。而IE 和Opera 则会给出框架相对于屏幕边界的精确坐<br>标值。<br>最终结果，就是无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值。然而，使用moveTo()<br>和moveBy()方法倒是有可能将窗口精确地移动到一个新位置。这两个方法都接收两个参数，其中<br>moveTo()接收的是新位置的x 和y 坐标值，而moveBy()接收的是在水平和垂直方向上移动的像素数。<br>下面来看几个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;将窗口移动到屏幕左上角</span><br><span class="line">window.moveTo(0,0);</span><br><span class="line">&#x2F;&#x2F;将窗向下移动100 像素</span><br><span class="line">window.moveBy(0,100);</span><br><span class="line">&#x2F;&#x2F;将窗口移动到(200,300)</span><br><span class="line">window.moveTo(200,300);</span><br><span class="line">&#x2F;&#x2F;将窗口向左移动50 像素</span><br></pre></td></tr></table></figure><p>需要注意的是，这两个方法可能会被浏览器禁用；而且，在Opera 和IE 7（及更高版本）中默认就<br>是禁用的。另外，这两个方法都不适用于框架，只能对最外层的window 对象使用。</p><h4 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h4><p>跨浏览器确定一个窗口的大小不是一件简单的事。IE9+、Firefox、Safari、Opera 和 Chrome 均为此提供了4个属性： innerWidth 、 innerHeight  、 outerWidth 和  outerHeight  。</p><p>在 IE9+、Safari 和 Firefox 中，  outerWidth  和  outerHeight  返回浏览器窗口本身的尺寸（无论是从最外层的  window  对象还是从某个框架访问）。</p><p>在 Opera 中，这两个属性的值表示页面视图容器 的大小。而  innerWidth  和  innerHeight  则表示该容器中页面视图区的大小（减去边框宽度）。</p><p>在 Chrome 中， outerWidth 、 outerHeight  与  innerWidth 、  innerHeight  返回相同的值，即视口（viewport）大小而非浏览器窗口大小。</p><p>这里所谓的“页面视图容器”指的是 Opera 中单个标签页对应的浏览器窗口。IE8 及更早版本没有提供取得当前浏览器窗口尺寸的属性；不过，它通过 DOM 提供了页面可见区域的相关信息。</p><p>在 IE、Firefox、Safari、Opera 和 Chrome 中，  document.documentElement.clientWidth  和  document.documentElement.clientHeight  中保存了页面视口的信息。在 IE6 中，这些属性必须在标准模式下才有效；如果是混杂模式，就必须通过</p><p> document.body.clientWidth  和  document.body.  clientHeight  取得相同信息。而对于混杂模式下的Chrome，则无论通过 document.documentElement  还是  document.body  中的  clientWidth  和  clientHeight 属性，都可以取得视口的大小。</p><p>虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var pageWidth &#x3D; window.innerWidth,</span><br><span class="line"></span><br><span class="line">pageHeight &#x3D; window.innerHeight;</span><br><span class="line"></span><br><span class="line">if (typeof pageWidth !&#x3D; “number”)&#123;</span><br><span class="line"></span><br><span class="line">    if (document.compatMode &#x3D;&#x3D; “CSS1Compat”)&#123;</span><br><span class="line"></span><br><span class="line">    pageWidth &#x3D; document.documentElement.clientWidth;</span><br><span class="line"></span><br><span class="line">    pageHeight &#x3D; document.documentElement.clientHeight;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">    pageWidth &#x3D; document.body.clientWidth;</span><br><span class="line"></span><br><span class="line">    pageHeight &#x3D; document.body.clientHeight;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们首先将  window.innerWidth  和 window.innerHeight  的值分别赋给了  pageWidth  和 pageHeight  。然后检查  pageWidth  中保存的是不是一个数值；如果不是，则通过检查 document.compatMode （这个属性在《 HTML5扩展了HTMLDocument，增加了新的功能 》里面已经说明）来确定页面是否处于标准模式。如果是，则分别使用  document.documentElement.clientWidth  和 document.documentElement.clientHeight  的值。否则，就使用  document.body.clientWidth  和 document.body.clientHeight  的值。</p><p>对于移动设备，window.innerWidth  和 window.innerHeight  保存着可见视口，也就是屏幕上可见页面区域的大小。移动IE浏览器不支持这些属性，但通过document.documentElement.clientWidth  和 document.documentElement.clientHeihgt 提供了相同的信息。随着页面的缩放，这些值也会相应变化。</p><p>在其他移动浏览器中， document.documentElement 度量的是布局视口，即渲染后页面的实际大小（与可见视口不同，可见视口只是整个页面中的一小部分）。移动IE浏览器把布局视口的信息保存在 document.body.clientWidth和document.body.clientHeight  中。这些值不会随着页面缩放变化。</p><p>由于与桌面浏览器间存在这些差异，最好是先检测一下用户是否在使用移动设备，然后再决定使用哪个属性。</p><h4 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h4><p>使用 window.open() 方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。这个方法可以接收4个参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。</p><p>如果为 window.open() 传递了第二个参数，而且该参数是已有窗口或框架的名称，那么就会在具有该名称的窗口或框架中加载第一个参数指定的URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 等同于&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.domain.com&quot; target&#x3D;&quot;topFrame&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">window.open(&#39;https:&#x2F;&#x2F;www.domain.com&#x2F;&#39;, &#39;topFrame&#39;)</span><br></pre></td></tr></table></figure><h5 id="弹出窗口"><a href="#弹出窗口" class="headerlink" title="弹出窗口"></a>弹出窗口</h5><p>如果给window.open()传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根据在第三个参数位置上传入的字符串创建一个新窗口或新标签页。如果没有传入第三个参数，那么就会打开一个带有全部默认设置（工具栏、地址栏和状态栏等）的新浏览器窗口（或者打开一个新标签页——根据浏览器设置）。在不打开新窗口的情况下，会忽略第三个参数。</p><p>第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性。下表列出了可以出现在这个字符串中的设置选项。<br><img src="https://img-blog.csdn.net/20151013100024530?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><p>表中所列的部分或全部设置选项，都可以通过逗号分隔的名值对列表来指定。其中，名值对以等号表示（注意，整个特性字符串中不允许出现空格），如下面的例子所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.open(&quot;http:&#x2F;&#x2F;www.wrox.com&#x2F;&quot;,&quot;wroxWindow&quot;,</span><br><span class="line">&quot;height&#x3D;400,width&#x3D;400,top&#x3D;10,left&#x3D;10,resizable&#x3D;yes&quot;);</span><br></pre></td></tr></table></figure><p>window.open()方法会返回一个指向新窗口的引用。引用的对象与其他window 对象大致相似，但我们可以对其进行更多控制。例如，有些浏览器在默认情况下可能不允许我们针对主浏览器窗口调整大小或移动位置，但却允许我们针对通过window.open()创建的窗口调整大小或移动位置。通过这个返回的对象，可以像操作其他窗口一样操作新打开的窗口，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var wroxWin &#x3D; window.open(&quot;http:&#x2F;&#x2F;www.wrox.com&#x2F;&quot;,&quot;wroxWindow&quot;,</span><br><span class="line">&quot;height&#x3D;400,width&#x3D;400,top&#x3D;10,left&#x3D;10,resizable&#x3D;yes&quot;);</span><br><span class="line">&#x2F;&#x2F;调整大小</span><br><span class="line">wroxWin.resizeTo(500,500);</span><br><span class="line">&#x2F;&#x2F;移动位置</span><br><span class="line">wroxWin.moveTo(100,100);</span><br><span class="line">调用close()方法还可以关闭新打开的窗口。</span><br><span class="line">wroxWin.close();</span><br><span class="line">&#x2F;&#x2F; 这个方法仅适用于通过window.open()打开的弹出窗口</span><br></pre></td></tr></table></figure><p>新创建的window 对象有一个opener 属性，其中保存着打开它的原始窗口对象。这个属性只在弹出窗口中的最外层window 对象（top）中有定义，而且指向调用window.open()的窗口或框架。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var wroxWin &#x3D; window.open(&quot;http:&#x2F;&#x2F;www.wrox.com&#x2F;&quot;,&quot;wroxWindow&quot;,</span><br><span class="line">&quot;height&#x3D;400,width&#x3D;400,top&#x3D;10,left&#x3D;10,resizable&#x3D;yes&quot;);</span><br><span class="line">alert(wroxWin.opener &#x3D;&#x3D; window); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><p>虽然弹出窗口中有一个指针指向打开它的原始窗口，但原始窗口中并没有这样的指针指向弹出窗口。窗口并不跟踪记录它们打开的弹出窗口，因此我们只能在必要的时候自己来手动实现跟踪。有些浏览器（如IE8 和Chrome）会在独立的进程中运行每个标签页。当一个标签页打开另一个标签页时，如果两个window 对象之间需要彼此通信，那么新标签页就不能运行在独立的进程中。在Chrome中，将新创建的标签页的opener 属性设置为null，即表示在单独的进程中运行新标签页，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var wroxWin &#x3D; window.open(&quot;http:&#x2F;&#x2F;www.wrox.com&#x2F;&quot;,&quot;wroxWindow&quot;,</span><br><span class="line">&quot;height&#x3D;400,width&#x3D;400,top&#x3D;10,left&#x3D;10,resizable&#x3D;yes&quot;);</span><br><span class="line">wroxWin.opener &#x3D; null</span><br></pre></td></tr></table></figure><p>将opener 属性设置为null 就是告诉浏览器新创建的标签页不需要与打开它的标签页通信，因此可以在独立的进程中运行。标签页之间的联系一旦切断，将没有办法恢复。</p><h5 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h5><p>Windows XP SP2 中的IE6 对弹出窗口施加了多方面的安全限制，包括不允许在屏幕之外创建弹出窗口、不允许将弹出窗口移动到屏幕以外、不允许关闭状态栏等。IE7 则增加了更多的安全限制，如不允许关闭地址栏、默认情况下不允许移动弹出窗口或调整其大小。Firefox 1 从一开始就不支持修改状态栏，<br>因此无论给window.open()传入什么样的特性字符串，弹出窗口中都会无一例外地显示状态栏。后来的Firefox 3 又强制始终在弹出窗口中显示地址栏。Opera 只会在主浏览器窗口中打开弹出窗口，但不允许它们出现在可能与系统对话框混淆的地方。<br>此外，有的浏览器只根据用户操作来创建弹出窗口。这样一来，在页面尚未加载完成时调用window.open()的语句根本不会执行，而且还可能会将错误消息显示给用户。换句话说，只能通过单击或者击键来打开弹出窗口。对于那些不是用户有意打开的弹出窗口，Chrome 采取了不同的处理方式。它不会像其他浏览器那样简单地屏蔽这些弹出窗口，而是只显示它们的标题栏，并把它们放在浏览器窗口的右下角。</p><h5 id="弹出窗口屏蔽程序"><a href="#弹出窗口屏蔽程序" class="headerlink" title="弹出窗口屏蔽程序"></a>弹出窗口屏蔽程序</h5><p>大多数浏览器都内置有弹出窗口屏蔽程序，而没有内置此类程序的浏览器，也可以安装Yahoo!Toolbar 等带有内置屏蔽程序的实用工具。结果就是用户可以将绝大多数不想看到弹出窗口屏蔽掉。于是，在弹出窗口被屏蔽时，就应该考虑两种可能性。如果是浏览器内置的屏蔽程序阻止的弹出窗口，那么window.open()很可能会返回null。此时，只要检测这个返回的值就可以确定弹出窗口是否被屏蔽了，如下面的例子所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var wroxWin &#x3D; window.open(&quot;http:&#x2F;&#x2F;www.wrox.com&quot;, &quot;_blank&quot;);</span><br><span class="line">if (wroxWin &#x3D;&#x3D; null)&#123;</span><br><span class="line">alert(&quot;The popup was blocked!&quot;);</span><br></pre></td></tr></table></figure><p>如果是浏览器扩展或其他程序阻止的弹出窗口，那么window.open()通常会抛出一个错误。因此，要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对window.open()的调用封装在一个try-catch 块中，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var blocked &#x3D; false;</span><br><span class="line">try &#123;</span><br><span class="line">var wroxWin &#x3D; window.open(&quot;http:&#x2F;&#x2F;www.wrox.com&quot;, &quot;_blank&quot;);</span><br><span class="line">if (wroxWin &#x3D;&#x3D; null)&#123;</span><br><span class="line">blocked &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (ex)&#123;</span><br><span class="line">blocked &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">if (blocked)&#123;</span><br><span class="line">alert(&quot;The popup was blocked!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在任何情况下，以上代码都可以检测出调用window.open()打开的弹出窗口是不是被屏蔽了。但要注意的是，检测弹出窗口是否被屏蔽只是一方面，它并不会阻止浏览器显示被屏蔽的弹出窗口有关的消息。</p><h4 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h4><p>Javascript是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。前者是在指定的时间过后执行代码，而后者则是每隔指定的时间就执行一次代码。</p><p>超时调用需要使用window对象的setTimeout()方法，它接受两个参数：要执行的代码和以毫秒表示的时间(即在执行代码前需要等待多少毫秒)。其中，第一个参数可以是一个包含JS代码的字符串(就和在eval()函数中使用的字符串一样)，也可以是一个函数。虽然这两种调用方式都没有问题，但由于传递字符串可能导致性能损失，因此，不建议以字符串作为第一个参数。</p><p>第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定会执行。JS是一个单线程的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JS任务队列。这些任务会按照将他们添加到队列的顺序执行。setTimeout()的第二个参数告诉JS再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它要等前面的代码执行完了以后再执行。</p><p>调用setTimeout()之后，该方法会返回一个数值ID，表示超时调用。该ID是计划执行代码的唯一标识符，可以通过它来取消超时调用，可以调用clearTimeout()方法并将相应的超时调用ID作为参数传递给它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var timeoutId &#x3D; setTimeout(function() &#123;</span><br><span class="line">    alert(&#39;Hello world&#39;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">clearTimeout(timeoutId);</span><br></pre></td></tr></table></figure><p>超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象，在严格模式下是undefined。</p><p>间歇调用和超时调用类似，只不过它会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。设置间歇调用的方法是setInterval()，它接受的参数与setTimeout()相同；要执行的代码(字符串或函数)和每次执行之前需要等待的毫秒数。</p><p>要取消尚未执行的间歇调用，可以使用clearInterval()方法并传入相应的间歇调用ID。<br>取消间歇调用的重要性远远高于取消超时调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 0;</span><br><span class="line">var max &#x3D; 10;</span><br><span class="line">var intervalId &#x3D; null</span><br><span class="line"></span><br><span class="line">function incrementNumber() &#123;</span><br><span class="line">    num++;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果执行次数达到max设定的值，则取消后续尚未执行的调用</span><br><span class="line">    if(max &#x3D;&#x3D;&#x3D; num) &#123;</span><br><span class="line">        clearInterval(intercalId);</span><br><span class="line">        alert(&quot;Down&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var intercalId &#x3D; setInterval(incrementNumber, 1000);</span><br></pre></td></tr></table></figure><p>也可以使用超时调用来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 0;</span><br><span class="line">var max &#x3D; 10;</span><br><span class="line"></span><br><span class="line">function incrementNumber() &#123;</span><br><span class="line">    num++;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    if (num &lt; max) &#123;</span><br><span class="line">        setTimeout(incrementNumber, 1000);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        alert(&quot;Done&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(incrementNumber, 1000);</span><br></pre></td></tr></table></figure><p>可见，在使用超时调用时，没有必要跟踪超时调用ID，因此每次执行代码之后，如果不设置另一个超时调用，调用就会自行停止。一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境中，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。所以最好不要使用间歇调用。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;window对象&quot;&gt;&lt;a href=&quot;#window对象&quot; class=&quot;headerlink&quot; title=&quot;window对象&quot;&gt;&lt;/a&gt;window对象&lt;/h3&gt;&lt;p&gt;BOM的核心对象是window，他表示浏览器的一个实例。在浏览器中，window对象有双重角色，它既是通过Jacascript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。这意味着在网页中定义的任何一个对象、变量和函数，都以window作为其Global对象，因此有权访问parseInt()等方法。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
