<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端笔记</title>
  
  
  <link href="https://github.com/liubrook/liubrook.github.io/atom.xml" rel="self"/>
  
  <link href="https://github.com/liubrook/liubrook.github.io/"/>
  <updated>2020-10-14T08:15:40.115Z</updated>
  <id>https://github.com/liubrook/liubrook.github.io/</id>
  
  <author>
    <name>Brookliu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Express+MongoDB搭建图片分享社区二</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2020/10/14/Express-MongoDB%E6%90%AD%E5%BB%BA%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB%E7%A4%BE%E5%8C%BA%E4%BA%8C/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2020/10/14/Express-MongoDB%E6%90%AD%E5%BB%BA%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB%E7%A4%BE%E5%8C%BA%E4%BA%8C/</id>
    <published>2020-10-14T07:58:12.000Z</published>
    <updated>2020-10-14T08:15:40.115Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在上一篇文章<a href="https://brookliu.xyz/2020/10/13/Express-MongoDB%E6%90%AD%E5%BB%BA%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB%E7%A4%BE%E5%8C%BA%E4%B8%80/#more" target="_blank" rel="noopener">Express+MongoDB搭建图片分享社区一</a>中我们实现了路由、页面和数据渲染。</p><a id="more"></a> <p>本篇文章我们要实现图片上传、接入mongoDB数据库、评论、点赞、删除等功能。</p><h3 id="图片上传功能"><a href="#图片上传功能" class="headerlink" title="图片上传功能"></a>图片上传功能</h3><p>在根目录创建public/upload文件夹，用于存放用户上传的图片, 然后安装 multer 中间件用于处理文件上传：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i multer</span><br></pre></td></tr></table></figure><p>在 server/routes.js 模块中，我们初始化 multer 中间件，然后将其添加到上传图片的路由中（即 POST /images）, 代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const multer &#x3D; require(&#39;multer&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">const router &#x3D; express.Router();</span><br><span class="line">const upload &#x3D; multer(&#123; dest: path.join(__dirname, &#39;..&#x2F;public&#x2F;upload&#x2F;temp&#39;) &#125;);</span><br><span class="line">const home &#x3D; require(&#39;..&#x2F;controllers&#x2F;home&#39;);</span><br><span class="line">const image &#x3D; require(&#39;..&#x2F;controllers&#x2F;image&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; function(app) &#123;</span><br><span class="line">  router.get(&#39;&#x2F;&#39;, home.index);</span><br><span class="line">  router.get(&#39;&#x2F;images&#x2F;:image_id&#39;, image.index);</span><br><span class="line">  router.post(&#39;&#x2F;images&#39;, upload.single(&#39;file&#39;), image.create);</span><br><span class="line">  router.post(&#39;&#x2F;images&#x2F;:image_id&#x2F;like&#39;, image.like);</span><br><span class="line">  router.post(&#39;&#x2F;images&#x2F;:image_id&#x2F;comment&#39;, image.comment);</span><br><span class="line">  app.use(router);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码有两点需要讲解：</p><ul><li>第 6 行，在初始化 upload 中间件时，传入 dest 选项指定保存上传文件的路径，这里我们选择在 public/upload 目录中再创建一个 temp 目录用于临时保存上传到的图片。</li><li>第 14 行，router.post 除第一个参数为 URL，后面可以跟任意多个中间件，这里我们将上传文件的中间件添加到 image.create 控制器的前面，确保先处理用户上传的文件。这里 upload.single(‘file’) 表示只处理单个上传文件，并且字段名为 file，在后续中间件中就可以通过 req.file 进行获取。</li></ul><div class="note info"><p>注意</p><p>在dest选项这里图灵社区的路径是public/upload/temp，但是我在操作过程中发现这个路径不是项目根目录下，而是在当前server文件夹下，所以这里的路径要用../public/upload/temp</p></div><p>关于 multer 的详细用法，可以参考其<a href="https://github.com/expressjs/multer">文档</a></p><p>controller/image.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  index: function(req, res) &#123;</span><br><span class="line">    const viewModel &#x3D; &#123;</span><br><span class="line">      image: &#123;</span><br><span class="line">        uniqueId: 1,</span><br><span class="line">        title: &#39;示例图片1&#39;,</span><br><span class="line">        description: &#39;这是张测试图片&#39;,</span><br><span class="line">        filename: &#39;sample1.jpg&#39;,</span><br><span class="line">        views: 0,</span><br><span class="line">        likes: 0,</span><br><span class="line">        timestamp: Date.now(),</span><br><span class="line">      &#125;,</span><br><span class="line">      comments: [</span><br><span class="line">        &#123;</span><br><span class="line">          image_id: 1,</span><br><span class="line">          email: &#39;test@testing.com&#39;,</span><br><span class="line">          name: &#39;Test Tester&#39;,</span><br><span class="line">          comment: &#39;Test 1&#39;,</span><br><span class="line">          timestamp: Date.now(),</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          image_id: 1,</span><br><span class="line">          email: &#39;test@testing.com&#39;,</span><br><span class="line">          name: &#39;Test Tester&#39;,</span><br><span class="line">          comment: &#39;Test 2&#39;,</span><br><span class="line">          timestamp: Date.now(),</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;;</span><br><span class="line">    res.render(&#39;image&#39;, viewModel);</span><br><span class="line">  &#125;,</span><br><span class="line">  create: function(req, res) &#123;</span><br><span class="line">    var tempPath &#x3D; req.file.path;</span><br><span class="line">    var imgUrl &#x3D; req.file.filename;</span><br><span class="line">    var ext &#x3D; path.extname(req.file.originalname).toLowerCase();</span><br><span class="line">    var targetPath &#x3D; path.resolve(&#39;.&#x2F;public&#x2F;upload&#x2F;&#39; + imgUrl + ext);</span><br><span class="line"></span><br><span class="line">    if (ext &#x3D;&#x3D;&#x3D; &#39;.png&#39; || ext &#x3D;&#x3D;&#x3D; &#39;.jpg&#39; || ext &#x3D;&#x3D;&#x3D; &#39;.jpeg&#39; || ext &#x3D;&#x3D;&#x3D; &#39;.gif&#39;) &#123;</span><br><span class="line">      fs.rename(tempPath, targetPath, function(err) &#123;</span><br><span class="line">        if (err) throw err;</span><br><span class="line">        res.redirect(&#39;&#x2F;images&#x2F;&#39; + imgUrl);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      fs.unlink(tempPath, function(err) &#123;</span><br><span class="line">        if (err) throw err;</span><br><span class="line">        res.json(500, &#123; error: &#39;只允许上传图片文件.&#39; &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  like: function(req, res) &#123;</span><br><span class="line">    res.send(&#39;The image:like POST controller&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  comment: function(req, res) &#123;</span><br><span class="line">    res.send(&#39;The image:comment POST controller&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>req.file 是一个 Multer 文件对象，包括 path（上传到服务器的路径）、filename（服务器存储的文件名）和 originalname（文件初始名，即保存在客户端的文件名）等有用的属性。我截取了一张输出 req.file 所有字段的图片如下：<br><img src="https://static.tuture.co/c/69b697ed0cd9f890a636c9c78eb2ce0c/figure-4.png" alt="req.file图"></p><p>这里我们通过简单的后缀匹配来判断用户上传的是否为图片，如果是，则从临时目录 tempPath 存放到上传目录 targetPath 中，否则直接删除。上传成功后，通过 res.redirect 将页面重定向到刚刚上传的图片的详情页面。</p><h3 id="接入MongoDB数据库"><a href="#接入MongoDB数据库" class="headerlink" title="接入MongoDB数据库"></a>接入MongoDB数据库</h3><p>首先安装MongoDB：</p><p><a href="https://www.mongodb.com/try/download/community" target="_blank" rel="noopener">MongoDB官网</a><br><a href="https://www.runoob.com/mongodb/mongodb-osx-install.html" target="_blank" rel="noopener">菜鸟教程MongoDB安装</a></p><p>安装之后新开一个终端根据不同平台的对应方法打开数据库。</p><p>然后安装Mongoose：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mongoose</span><br></pre></td></tr></table></figure><p>Mongoose 是 MongoDB 最流行的 ODM（Object Document Mapping，对象文档映射），使用起来要比底层的 MongoDB Node 驱动更方便。</p><p>我们首先实现图片有关的数据模型。创建 models 目录，在其中添加 image.js 模块，并添加实现 ImageSchema 的代码：<br>model/image.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">const Schema &#x3D; mongoose.Schema;</span><br><span class="line"></span><br><span class="line">const ImageSchema &#x3D; new Schema(&#123;</span><br><span class="line">  title: &#123; type: String &#125;,</span><br><span class="line">  description: &#123; type: String &#125;,</span><br><span class="line">  filename: &#123; type: String &#125;,</span><br><span class="line">  views: &#123; type: Number, default: 0 &#125;,</span><br><span class="line">  likes: &#123; type: Number, default: 0 &#125;,</span><br><span class="line">  timestamp: &#123; type: Date, default: Date.now &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ImageSchema.virtual(&#39;uniqueId&#39;).get(function() &#123;</span><br><span class="line">  return this.filename.replace(path.extname(this.filename), &#39;&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; mongoose.model(&#39;Image&#39;, ImageSchema);</span><br></pre></td></tr></table></figure><p>我们在第 6 行到第 13 行定义了一个 Schema，即数据对象的模式，描述了这个模型的所有字段及相应的属性。这里我们为 ImageSchema 定义了六个字段，每个字段都有其类型（必须），views、likes 和 timestamp 还有相应的默认值（可选）。除了普通字段外，我们还定义了虚字段uniqueId。虚字段（virtuals）和普通字段的最大区别是不会保存到数据库中，而是在每次查询时临时计算，通常用于对普通字段进行格式调整或组合。在 Schema 定义完成后，我们将其编译为名为 Image 的模型并导出，方便在控制器中进行使用。</p><p>接着我们在 home 控制器中调用 ImageModel 来从数据库中获取全部图片：<br>controller/home.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const ImageModel &#x3D; require(&#39;..&#x2F;models&#x2F;image&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  index: function(req, res) &#123;</span><br><span class="line">    const viewModel &#x3D; &#123; images: [] &#125;;</span><br><span class="line"></span><br><span class="line">    ImageModel.find(&#123;&#125;, &#123;&#125;, &#123; sort: &#123; timestamp: -1 &#125; &#125;, function(err, images) &#123;</span><br><span class="line">      if (err) throw err;</span><br><span class="line">      viewModel.images &#x3D; images;</span><br><span class="line">      res.render(&#39;index&#39;, viewModel);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在第 39 行中，我们用 find 方法查询图片，所有的查询方法可参考 <a href="http://www.mongoosejs.net/" target="_blank" rel="noopener">Mongoose 中文文档</a>。find 是查询多条数据记录的通用方法，其四个参数如下：</p><ul><li>filter：过滤器，是一个 JavaScript 对象，例如 { name: ‘john’ } 则限定返回所有名字为 john 的记录，这里我们用 {} 表示查询所有记录；</li><li>projection（可选）：查询所返回的字段，可以是对象或字符串，我们用 {} 表示返回所有字段；</li><li>options（可选）：查询操作的选项，用来指定查询操作的一些参数，比如我们用 sort 选项对返回结果进行排序（这里按照发布时间 timestamp 进行倒序排列，即把最新发布的放在最前面）；</li><li>callback：回调函数，用于添加在查询完毕时的业务逻辑；</li></ul><p>进一步，我们在 image 控制器中添加数据库操作的代码：<br>controller/image.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const ImageModel &#x3D; require(&#39;..&#x2F;models&#x2F;image&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  index: function(req, res) &#123;</span><br><span class="line">    const viewModel &#x3D; &#123; image: &#123;&#125;, comments: [] &#125;;</span><br><span class="line"></span><br><span class="line">    ImageModel.findOne(&#123; filename: &#123; $regex: req.params.image_id &#125; &#125;, function(</span><br><span class="line">      err,</span><br><span class="line">      image,</span><br><span class="line">    ) &#123;</span><br><span class="line">      if (err) throw err;</span><br><span class="line">      if (image) &#123;</span><br><span class="line">        &#x2F;&#x2F; 增加该图片的访问量</span><br><span class="line">        image.views +&#x3D; 1;</span><br><span class="line">        viewModel.image &#x3D; image;</span><br><span class="line">        image.save();</span><br><span class="line">        res.render(&#39;image&#39;, viewModel);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        res.redirect(&#39;&#x2F;&#39;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  create: function(req, res) &#123;</span><br><span class="line">    var tempPath &#x3D; req.file.path;</span><br><span class="line">    var imgUrl &#x3D; req.file.filename;</span><br><span class="line">    var ext &#x3D; path.extname(req.file.originalname).toLowerCase();</span><br><span class="line">    var targetPath &#x3D; path.resolve(&#39;.&#x2F;public&#x2F;upload&#x2F;&#39; + imgUrl + ext);</span><br><span class="line"></span><br><span class="line">    if (ext &#x3D;&#x3D;&#x3D; &#39;.png&#39; || ext &#x3D;&#x3D;&#x3D; &#39;.jpg&#39; || ext &#x3D;&#x3D;&#x3D; &#39;.jpeg&#39; || ext &#x3D;&#x3D;&#x3D; &#39;.gif&#39;) &#123;</span><br><span class="line">      fs.rename(tempPath, targetPath, function(err) &#123;</span><br><span class="line">        if (err) throw err;</span><br><span class="line">        const newImg &#x3D; new ImageModel(&#123;</span><br><span class="line">          title: req.body.title,</span><br><span class="line">          description: req.body.description,</span><br><span class="line">          filename: imgUrl + ext,</span><br><span class="line">        &#125;);</span><br><span class="line">        newImg.save(function(err, image) &#123;</span><br><span class="line">          if (err) throw err;</span><br><span class="line">          res.redirect(&#39;&#x2F;images&#x2F;&#39; + image.uniqueId);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      fs.unlink(tempPath, function(err) &#123;</span><br><span class="line">        if (err) throw err;</span><br><span class="line">        res.json(500, &#123; error: &#39;只允许上传图片文件.&#39; &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  like: function(req, res) &#123;</span><br><span class="line">    res.send(&#39;The image:like POST controller&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  comment: function(req, res) &#123;</span><br><span class="line">    res.send(&#39;The image:comment POST controller&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 image.index 和 image.create 两个控制器中，我们分别进行了单条数据记录的查询和插入。findOne 与之前的 find 参数格式完全一致，只不过仅返回一条数据。在插入新数据时，先创建一个 ImageModel 实例，然后再调用 save 方法进行保存即可。</p><p>最后，我们需要在服务器刚刚运行时就连接好数据库，因此在 server.js 中添加如下代码：<br>server.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class="line">const configure &#x3D; require(&#39;.&#x2F;server&#x2F;configure&#39;);</span><br><span class="line"></span><br><span class="line">app &#x3D; express();</span><br><span class="line">app &#x3D; configure(app);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 建立数据库连接</span><br><span class="line">mongoose.connect(&#39;mongodb:&#x2F;&#x2F;localhost&#x2F;instagrammy&#39;);</span><br><span class="line">mongoose.connection.on(&#39;open&#39;, function() &#123;</span><br><span class="line">  console.log(&#39;Mongoose connected.&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.set(&#39;port&#39;, process.env.PORT || 3000);</span><br><span class="line"></span><br><span class="line">app.listen(app.get(&#39;port&#39;), function() &#123;</span><br><span class="line">  console.log(&#96;Server is running on http:&#x2F;&#x2F;localhost:$&#123;app.get(&#39;port&#39;)&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="运行过程中的问题"><a href="#运行过程中的问题" class="headerlink" title="运行过程中的问题"></a>运行过程中的问题</h3><p>这里我们运行服务器的话会有如下的输出信息:<br><img src="https://img.brookliu.xyz/blog/express%2BmongoDB-2-1.png" alt="输出1"></p><p>解决方法:<br>mongoose连接数据库时除了url参数外增加1个参数： {useNewUrlParser:true,useUnifiedTopology: true}<br>server.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class="line">const configure &#x3D; require(&#39;.&#x2F;server&#x2F;configure&#39;);</span><br><span class="line"></span><br><span class="line">app &#x3D; express();</span><br><span class="line">app &#x3D; configure(app);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 建立数据库连接</span><br><span class="line">mongoose.connect(&#39;mongodb:&#x2F;&#x2F;localhost&#x2F;instagrammy&#39;, &#123;useNewUrlParser:true,useUnifiedTopology:true &#125;);</span><br><span class="line">mongoose.connection.on(&#39;open&#39;, function() &#123;</span><br><span class="line">    console.log(&#39;Mongoose connected.&#39;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.set(&#39;port&#39;, process.env.PORT || 3000);</span><br><span class="line"></span><br><span class="line">app.listen(app.get(&#39;port&#39;), function() &#123;</span><br><span class="line">    console.log(&#96;Server is running on http:&#x2F;&#x2F;localhost:$&#123;app.get(&#39;port&#39;)&#125;&#96;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后我们重新运行服务器，打开<a href="http://localhost:3000" target="_blank" rel="noopener">localhost:3000</a>，我们会发现console有报错信息：<br><img src="https://img.brookliu.xyz/blog/express%2BmongoDB-2-2.png" alt="输出2"></p><p>我们走一下上传图片的过程，上传跳转到图片详情会发现页面是这个样子:<br><img src="https://img.brookliu.xyz/blog/express%2BmongoDB-2-3.png" alt="输出3"></p><p>在服务器的日志上发现有如下所示信息：<br><img src="https://img.brookliu.xyz/blog/express%2BmongoDB-2-4.png" alt="输出4"></p><p>在<a href="https://stackoverflow.com/questions/59690923/handlebars-access-has-been-denied-to-resolve-the-property-from-because-it-is" target="_blank" rel="noopener">stackoverflow</a>有这个问题的<br>相关讨论，有兴趣的可以去看一下</p><p>解决方法：</p><p>安装依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @handlebars&#x2F;allow-prototype-access</span><br></pre></td></tr></table></figure><p>然后修改server/configure.js的内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const Handlebars &#x3D; require(&#39;handlebars&#39;);</span><br><span class="line">const exphbs &#x3D; require(&#39;express-handlebars&#39;);</span><br><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const bodyParser &#x3D; require(&#39;body-parser&#39;);</span><br><span class="line">const cookieParser &#x3D; require(&#39;cookie-parser&#39;);</span><br><span class="line">const morgan &#x3D; require(&#39;morgan&#39;);</span><br><span class="line">const methodOverride &#x3D; require(&#39;method-override&#39;);</span><br><span class="line">const errorHandler &#x3D; require(&#39;errorhandler&#39;);</span><br><span class="line">const moment &#x3D; require(&#39;moment&#39;);</span><br><span class="line"></span><br><span class="line">const &#123; allowInsecurePrototypeAccess &#125; &#x3D; require(&#39;@handlebars&#x2F;allow-prototype-access&#39;);</span><br><span class="line"></span><br><span class="line">const routes &#x3D; require(&#39;.&#x2F;routes&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; function(app) &#123;</span><br><span class="line">    &#x2F;&#x2F; 定义 moment 全局语言 </span><br><span class="line">    moment.locale(&#39;zh-cn&#39;);</span><br><span class="line">    app.engine(&#39;handlebars&#39;, exphbs.create(&#123;</span><br><span class="line">        helpers: &#123;</span><br><span class="line">            timeago: function(timestamp) &#123;</span><br><span class="line">                return moment(timestamp).startOf(&#39;minute&#39;).fromNow();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        handlebars: allowInsecurePrototypeAccess(Handlebars)</span><br><span class="line">    &#125;).engine)</span><br><span class="line">    app.set(&#39;view engine&#39;, &#39;handlebars&#39;);</span><br><span class="line"></span><br><span class="line">    app.use(morgan(&#39;dev&#39;));</span><br><span class="line">    app.use(bodyParser.urlencoded(&#123; extended: true &#125;));</span><br><span class="line">    app.use(bodyParser.json());</span><br><span class="line">    app.use(methodOverride());</span><br><span class="line">    app.use(cookieParser(&#39;secret-value&#39;));</span><br><span class="line">    app.use(&#39;&#x2F;public&#x2F;&#39;, express.static(path.join(__dirname, &#39;..&#x2F;public&#39;)));</span><br><span class="line"></span><br><span class="line">    if (app.get(&#39;env&#39;) &#x3D;&#x3D;&#x3D; &#39;development&#39;) &#123;</span><br><span class="line">        app.use(errorHandler())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    routes(app);</span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们来重新运行服务器，尝试上传图片，可以发现不仅能上传成功，还可以在首页看到新添加的图片了！</p><h3 id="实现评论功能"><a href="#实现评论功能" class="headerlink" title="实现评论功能"></a>实现评论功能</h3><p>这一步我们来实现网站的评论功能。按照 MVC 模式，我们将依次实现评论的模型（M）、视图（V）和控制器（C）。<br>首先，仿照 models/image.js，我们实现评论的数据模型：<br>models/comment.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class="line"></span><br><span class="line">const Schema &#x3D; mongoose.Schema;</span><br><span class="line">const ObjectId &#x3D; Schema.ObjectId;</span><br><span class="line"></span><br><span class="line">const CommentSchema &#x3D; new Schema(&#123;</span><br><span class="line">  image_id: &#123; type: ObjectId &#125;,</span><br><span class="line">  email: &#123; type: String &#125;,</span><br><span class="line">  name: &#123; type: String &#125;,</span><br><span class="line">  gravatar: &#123; type: String &#125;,</span><br><span class="line">  comment: &#123; type: String &#125;,</span><br><span class="line">  timestamp: &#123; type: Date, default: Date.now &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">CommentSchema.virtual(&#39;image&#39;)</span><br><span class="line">  .set(function(image) &#123;</span><br><span class="line">    this._image &#x3D; image;</span><br><span class="line">  &#125;)</span><br><span class="line">  .get(function() &#123;</span><br><span class="line">    return this._image;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; mongoose.model(&#39;Comment&#39;, CommentSchema);</span><br></pre></td></tr></table></figure><p>CommentSchema 有两个字段需要补充说明一下：</p><ul><li>image_id：由于图片和评论是一对多的关系（即一张图片包括多个评论），因此我们需要在记录每个评论所属的图片，即通过 image_id 字段进行记录；</li><li>gravatar：用 MD5 对电子邮箱加密后得到的字符串，用于访问 <a href="https://en.gravatar.com/" target="_blank" rel="noopener">Gravatar 服务</a>。Gravatar 提供了跨网站的头像服务，如果你在集成了 Gravatar 服务的网站通过邮箱注册并上传了头像，那么别的网站也可以通过 Gravatar 访问你的头像。这里请通过 npm install md5 安装 MD5 加密的包。</li></ul><p>我们对评论有关的界面代码进行细微的调整，将提交按钮的 type 从 button 改为 submit：<br>views/image.handlebars<br><img src="https://img.brookliu.xyz/blog/express%2BmongoDB-2-5.png" alt="评论"></p><p>最后是评论有关的 controller 代码。包括在 image.comment 中实现创建评论，以及在 image.index 中实现对单张图片所有评论的查询：<br>controllers/image.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const md5 &#x3D; require(&#39;md5&#39;);</span><br><span class="line">const ImageModel &#x3D; require(&#39;..&#x2F;models&#x2F;image&#39;);</span><br><span class="line">const CommentModel &#x3D; require(&#39;..&#x2F;models&#x2F;comment&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  index: function(req, res) &#123;</span><br><span class="line">    const viewModel &#x3D; &#123; image: &#123;&#125;, comments: [] &#125;;</span><br><span class="line"></span><br><span class="line">    ImageModel.findOne(&#123; filename: &#123; $regex: req.params.image_id &#125; &#125;, function(</span><br><span class="line">      err,</span><br><span class="line">      image,</span><br><span class="line">    ) &#123;</span><br><span class="line">      if (err) throw err;</span><br><span class="line">      if (image) &#123;</span><br><span class="line">        &#x2F;&#x2F; 增加该图片的访问量</span><br><span class="line">        image.views +&#x3D; 1;</span><br><span class="line">        viewModel.image &#x3D; image;</span><br><span class="line">        image.save();</span><br><span class="line"></span><br><span class="line">        CommentModel.find(</span><br><span class="line">          &#123; image_id: image._id &#125;,</span><br><span class="line">          &#123;&#125;,</span><br><span class="line">          &#123; sort: &#123; timestamp: 1 &#125; &#125;,</span><br><span class="line">          function(err, comments) &#123;</span><br><span class="line">            if (err) throw err;</span><br><span class="line">            viewModel.comments &#x3D; comments;</span><br><span class="line">            res.render(&#39;image&#39;, viewModel);</span><br><span class="line">          &#125;,</span><br><span class="line">        );</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        res.redirect(&#39;&#x2F;&#39;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  create: function(req, res) &#123;</span><br><span class="line">    var tempPath &#x3D; req.file.path;</span><br><span class="line">    var imgUrl &#x3D; req.file.filename;</span><br><span class="line">    var ext &#x3D; path.extname(req.file.originalname).toLowerCase();</span><br><span class="line">    var targetPath &#x3D; path.resolve(&#39;.&#x2F;public&#x2F;upload&#x2F;&#39; + imgUrl + ext);</span><br><span class="line"></span><br><span class="line">    if (ext &#x3D;&#x3D;&#x3D; &#39;.png&#39; || ext &#x3D;&#x3D;&#x3D; &#39;.jpg&#39; || ext &#x3D;&#x3D;&#x3D; &#39;.jpeg&#39; || ext &#x3D;&#x3D;&#x3D; &#39;.gif&#39;) &#123;</span><br><span class="line">      fs.rename(tempPath, targetPath, function(err) &#123;</span><br><span class="line">        if (err) throw err;</span><br><span class="line">        const newImg &#x3D; new ImageModel(&#123;</span><br><span class="line">          title: req.body.title,</span><br><span class="line">          description: req.body.description,</span><br><span class="line">          filename: imgUrl + ext,</span><br><span class="line">        &#125;);</span><br><span class="line">        newImg.save(function(err, image) &#123;</span><br><span class="line">          if (err) throw err;</span><br><span class="line">          res.redirect(&#39;&#x2F;images&#x2F;&#39; + image.uniqueId);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      fs.unlink(tempPath, function(err) &#123;</span><br><span class="line">        if (err) throw err;</span><br><span class="line">        res.json(500, &#123; error: &#39;只允许上传图片文件.&#39; &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  like: function(req, res) &#123;</span><br><span class="line">    res.send(&#39;The image:like POST controller&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  comment: function(req, res) &#123;</span><br><span class="line">    ImageModel.findOne(&#123; filename: &#123; $regex: req.params.image_id &#125; &#125;, function(</span><br><span class="line">      err,</span><br><span class="line">      image,</span><br><span class="line">    ) &#123;</span><br><span class="line">      if (!err &amp;&amp; image) &#123;</span><br><span class="line">        const newComment &#x3D; new CommentModel(req.body);</span><br><span class="line">        newComment.gravatar &#x3D; md5(newComment.email);</span><br><span class="line">        newComment.image_id &#x3D; image._id;</span><br><span class="line">        newComment.save(function(err, comment) &#123;</span><br><span class="line">          if (err) throw err;</span><br><span class="line">          res.redirect(&#39;&#x2F;images&#x2F;&#39; + image.uniqueId + &#39;#&#39; + comment._id);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        res.redirect(&#39;&#x2F;&#39;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>查询与创建评论的代码和之前操作图片的代码大部分都是一致的，最大的差别在于查询时需要根据所属的图片 ID，创建时需要记录图片的 ID。这里我们约定使用 MongoDB 为每一条数据默认创建的 _id 字段。</p><p>接下来我们重启服务器，然后找一张图片点进详情测试一下评论功能<br><img src="https://img.brookliu.xyz/blog/express%2BmongoDB-2-6.png" alt="评论"></p><h3 id="实现图片的点赞和删除"><a href="#实现图片的点赞和删除" class="headerlink" title="实现图片的点赞和删除"></a>实现图片的点赞和删除</h3><p>这一步我们来实现图片的点赞和删除。<br>首先在控制器中添加点赞和删除的代码:<br>controller/image.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const md5 &#x3D; require(&#39;md5&#39;);</span><br><span class="line">const ImageModel &#x3D; require(&#39;..&#x2F;models&#x2F;image&#39;);</span><br><span class="line">const CommentModel &#x3D; require(&#39;..&#x2F;models&#x2F;comment&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  index: function(req, res) &#123;</span><br><span class="line">    const viewModel &#x3D; &#123; image: &#123;&#125;, comments: [] &#125;;</span><br><span class="line"></span><br><span class="line">    ImageModel.findOne(&#123; filename: &#123; $regex: req.params.image_id &#125; &#125;, function(</span><br><span class="line">      err,</span><br><span class="line">      image,</span><br><span class="line">    ) &#123;</span><br><span class="line">      if (err) throw err;</span><br><span class="line">      if (image) &#123;</span><br><span class="line">        &#x2F;&#x2F; 增加该图片的访问量</span><br><span class="line">        image.views +&#x3D; 1;</span><br><span class="line">        viewModel.image &#x3D; image;</span><br><span class="line">        image.save();</span><br><span class="line"></span><br><span class="line">        CommentModel.find(</span><br><span class="line">          &#123; image_id: image._id &#125;,</span><br><span class="line">          &#123;&#125;,</span><br><span class="line">          &#123; sort: &#123; timestamp: 1 &#125; &#125;,</span><br><span class="line">          function(err, comments) &#123;</span><br><span class="line">            if (err) throw err;</span><br><span class="line">            viewModel.comments &#x3D; comments;</span><br><span class="line">            res.render(&#39;image&#39;, viewModel);</span><br><span class="line">          &#125;,</span><br><span class="line">        );</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        res.redirect(&#39;&#x2F;&#39;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  create: function(req, res) &#123;</span><br><span class="line">    var tempPath &#x3D; req.file.path;</span><br><span class="line">    var imgUrl &#x3D; req.file.filename;</span><br><span class="line">    var ext &#x3D; path.extname(req.file.originalname).toLowerCase();</span><br><span class="line">    var targetPath &#x3D; path.resolve(&#39;.&#x2F;public&#x2F;upload&#x2F;&#39; + imgUrl + ext);</span><br><span class="line"></span><br><span class="line">    if (ext &#x3D;&#x3D;&#x3D; &#39;.png&#39; || ext &#x3D;&#x3D;&#x3D; &#39;.jpg&#39; || ext &#x3D;&#x3D;&#x3D; &#39;.jpeg&#39; || ext &#x3D;&#x3D;&#x3D; &#39;.gif&#39;) &#123;</span><br><span class="line">      fs.rename(tempPath, targetPath, function(err) &#123;</span><br><span class="line">        if (err) throw err;</span><br><span class="line">        const newImg &#x3D; new ImageModel(&#123;</span><br><span class="line">          title: req.body.title,</span><br><span class="line">          description: req.body.description,</span><br><span class="line">          filename: imgUrl + ext,</span><br><span class="line">        &#125;);</span><br><span class="line">        newImg.save(function(err, image) &#123;</span><br><span class="line">          if (err) throw err;</span><br><span class="line">          res.redirect(&#39;&#x2F;images&#x2F;&#39; + image.uniqueId);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      fs.unlink(tempPath, function(err) &#123;</span><br><span class="line">        if (err) throw err;</span><br><span class="line">        res.json(500, &#123; error: &#39;只允许上传图片文件.&#39; &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  like: function(req, res) &#123;</span><br><span class="line">    ImageModel.findOne(&#123; filename: &#123; $regex: req.params.image_id &#125; &#125;, function(</span><br><span class="line">      err,</span><br><span class="line">      image,</span><br><span class="line">    ) &#123;</span><br><span class="line">      if (!err &amp;&amp; image) &#123;</span><br><span class="line">        image.likes +&#x3D; 1;</span><br><span class="line">        image.save(function(err) &#123;</span><br><span class="line">          if (err) res.json(err);</span><br><span class="line">          else res.json(&#123; likes: image.likes &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  remove: function(req, res) &#123;</span><br><span class="line">    ImageModel.findOne(&#123; filename: &#123; $regex: req.params.image_id &#125; &#125;, function(</span><br><span class="line">      err,</span><br><span class="line">      image,</span><br><span class="line">    ) &#123;</span><br><span class="line">      if (err) throw err;</span><br><span class="line">      fs.unlink(path.resolve(&#39;.&#x2F;public&#x2F;upload&#x2F;&#39; + image.filename), function(</span><br><span class="line">        err,</span><br><span class="line">      ) &#123;</span><br><span class="line">        if (err) throw err;</span><br><span class="line">        CommentModel.remove(&#123; image_id: image._id &#125;, function(err) &#123;</span><br><span class="line">          image.remove(function(err) &#123;</span><br><span class="line">            if (!err) &#123;</span><br><span class="line">              res.json(true);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              res.json(false);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  comment: function(req, res) &#123;</span><br><span class="line">    ImageModel.findOne(&#123; filename: &#123; $regex: req.params.image_id &#125; &#125;, function(</span><br><span class="line">      err,</span><br><span class="line">      image,</span><br><span class="line">    ) &#123;</span><br><span class="line">      if (!err &amp;&amp; image) &#123;</span><br><span class="line">        const newComment &#x3D; new CommentModel(req.body);</span><br><span class="line">        newComment.gravatar &#x3D; md5(newComment.email);</span><br><span class="line">        newComment.image_id &#x3D; image._id;</span><br><span class="line">        newComment.save(function(err, comment) &#123;</span><br><span class="line">          if (err) throw err;</span><br><span class="line">          res.redirect(&#39;&#x2F;images&#x2F;&#39; + image.uniqueId + &#39;#&#39; + comment._id);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        res.redirect(&#39;&#x2F;&#39;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在两个控制器中，我们都按照查询 -&gt; 修改 -&gt; 保存的流程进行操作。不过在删除图片中，我们不仅先删除上传图片，再删除了此图片所有的评论模型，最后再删除数据库中的图片模型，这一切通过 Model.remove 方法都可以轻松实现。remove 的使用方法与之前的 find 几乎一模一样，只不过 find 会返回符合条件的结果，而 remove 则会直接将符合条件的记录从数据库中删除。</p><p>我们在路由模块 server/routes.js 中添加刚刚写好的 image.remove 控制器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const multer &#x3D; require(&#39;multer&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">const router &#x3D; express.Router();</span><br><span class="line">const upload &#x3D; multer(&#123; dest: path.join(__dirname, &#39;public&#x2F;upload&#x2F;temp&#39;) &#125;);</span><br><span class="line">const home &#x3D; require(&#39;..&#x2F;controllers&#x2F;home&#39;);</span><br><span class="line">const image &#x3D; require(&#39;..&#x2F;controllers&#x2F;image&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; function(app) &#123;</span><br><span class="line">  router.get(&#39;&#x2F;&#39;, home.index);</span><br><span class="line">  router.get(&#39;&#x2F;images&#x2F;:image_id&#39;, image.index);</span><br><span class="line">  router.post(&#39;&#x2F;images&#39;, upload.single(&#39;file&#39;), image.create);</span><br><span class="line">  router.post(&#39;&#x2F;images&#x2F;:image_id&#x2F;like&#39;, image.like);</span><br><span class="line">  router.post(&#39;&#x2F;images&#x2F;:image_id&#x2F;comment&#39;, image.comment);</span><br><span class="line">  router.delete(&#39;&#x2F;images&#x2F;:image_id&#39;, image.remove);</span><br><span class="line">  app.use(router);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们来重新运行服务器，然后试一下点赞和删除发现并没有任何作用，因为上面的只是服务端的逻辑，前端页面显示并没有对应的逻辑，所以我们用jQuery来实现前端的点赞和删除请求。<br>views/layouts/main.handlebars</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Instagrammy&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;link href&#x3D;&quot;http:&#x2F;&#x2F;netdna.bootstrapcdn.com&#x2F;bootstrap&#x2F;3.1.1&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">  &lt;link href&#x3D;&quot;http:&#x2F;&#x2F;netdna.bootstrapcdn.com&#x2F;font-awesome&#x2F;4.0.3&#x2F;css&#x2F;font-awesome.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;page-header&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;col-md-6&quot;&gt;</span><br><span class="line">        &lt;h1&gt;&lt;a href&#x3D;&quot;&#x2F;&quot;&gt;Instagrammy&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;row&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;col-sm-8&quot;&gt;&#123;&#123;&#123;body&#125;&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;col-sm-4&quot;&gt;</span><br><span class="line">        &#123;&#123;&gt; stats this&#125;&#125;</span><br><span class="line">        &#123;&#123;&gt; popular this&#125;&#125;</span><br><span class="line">        &#123;&#123;&gt; comments this&#125;&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.4.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  $(function () &#123;</span><br><span class="line">    &#x2F;&#x2F; to do...</span><br><span class="line">  &#125;);</span><br><span class="line">  $(&#39;#btn-like&#39;).on(&#39;click&#39;, function (event) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    var imgId &#x3D; $(this).data(&#39;id&#39;);</span><br><span class="line">    $.post(&#39;&#x2F;images&#x2F;&#39; + imgId + &#39;&#x2F;like&#39;).done(function (data) &#123;</span><br><span class="line">      $(&#39;.likes-count&#39;).text(data.likes);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  $(&#39;#btn-delete&#39;).on(&#39;click&#39;, function (event) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    var $this &#x3D; $(this);</span><br><span class="line">    var remove &#x3D; confirm(&#39;确定要删除这张图片吗?&#39;);</span><br><span class="line">    if (remove) &#123;</span><br><span class="line">      var imgId &#x3D; $(this).data(&#39;id&#39;);</span><br><span class="line">      $</span><br><span class="line">        .ajax(&#123;</span><br><span class="line">          url: &#39;&#x2F;images&#x2F;&#39; + imgId,</span><br><span class="line">          type: &#39;DELETE&#39;</span><br><span class="line">        &#125;)</span><br><span class="line">        .done(function (result) &#123;</span><br><span class="line">          if (result) &#123;</span><br><span class="line">            $this.removeClass(&#39;btn-danger&#39;).addClass(&#39;btn-success&#39;);</span><br><span class="line">            $this.find(&#39;i&#39;).removeClass(&#39;fa-times&#39;).addClass(&#39;fa-check&#39;);</span><br><span class="line">            $this.append(&#39;&lt;span&gt; 已删除!&lt;&#x2F;span&gt;&#39;);</span><br><span class="line">            alert(&#39;删除成功&#39;);</span><br><span class="line">            window.location.href&#x3D;document.referrer;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>现在我们重新运行服务器，然后打开<a href="http://localhost:3000" target="_blank" rel="noopener">localhost:3000</a>来体验下点赞和删除功能，可以看到点赞和删除已经实现了，下一步我们将完善侧边栏的数据同步更新。</p><h3 id="完善用户界面"><a href="#完善用户界面" class="headerlink" title="完善用户界面"></a>完善用户界面</h3><p>这一步我们将实现侧边栏所有数据的同步更新。<br>首先先创建helpers目录用于存放侧边栏数据获取的相关代码。然后分析一下数据同步逻辑（例如统计数据），我们发现要进行的查询非常多：图片总数、评论总数、图片所有的访问量、图片所有的点赞数。如果按照普通的写法，我们也许会这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">queryA(function(err, resultsA) &#123;</span><br><span class="line">  queryB(function(err, resultsB) &#123;</span><br><span class="line">    queryC(function(err, resultsC) &#123;</span><br><span class="line">      queryD(function(err, resultsD) &#123;</span><br><span class="line">        &#x2F;&#x2F; some code ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码不仅十分丑陋，难以维护（即大家常说的 “回调地狱”），而且性能也十分糟糕 —— 所有查询都是链式执行。但其实所有的查询都是相互独立的，完全可以并发进行，那我们应该怎么写呢？</p><p>答案就是 <a href="http://caolan.github.io/async/v3/" target="_blank" rel="noopener">async</a> 库。async 是在 ECMAScript 6 的 Promise 体系出现之前最流行的异步组件库，凭借其强大的性能、丰富且设计良好的接口成为 Node 和前端开发中解决异步的最佳选择之一。这里我们也用 async 来解决并发获取数据的问题。安装 async 包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i async</span><br></pre></td></tr></table></figure><p>然后创建helpers/stats.js用户获取网站统计数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">const async &#x3D; require(&#39;async&#39;);</span><br><span class="line">const ImageModel &#x3D; require(&#39;..&#x2F;models&#x2F;image&#39;);</span><br><span class="line">const CommentModel &#x3D; require(&#39;..&#x2F;models&#x2F;comment&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; function(callback) &#123;</span><br><span class="line">  async.parallel(</span><br><span class="line">    [</span><br><span class="line">      function(next) &#123;</span><br><span class="line">        &#x2F;&#x2F; 统计图片总数</span><br><span class="line">        ImageModel.countDocuments(&#123;&#125;, next);</span><br><span class="line">      &#125;,</span><br><span class="line">      function(next) &#123;</span><br><span class="line">        &#x2F;&#x2F; 统计评论总数</span><br><span class="line">        CommentModel.countDocuments(&#123;&#125;, next);</span><br><span class="line">      &#125;,</span><br><span class="line">      function(next) &#123;</span><br><span class="line">        &#x2F;&#x2F; 对图片所有访问量求和</span><br><span class="line">        ImageModel.aggregate(</span><br><span class="line">          [</span><br><span class="line">            &#123;</span><br><span class="line">              $group: &#123;</span><br><span class="line">                _id: &#39;1&#39;,</span><br><span class="line">                viewsTotal: &#123; $sum: &#39;$views&#39; &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          ],</span><br><span class="line">          function(err, result) &#123;</span><br><span class="line">            if (err) &#123;</span><br><span class="line">              return next(err);</span><br><span class="line">            &#125;</span><br><span class="line">            var viewsTotal &#x3D; 0;</span><br><span class="line">            if (result.length &gt; 0) &#123;</span><br><span class="line">              viewsTotal +&#x3D; result[0].viewsTotal;</span><br><span class="line">            &#125;</span><br><span class="line">            next(null, viewsTotal);</span><br><span class="line">          &#125;,</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">      function(next) &#123;</span><br><span class="line">        &#x2F;&#x2F; 对所有点赞数求和</span><br><span class="line">        ImageModel.aggregate(</span><br><span class="line">          [</span><br><span class="line">            &#123;</span><br><span class="line">              $group: &#123;</span><br><span class="line">                _id: &#39;1&#39;,</span><br><span class="line">                likesTotal: &#123; $sum: &#39;$likes&#39; &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          ],</span><br><span class="line">          function(err, result) &#123;</span><br><span class="line">            if (err) &#123;</span><br><span class="line">              return next(err);</span><br><span class="line">            &#125;</span><br><span class="line">            var likesTotal &#x3D; 0;</span><br><span class="line">            if (result.length &gt; 0) &#123;</span><br><span class="line">              likesTotal +&#x3D; result[0].likesTotal;</span><br><span class="line">            &#125;</span><br><span class="line">            next(null, likesTotal);</span><br><span class="line">          &#125;,</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    function(err, results) &#123;</span><br><span class="line">      callback(null, &#123;</span><br><span class="line">        images: results[0],</span><br><span class="line">        comments: results[1],</span><br><span class="line">        views: results[2],</span><br><span class="line">        likes: results[3],</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们用到了 async.parallel 接口，它接受两个参数：</p><ul><li>tasks：一个函数数组，每个函数对应一个异步任务（所有任务将并发执行），并且接受一个回调函数用于返回任务执行的结果；</li><li>callback：整个任务组的回调函数，可以获取所有异步任务执行完成后的所有结果。</li></ul><p>我们将四个数据查询任务包装成四个函数作为 async.parallel 的第一个参数，在最后的 callback 中返回所有查询结果。非常简洁、优雅。</p><p>接下来实现侧边栏中的最新图片模块，一个简单的数据库查询即可：<br>helpers/images.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const ImageModel &#x3D; require(&#39;..&#x2F;models&#x2F;image&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    popular: function(callback) &#123;</span><br><span class="line">        ImageModel.find(&#123;&#125;, &#123;&#125;, &#123; limit: 9, sort: &#123; likes: 01 &#125; &#125;, function(err, images) &#123;</span><br><span class="line">            if (err) return callback(err);</span><br><span class="line">            callback(null, images);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是创建获取最新评论的代码。不过简单地查询评论模型是不够的，我们还需要获取到每个评论对应的图片，这时候用 async.each 函数对一个数组中所有对象进行异步操作最为合适不过。整个模块的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const async &#x3D; require(&#39;async&#39;);</span><br><span class="line">const ImageModel &#x3D; require(&#39;..&#x2F;models&#x2F;image&#39;);</span><br><span class="line">const CommentModel &#x3D; require(&#39;..&#x2F;models&#x2F;comment&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    newest: function(callback) &#123;</span><br><span class="line">        CommentModel.find(&#123;&#125;, &#123;&#125;, &#123; limit: 5, sort: &#123; timestamp: -1 &#125; &#125;, function(err, comments) &#123;</span><br><span class="line">            if (err) return callback(err);</span><br><span class="line">            var attachImage &#x3D; function(comment, next) &#123;</span><br><span class="line">                ImageModel.findOne(&#123; _id: comment.image_id &#125;, function(err, image) &#123;</span><br><span class="line">                    if (err) throw err;</span><br><span class="line">                    comment.image &#x3D; image;</span><br><span class="line">                    next(err);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            async.each(comments, attachImage, function(err) &#123;</span><br><span class="line">                if (err) throw err;</span><br><span class="line">                callback(err, comments);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>async.each 函数接受的三个参数如下：</p><ul><li>collection：用于接收异步操作的集合，这里是评论集；</li><li>iteratee：异步操作函数，这里是 attachImage 函数；</li><li>callback：全部操作执行完成的回调函数；</li></ul><p>然后将前面三个 helper 函数放到一起，创建一个 sidebar 模块，并发获取三个模块的数据。这里我们还是用 async.parallel 函数，因为三个模块本质上也是异步查询：<br>helpers/sidebars.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const async &#x3D; require(&#39;async&#39;);</span><br><span class="line">const Stats &#x3D; require(&#39;.&#x2F;stats&#39;);</span><br><span class="line">const Images &#x3D; require(&#39;.&#x2F;images&#39;);</span><br><span class="line">const Comments &#x3D; require(&#39;.&#x2F;comments&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; function(viewModel, callback) &#123;</span><br><span class="line">    async.parallel(</span><br><span class="line">        [</span><br><span class="line">            function(next) &#123;</span><br><span class="line">                Stats(next);</span><br><span class="line">            &#125;,</span><br><span class="line">            function(next) &#123;</span><br><span class="line">                Images.popular(next);</span><br><span class="line">            &#125;,</span><br><span class="line">            function(next) &#123;</span><br><span class="line">                Comments.newest(next);</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        function(err, results) &#123;</span><br><span class="line">            viewModel.sidebar &#x3D; &#123;</span><br><span class="line">                stats: results[0],</span><br><span class="line">                popular: results[1],</span><br><span class="line">                comments: results[2]</span><br><span class="line">            &#125;</span><br><span class="line">            callback(viewModel);</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将sidebar 模块用到 home 和 image 控制器中：<br>controllers/home.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const sidebar &#x3D; require(&#39;..&#x2F;helpers&#x2F;sidebar&#39;);</span><br><span class="line">const ImageModel &#x3D; require(&#39;..&#x2F;models&#x2F;image&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  index: function(req, res) &#123;</span><br><span class="line">    const viewModel &#x3D; &#123; images: [] &#125;;</span><br><span class="line"></span><br><span class="line">    ImageModel.find(&#123;&#125;, &#123;&#125;, &#123; sort: &#123; timestamp: -1 &#125; &#125;, function(err, images) &#123;</span><br><span class="line">      if (err) throw err;</span><br><span class="line">      viewModel.images &#x3D; images;</span><br><span class="line">      sidebar(viewModel, function(viewModel) &#123;</span><br><span class="line">        res.render(&#39;index&#39;, viewModel);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>controllers/image.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const md5 &#x3D; require(&#39;md5&#39;);</span><br><span class="line">const sidebar &#x3D; require(&#39;..&#x2F;helpers&#x2F;sidebar&#39;);</span><br><span class="line">const ImageModel &#x3D; require(&#39;..&#x2F;models&#x2F;image&#39;);</span><br><span class="line">const CommentModel &#x3D; require(&#39;..&#x2F;models&#x2F;comment&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    index: function(req, res) &#123;</span><br><span class="line">        const viewModel &#x3D; &#123; image: &#123;&#125;, comments: [] &#125;;</span><br><span class="line">        ImageModel.findOne(&#123; filename: &#123; $regex: req.params.image_id &#125; &#125;, function(err, image) &#123;</span><br><span class="line">          if (err) throw err;</span><br><span class="line">          if (image) &#123;</span><br><span class="line">            &#x2F;&#x2F; 增加该图片的访问量</span><br><span class="line">            image.views +&#x3D; 1;</span><br><span class="line">            viewModel.image &#x3D; image;</span><br><span class="line">            image.save();</span><br><span class="line"></span><br><span class="line">            CommentModel.find(</span><br><span class="line">              &#123; image_id: image._id &#125;,</span><br><span class="line">              &#123;&#125;,</span><br><span class="line">              &#123; sort: &#123; timestamp: 1 &#125; &#125;,</span><br><span class="line">              function(err, comments) &#123;</span><br><span class="line">                if (err) throw err;</span><br><span class="line">                viewModel.comments &#x3D; comments;</span><br><span class="line">                sidebar(viewModel, function(viewModel) &#123;</span><br><span class="line">                  res.render(&#39;image&#39;, viewModel);</span><br><span class="line">                &#125;)</span><br><span class="line">              &#125;</span><br><span class="line">            )</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            res.redirect(&#39;&#x2F;&#39;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    create: function(req, res) &#123;</span><br><span class="line">        var tempPath &#x3D; req.file.path;</span><br><span class="line">        var imgUrl &#x3D; req.file.filename;</span><br><span class="line">        var ext &#x3D; path.extname(req.file.originalname).toLowerCase();</span><br><span class="line">        var targetPath &#x3D; path.resolve(&#39;.&#x2F;public&#x2F;upload&#x2F;&#39; + imgUrl + ext);</span><br><span class="line"></span><br><span class="line">        if (ext &#x3D;&#x3D;&#x3D; &#39;.png&#39; || ext &#x3D;&#x3D;&#x3D; &#39;.jpg&#39; || ext &#x3D;&#x3D;&#x3D; &#39;.jpeg&#39; || ext &#x3D;&#x3D;&#x3D; &#39;.gif&#39;) &#123;</span><br><span class="line">          fs.rename(tempPath, targetPath, function(err) &#123;</span><br><span class="line">            if (err) throw err;</span><br><span class="line">            const newImg &#x3D; new ImageModel(&#123;</span><br><span class="line">              title: req.body.title,</span><br><span class="line">              description: req.body.description,</span><br><span class="line">              filename: imgUrl + ext</span><br><span class="line">            &#125;)</span><br><span class="line">            newImg.save(function(err, image) &#123;</span><br><span class="line">              if (err) throw err;</span><br><span class="line">              res.redirect(&#39;&#x2F;images&#x2F;&#39; + image.uniqueId);</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          fs.unlink(tempPath, function(err) &#123;</span><br><span class="line">            if (err) throw err;</span><br><span class="line">            res.json(500, &#123; error: &#39;只允许上传图片文件.&#39; &#125;);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    like: function(req, res) &#123;</span><br><span class="line">        ImageModel.findOne(&#123; filename: &#123; $regex: req.params.image_id &#125; &#125;, function(err, image) &#123;</span><br><span class="line">          if (!err &amp;&amp; image) &#123;</span><br><span class="line">            image.likes +&#x3D; 1;</span><br><span class="line">            image.save(function(err) &#123;</span><br><span class="line">              if (err) res.json(err);</span><br><span class="line">              else res.json(&#123; likes: image.likes &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    remove: function(req, res) &#123;</span><br><span class="line">      ImageModel.findOne(&#123; filename: &#123; $regex: req.params.image_id &#125; &#125;, function(err, image) &#123;</span><br><span class="line">        if (err) throw err;</span><br><span class="line">        fs.unlink(path.resolve(&#39;.&#x2F;public&#x2F;upload&#x2F;&#39; + image.filename), function(err) &#123;</span><br><span class="line">          if (err) throw err;</span><br><span class="line">          CommentModel.remove(&#123; image_id: image._id &#125;, function(err) &#123;</span><br><span class="line">            image.remove(function(err) &#123;</span><br><span class="line">              if (!err) &#123;</span><br><span class="line">                res.json(true);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                Response.json(false);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    comment: function(req, res) &#123;</span><br><span class="line">        ImageModel.findOne(&#123; filename: &#123; $regex: req.params.image_id &#125; &#125;, function(err, image) &#123;</span><br><span class="line">          if (!err &amp;&amp; image) &#123;</span><br><span class="line">            const newComment &#x3D; new CommentModel(req.body);</span><br><span class="line">            newComment.gravatar &#x3D; md5(newComment.email);</span><br><span class="line">            newComment.image_id &#x3D; image._id;</span><br><span class="line">            newComment.save(function(err, comment) &#123;</span><br><span class="line">              if (err) throw err;</span><br><span class="line">              res.redirect(&#39;&#x2F;images&#x2F;&#39; + image.uniqueId + &#39;#&#39; + comment._id);</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            res.redirect(&#39;&#x2F;&#39;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们来重新运行服务器看下侧边栏的数据有没有同步更新吧!</p><p>到这里我们今天要实现的功能已经全部实现了，你可以在这个的基础上自己再拓展。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在上一篇文章&lt;a href=&quot;https://brookliu.xyz/2020/10/13/Express-MongoDB%E6%90%AD%E5%BB%BA%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB%E7%A4%BE%E5%8C%BA%E4%B8%80/#more&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Express+MongoDB搭建图片分享社区一&lt;/a&gt;中我们实现了路由、页面和数据渲染。&lt;/p&gt;</summary>
    
    
    
    <category term="Node" scheme="https://github.com/liubrook/liubrook.github.io/categories/Node/"/>
    
    
    <category term="Node" scheme="https://github.com/liubrook/liubrook.github.io/tags/Node/"/>
    
    <category term="Express" scheme="https://github.com/liubrook/liubrook.github.io/tags/Express/"/>
    
    <category term="MongoDB" scheme="https://github.com/liubrook/liubrook.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Express+MongoDB搭建图片分享社区一</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2020/10/13/Express-MongoDB%E6%90%AD%E5%BB%BA%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB%E7%A4%BE%E5%8C%BA%E4%B8%80/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2020/10/13/Express-MongoDB%E6%90%AD%E5%BB%BA%E5%9B%BE%E7%89%87%E5%88%86%E4%BA%AB%E7%A4%BE%E5%8C%BA%E4%B8%80/</id>
    <published>2020-10-13T01:44:19.000Z</published>
    <updated>2020-10-13T07:09:48.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="初始化项目结构"><a href="#初始化项目结构" class="headerlink" title="初始化项目结构"></a>初始化项目结构</h3><p>首先创建目录，并初始化(如果你想放在GitHub上的话，先在GitHub上建一个仓库然后clone下来)：<br>初始化的时候可以一路enter下来，如果你不在意的话。</p><a id="more"></a> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir Instagrammy &amp;&amp; cd Instagrammy</span><br><span class="line"></span><br><span class="line">npm init</span><br></pre></td></tr></table></figure><p>安装express</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i express</span><br></pre></td></tr></table></figure><p>最终生成的package.json文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;instagrammy&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;express&quot;: &quot;^4.17.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在项目根目录新建入口文件server.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line"></span><br><span class="line">app &#x3D; express();</span><br><span class="line"></span><br><span class="line">app.set(&#39;port&#39;, process.env.PORT || 3000);</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;&#39;, function(req, res) &#123;</span><br><span class="line">    res.send(&#39;Hello World!&#39;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(app.get(&#39;port&#39;), function() &#123;</span><br><span class="line">    console.log(&#96;Server is running on http:&#x2F;&#x2F;localhost:$&#123;app.get(&#39;port&#39;)&#125;&#96;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行<code>node server.js</code>，然后在浏览器中访问<a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a>，就可以在页面上看到服务器返回的Hello World!</p><p>这里为了接下去运行项目方便，我们在package.json中添加启动命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;node server.js&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置中间件"><a href="#配置中间件" class="headerlink" title="配置中间件"></a>配置中间件</h3><p>Express 本身是一个非常简洁的 web 框架，但是通过中间件这一设计模式，能够实现非常丰富的功能。一个 Express 中间件本质上是一个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function someMiddleware(req, res, next) &#123;&#125;</span><br></pre></td></tr></table></figure><p>req 参数是一个 express.Request 对象，封装了用户请求；res 参数则是一个 express.Response 对象，封装了即将返回给用户的响应；next 则是在执行完所有逻辑后用于触发下一个中间件的函数。</p><p>添加中间件的代码则非常简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.use(middlewareA);</span><br><span class="line">app.use(middlewareB);</span><br><span class="line">app.use(middlewareC);</span><br></pre></td></tr></table></figure><p>中间件 A、B、C 将会在处理每次请求时按顺序执行（这也意味着中间件的顺序是非常重要的）。接下来我们将添加以下基础中间件（也是几乎所有应用都会用到的中间件）：</p><ul><li>morgan：用于记录日志的中间件，对于开发调试和生产监控都很有用；</li><li>bodyParser：用于解析客户端请求的中间件，包括 HTML 表单和 JSON 请求；</li><li>methodOverride：为老的浏览器提供 REST 请求的兼容性支持；</li><li>cookieParser：用于收发 cookie；</li><li>errorHandler：用于在发生错误时打印调用栈，仅在开发时使用；</li><li>handlebars：用于渲染用户界面的模板引擎，会在后面细讲。</li></ul><p>我们通过 npm 安装这些中间件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express-handlebars body-parser cookie-parser morgan method-override errorhandler</span><br></pre></td></tr></table></figure><p>在项目根目录创建server目录，在server目录下创建configure.js文件用于配置所有的中间件，文件内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const exphbs &#x3D; require(&#39;express-handlebars&#39;);</span><br><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const bodyParser &#x3D; require(&#39;body-parser&#39;);</span><br><span class="line">const cookieParser &#x3D; require(&#39;cookie-parser&#39;);</span><br><span class="line">const morgan &#x3D; require(&#39;morgan&#39;);</span><br><span class="line">const methodOverride &#x3D; require(&#39;method-override&#39;);</span><br><span class="line">const errorHandler &#x3D; require(&#39;errorhandler&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; function(app) &#123;</span><br><span class="line">    app.use(morgan(&#39;dev&#39;));</span><br><span class="line">    app.use(bodyParser.urlencoded(&#123; extended: true &#125;));</span><br><span class="line">    app.use(bodyParser.json());</span><br><span class="line">    app.use(methodOverride());</span><br><span class="line">    app.use(cookieParser(&#39;secret-value&#39;));</span><br><span class="line">    app.use(&#39;&#x2F;public&#x2F;&#39;, express.static(path.join(__dirname, &#39;..&#x2F;public&#39;)));</span><br><span class="line"></span><br><span class="line">    if (app.get(&#39;env&#39;) &#x3D;&#x3D;&#x3D; &#39;development&#39;) &#123;</span><br><span class="line">        app.use(errorHandler())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>express.static是express自带的静态资源中间件，用于向客户端发送图片、css等静态文件。最后，我们通过env变量来判断是否处于开发环境，如果是的话就添加errorHandler以便于调试代码。</p><p>在server.js中调用刚才配置中间件的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const configure &#x3D; require(&#39;.&#x2F;server&#x2F;configure&#39;);</span><br><span class="line"></span><br><span class="line">app &#x3D; express();</span><br><span class="line">app &#x3D; configure(app);</span><br><span class="line"></span><br><span class="line">app.set(&#39;port&#39;, process.env.PORT || 3000);</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;&#39;, function(req, res) &#123;</span><br><span class="line">    res.send(&#39;Hello World!&#39;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(app.get(&#39;port&#39;), function() &#123;</span><br><span class="line">    console.log(&#96;Server is running on http:&#x2F;&#x2F;localhost:$&#123;app.get(&#39;port&#39;)&#125;&#96;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="搭建路由和控制器"><a href="#搭建路由和控制器" class="headerlink" title="搭建路由和控制器"></a>搭建路由和控制器</h3><p>在上面的步骤中我们配置好了基础的中间件，但是只有主页(/)可以访问，下面我们要实现以下路由:</p><ul><li>GET /：网站主页。</li><li>GET /images/image_id：展示单张图片。</li><li>POST /images：上传图片。</li><li>POST /images/image_id/like：点赞图片。</li><li>POST /images/image_id/comment：评论图片。</li></ul><p>我们采用前端最熟悉的MVC模式来搭建下面的内容。</p><p>首先创建controllers目录，在该目录下新建home.js文件定义index控制器，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  index: function(req, res) &#123;</span><br><span class="line">    res.send(&#39;The home:index controller&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个控制器实际上都是一个 Express 中间件（只不过不需要 next 函数，因为是最后一个中间件）。这里我们暂时用 res.send 发一条文字来代表这个 controller 已经实现。</p><p>再在 controllers 目录下创建 image.js，实现与图片处理相关的控制器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  index: function(req, res) &#123;</span><br><span class="line">    res.send(&#39;The image:index controller &#39; + req.params.image_id);</span><br><span class="line">  &#125;,</span><br><span class="line">  create: function(req, res) &#123;</span><br><span class="line">    res.send(&#39;The image:create POST controller&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  like: function(req, res) &#123;</span><br><span class="line">    res.send(&#39;The image:like POST controller&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  comment: function(req, res) &#123;</span><br><span class="line">    res.send(&#39;The image:comment POST controller&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在 server 目录下创建路由模块 routes.js，建立从 URL 到控制器之间的映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line"></span><br><span class="line">const router &#x3D; express.Router();</span><br><span class="line">const home &#x3D; require(&#39;..&#x2F;controllers&#x2F;home&#39;);</span><br><span class="line">const image &#x3D; require(&#39;..&#x2F;controllers&#x2F;image&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; function(app) &#123;</span><br><span class="line">  router.get(&#39;&#x2F;&#39;, home.index);</span><br><span class="line">  router.get(&#39;&#x2F;images&#x2F;:image_id&#39;, image.index);</span><br><span class="line">  router.post(&#39;&#x2F;images&#39;, image.create);</span><br><span class="line">  router.post(&#39;&#x2F;images&#x2F;:image_id&#x2F;like&#39;, image.like);</span><br><span class="line">  router.post(&#39;&#x2F;images&#x2F;:image_id&#x2F;comment&#39;, image.comment);</span><br><span class="line">  app.use(router);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们用到了 Express 自带的路由类 Router，可以很方便地定义路由，并且 Router 本身也是一个中间件，可以直接通过 app.use 进行配置。</p><p>接着在 server/configure.js 模块中调用路由模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const exphbs &#x3D; require(&#39;express-handlebars&#39;);</span><br><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const bodyParser &#x3D; require(&#39;body-parser&#39;);</span><br><span class="line">const cookieParser &#x3D; require(&#39;cookie-parser&#39;);</span><br><span class="line">const morgan &#x3D; require(&#39;morgan&#39;);</span><br><span class="line">const methodOverride &#x3D; require(&#39;method-override&#39;);</span><br><span class="line">const errorHandler &#x3D; require(&#39;errorhandler&#39;);</span><br><span class="line"></span><br><span class="line">const routes &#x3D; require(&#39;.&#x2F;routes&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; function(app) &#123;</span><br><span class="line">  app.use(morgan(&#39;dev&#39;));</span><br><span class="line">  app.use(bodyParser.urlencoded(&#123; extended: true &#125;));</span><br><span class="line">  app.use(bodyParser.json());</span><br><span class="line">  app.use(methodOverride());</span><br><span class="line">  app.use(cookieParser(&#39;secret-value&#39;));</span><br><span class="line">  app.use(&#39;&#x2F;public&#x2F;&#39;, express.static(path.join(__dirname, &#39;..&#x2F;public&#39;)));</span><br><span class="line"></span><br><span class="line">  if (app.get(&#39;env&#39;) &#x3D;&#x3D;&#x3D; &#39;development&#39;) &#123;</span><br><span class="line">    app.use(errorHandler());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  routes(app);</span><br><span class="line">  return app;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后我们去掉 server.js 中原来的首页路由。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const configure &#x3D; require(&#39;.&#x2F;server&#x2F;configure&#39;);</span><br><span class="line"></span><br><span class="line">app &#x3D; express();</span><br><span class="line">app &#x3D; configure(app);</span><br><span class="line">app.set(&#39;port&#39;, process.env.PORT || 3000);</span><br><span class="line"></span><br><span class="line">app.listen(app.get(&#39;port&#39;), function() &#123;</span><br><span class="line">  console.log(&#96;Server is running on http:&#x2F;&#x2F;localhost:$&#123;app.get(&#39;port&#39;)&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在我们运行服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p>打开浏览器访问<a href="http://localhost:3000" target="_blank" rel="noopener">localhost:3000</a>可以看到页面展示的The home:index controller。访问<a href="http://localhost:3000/images/test123" target="_blank" rel="noopener">localhost:3000/images/test123</a>，则是The image:index controller test123。</p><h3 id="配置handlebars模板引擎"><a href="#配置handlebars模板引擎" class="headerlink" title="配置handlebars模板引擎"></a>配置handlebars模板引擎</h3><p>这一步我们来实现界面展示，首页的效果如下图所示：<br><img src="https://static.tuture.co/c/69b697ed0cd9f890a636c9c78eb2ce0c/figure-2.png" alt="首页效果图"></p><p>图片详情页的效果如下图:<br><img src="https://static.tuture.co/c/69b697ed0cd9f890a636c9c78eb2ce0c/figure-3.png" alt="图片详情页"></p><p>尽管如今前后端分离已经是大势所趋，但是通过模板引擎在服务器端渲染页面也是有用武之地的，特别是快速地开发一些简单的应用。在模板引擎中，<a href="https://handlebarsjs.com/" target="_blank" rel="noopener">Handlebars</a> 和 <a href="https://pugjs.org/api/getting-started.html" target="_blank" rel="noopener">Pug</a> 当属其中的佼佼者。由于 Handlebars 和普通的 HTML 文档几乎完全一致，容易上手，因此这篇教程中我们选用 Handlebars，并且选用 Bootstrap 样式。</p><p>与普通的 HTML 文档相比，模板最大的特点即在于提供了数据的接入。例如 handlebars，可以在双花括号 &#123;&#123; &#125;&#125; 之间填写任何数据，当服务器渲染页面时只需传入相应的数据即可渲染成对应的内容。除此之外，handlebars 还支持条件语法、循环语法和模板嵌套等高级功能，下面将详细描述。</p><p>我们创建一个 views 目录，用于存放所有的模板代码。views 目录的结构如下所示：<br><img src="https://img.brookliu.xyz/blog/express%2BmongoDB-1-1.png" alt="view目录"></p><p>其中 image.handlebars 和 index.handlebars 是页面模板，layouts/main.handlebars 则是整个网站的布局模板（所有页面共享），partials 目录则用于存放页面之间共享的组件模板，例如评论、数据等等。</p><p>首先完成布局模板 layouts/main.handlebars：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Instagrammy&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;http:&#x2F;&#x2F;netdna.bootstrapcdn.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;page-header&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;col-md-6&quot;&gt;</span><br><span class="line">                &lt;h1&gt;&lt;a href&#x3D;&quot;&#x2F;&quot;&gt;Instagrammy&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;row&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;col-sm-8&quot;&gt;&#123;&#123;&#123;body&#125;&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>main.handlebars 本身是一个完整的 HTML 文档，包括 head 和 body 部分。在 head 部分，我们定义了网站的一些元数据，还加入了 Bootstrap 的 CDN 链接；在 body 部分，包含两个容器：网站头部（header）和每个页面的自定义内容（即 &#123;&#123;&#123;body&#125;&#125;&#125; ）。</p><p>接下来编写主页内容index.handlebars，页面内容先用标题占位:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;Index Page&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure><p>图片详情页面内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;Image Page&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure><p>index.handlebars 和 image.handlebars 的内容将替换布局模板中的 &#123;&#123;&#123;body&#125;&#125;&#125; 部分。在用户访问某个页面时，页面内容 = 布局模板 + 页面模板。</p><p>模板写好之后，我们修改控制器controller/home.js相应的代码，通过 res.render 函数渲染模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  index: function(req, res) &#123;</span><br><span class="line">    res.render(&#39;index&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>render 函数接受一个字符串参数，即页面模板的名称。例如 index.handlebars 的名称即为 index。</p><p>同样地，我们修改 image 控制器controllers/image.js的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  index: function(req, res) &#123;</span><br><span class="line">    res.render(&#39;image&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  create: function(req, res) &#123;</span><br><span class="line">    res.send(&#39;The image:create POST controller&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  like: function(req, res) &#123;</span><br><span class="line">    res.send(&#39;The image:like POST controller&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  comment: function(req, res) &#123;</span><br><span class="line">    res.send(&#39;The image:comment POST controller&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后在server/configure.js中配置handlebars中间件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const exphbs &#x3D; require(&#39;express-handlebars&#39;);</span><br><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const bodyParser &#x3D; require(&#39;body-parser&#39;);</span><br><span class="line">const cookieParser &#x3D; require(&#39;cookie-parser&#39;);</span><br><span class="line">const morgan &#x3D; require(&#39;morgan&#39;);</span><br><span class="line">const methodOverride &#x3D; require(&#39;method-override&#39;);</span><br><span class="line">const errorHandler &#x3D; require(&#39;errorhandler&#39;);</span><br><span class="line"></span><br><span class="line">const routes &#x3D; require(&#39;.&#x2F;routes&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; function(app) &#123;</span><br><span class="line">  app.engine(&#39;handlebars&#39;, exphbs());</span><br><span class="line">  app.set(&#39;view engine&#39;, &#39;handlebars&#39;);</span><br><span class="line"></span><br><span class="line">  app.use(morgan(&#39;dev&#39;));</span><br><span class="line">  app.use(bodyParser.urlencoded(&#123; extended: true &#125;));</span><br><span class="line">  app.use(bodyParser.json());</span><br><span class="line">  app.use(methodOverride());</span><br><span class="line">  app.use(cookieParser(&#39;secret-value&#39;));</span><br><span class="line">  app.use(&#39;&#x2F;public&#x2F;&#39;, express.static(path.join(__dirname, &#39;..&#x2F;public&#39;)));</span><br><span class="line"></span><br><span class="line">  if (app.get(&#39;env&#39;) &#x3D;&#x3D;&#x3D; &#39;development&#39;) &#123;</span><br><span class="line">    app.use(errorHandler());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  routes(app);</span><br><span class="line">  return app;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>到这里我们这一步就完成了，现在<code>npm start</code>运行服务器，访问主页localhost:3000和图片详情页面localhost:3000/images/test就可以看到对应的页面了，虽然没有数据.</p><h3 id="完善页面代码"><a href="#完善页面代码" class="headerlink" title="完善页面代码"></a>完善页面代码</h3><p>首先在index.handlebars中添加上传图片的表单和展示最新图片的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; views&#x2F;index.handlebars</span><br><span class="line">&lt;div class&#x3D;&quot;panel panel-primary&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;panel-heading&quot;&gt;</span><br><span class="line">    &lt;h3 class&#x3D;&quot;panel-title&quot;&gt;</span><br><span class="line">      上传图片</span><br><span class="line">    &lt;&#x2F;h3&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;form action&#x3D;&quot;&#x2F;images&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;panel-body form-horizontal&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;form-group col-md-12&quot;&gt;</span><br><span class="line">        &lt;label for&#x3D;&quot;file&quot; class&#x3D;&quot;col-sm-2 control-label&quot;&gt;浏览:&lt;&#x2F;label&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;col-md-10&quot;&gt;</span><br><span class="line">          &lt;input type&#x3D;&quot;file&quot; class&#x3D;&quot;form-control&quot; name&#x3D;&quot;file&quot; id&#x3D;&quot;file&quot;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;form-group col-md-12&quot;&gt;</span><br><span class="line">        &lt;label for&#x3D;&quot;title&quot; class&#x3D;&quot;col-md-2 control-label&quot;&gt;标题:&lt;&#x2F;label&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;col-md-10&quot;&gt;</span><br><span class="line">          &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; name&#x3D;&quot;title&quot;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;form-group col-md-12&quot;&gt;</span><br><span class="line">        &lt;label for&#x3D;&quot;description&quot; class&#x3D;&quot;col-md-2 control-label&quot;&gt;描述:&lt;&#x2F;label&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;col-md-10&quot;&gt;</span><br><span class="line">          &lt;textarea name&#x3D;&quot;description&quot; rows&#x3D;&quot;2&quot; class&#x3D;&quot;form-control&quot;&gt;&lt;&#x2F;textarea&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;form-group col-md-12&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;col-md-12 text-right&quot;&gt;</span><br><span class="line">          &lt;button type&#x3D;&quot;submit&quot; id&#x3D;&quot;login-btn&quot; class&#x3D;&quot;btn btn-success&quot;&gt;</span><br><span class="line">            &lt;i class&#x3D;&quot;fa fa-cloud-upload&quot;&gt; 上传图片&lt;&#x2F;i&gt;</span><br><span class="line">          &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;panel panel-default&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;panel-heading&quot;&gt;</span><br><span class="line">    &lt;h3 class&#x3D;&quot;panel-title&quot;&gt;</span><br><span class="line">      最新图片</span><br><span class="line">    &lt;&#x2F;h3&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;panel-body&quot;&gt;</span><br><span class="line">    &#123;&#123;#each images&#125;&#125;</span><br><span class="line">      &lt;div class&#x3D;&quot;col-md-4 text-center&quot; style&#x3D;&quot;padding-bottom: 1em;&quot;&gt;</span><br><span class="line">        &lt;a href&#x3D;&quot;&#x2F;images&#x2F;&#123;&#123;uniqueId&#125;&#125;&quot;&gt;</span><br><span class="line">          &lt;img src&#x3D;&quot;&#x2F;public&#x2F;upload&#x2F;&#123;&#123;filename&#125;&#125;&quot; alt&#x3D;&quot;&#123;&#123;title&#125;&#125;&quot;</span><br><span class="line">            style&#x3D;&quot;width: 175px; height: 175px;&quot; class&#x3D;&quot;img-thumbnail&quot;&gt;</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &#123;&#123;&#x2F;each&#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>在展示最新图片时，我们用到了 handlebars 提供的循环语法（第 46 行到 53 行）。对于传入模板的数据对象 images 进行遍历，每个循环中可以访问单个 image 的全部属性，例如 uniqueId 等等。</p><p>接着完善 image.handlebars 的内容，包括展示图片的详细内容、发表评论的表单和展示所有评论的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; views&#x2F;image.handlebars</span><br><span class="line">&lt;div class&#x3D;&quot;panel panel-primary&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;panel-heading&quot;&gt;</span><br><span class="line">    &lt;h2 class&#x3D;&quot;panel-title&quot;&gt;&#123;&#123;image.title&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;panel-body&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;image.description&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;col-md-12 text-center&quot;&gt;</span><br><span class="line">      &lt;img src&#x3D;&quot;&#x2F;public&#x2F;upload&#x2F;&#123;&#123;image.filename&#125;&#125;&quot; alt&#x3D;&quot;&#123;&#123;image.title&#125;&#125;&quot;</span><br><span class="line">        class&#x3D;&quot;thumbnail&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;panel-footer&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;row&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;col-md-8&quot;&gt;</span><br><span class="line">        &lt;button class&#x3D;&quot;btn btn-success&quot; id&#x3D;&quot;btn-like&quot; data-id&#x3D;&quot;&#123;&#123;image.uniqueId&#125;&#125;&quot;&gt;</span><br><span class="line">          &lt;i class&#x3D;&quot;fa fa-heart&quot;&gt; 点赞&lt;&#x2F;i&gt;</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;strong class&#x3D;&quot;likes-count&quot;&gt;&#123;&#123;image.likes&#125;&#125;&lt;&#x2F;strong&gt; &amp;nbsp; - &amp;nbsp;</span><br><span class="line">        &lt;i class&#x3D;&quot;fa fa-eye&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">        &lt;strong&gt;&#123;&#123;image.views&#125;&#125;&lt;&#x2F;strong&gt;</span><br><span class="line">        &amp;nbsp; - &amp;nbsp; 发表于: &lt;em class&#x3D;&quot;text-muted&quot;&gt;&#123;&#123;image.timestamp&#125;&#125;&lt;&#x2F;em&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;col-md-4 text-right&quot;&gt;</span><br><span class="line">        &lt;button class&#x3D;&quot;btn btn-danger&quot; id&#x3D;&quot;btn-delete&quot; data-id&#x3D;&quot;&#123;&#123;image.uniqueId&#125;&#125;&quot;&gt;</span><br><span class="line">          &lt;i class&#x3D;&quot;fa fa-times&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;panel panel-default&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;panel-heading&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;row&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;col-md-8&quot;&gt;</span><br><span class="line">        &lt;strong class&#x3D;&quot;panel-title&quot;&gt;评论&lt;&#x2F;strong&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;col-md-4 text-right&quot;&gt;</span><br><span class="line">        &lt;button class&#x3D;&quot;btn btn-default btn-sm&quot; id&#x3D;&quot;btn-comment&quot; data-id&#x3D;&quot;&#123;&#123;image.uniqueId&#125;&#125;&quot;&gt;</span><br><span class="line">          &lt;i class&#x3D;&quot;fa fa-comments-o&quot;&gt; 发表评论...&lt;&#x2F;i&gt;</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;panel-body&quot;&gt;</span><br><span class="line">    &lt;blockquote id&#x3D;&quot;post-comment&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;row&quot;&gt;</span><br><span class="line">        &lt;form action&#x3D;&quot;&#x2F;images&#x2F;&#123;&#123;image.uniqueId&#125;&#125;&#x2F;comment&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">          &lt;div class&#x3D;&quot;form-group col-sm-12&quot;&gt;</span><br><span class="line">            &lt;label for&#x3D;&quot;name&quot; class&#x3D;&quot;col-sm-2 control-label&quot;&gt;昵称:&lt;&#x2F;label&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;col-sm-10&quot;&gt;&lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; name&#x3D;&quot;name&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">          &lt;&#x2F;div&gt;</span><br><span class="line">          &lt;div class&#x3D;&quot;form-group col-sm-12&quot;&gt;</span><br><span class="line">            &lt;label for&#x3D;&quot;email&quot; class&#x3D;&quot;col-sm-2 control-label&quot;&gt;Email:&lt;&#x2F;label&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;col-sm-10&quot;&gt;&lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; name&#x3D;&quot;email&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">          &lt;&#x2F;div&gt;</span><br><span class="line">          &lt;div class&#x3D;&quot;form-group col-sm-12&quot;&gt;</span><br><span class="line">            &lt;label for&#x3D;&quot;comment&quot; class&#x3D;&quot;col-sm-2 control-label&quot;&gt;评论:&lt;&#x2F;label&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;col-sm-10&quot;&gt;</span><br><span class="line">              &lt;textarea name&#x3D;&quot;comment&quot; class&#x3D;&quot;form-control&quot; rows&#x3D;&quot;2&quot;&gt;&lt;&#x2F;textarea&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">          &lt;&#x2F;div&gt;</span><br><span class="line">          &lt;div class&#x3D;&quot;form-group col-sm-12&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;col-sm-12 text-right&quot;&gt;</span><br><span class="line">              &lt;button class&#x3D;&quot;btn btn-success&quot; id&#x3D;&quot;comment-btn&quot; type&#x3D;&quot;button&quot;&gt;</span><br><span class="line">                &lt;i class&#x3D;&quot;fa fa-comment&quot;&gt;&lt;&#x2F;i&gt; 发表</span><br><span class="line">              &lt;&#x2F;button&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">          &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;form&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;blockquote&gt;</span><br><span class="line">    &lt;ul class&#x3D;&quot;media-list&quot;&gt;</span><br><span class="line">      &#123;&#123;#each comments&#125;&#125;</span><br><span class="line">      &lt;li class&#x3D;&quot;media&quot;&gt;</span><br><span class="line">        &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;pull-left&quot;&gt;</span><br><span class="line">          &lt;img src&#x3D;&quot;http:&#x2F;&#x2F;www.gravatar.com&#x2F;avatar&#x2F;&#123;&#123;gravatar&#125;&#125;?d&#x3D;monsterid&amp;s&#x3D;45&quot;</span><br><span class="line">            class&#x3D;&quot;media-object img-circle&quot;&gt;</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;media-body&quot;&gt;</span><br><span class="line">          &#123;&#123;comment&#125;&#125;</span><br><span class="line">          &lt;br&#x2F;&gt;</span><br><span class="line">          &lt;strong class&#x3D;&quot;media-heading&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;strong&gt;</span><br><span class="line">          &lt;small class&#x3D;&quot;text-muted&quot;&gt;&#123;&#123;timestamp&#125;&#125;&lt;&#x2F;small&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">      &#123;&#123;&#x2F;each&#125;&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>在展示所有评论的代码中，我们同样用到了 handlebars 的循环语法，非常方便。</p><p>然后，我们将分别实现网站右边栏中的统计数据、最受欢迎图片和最新评论组件。</p><p>首先是统计数据组件模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; views&#x2F;partials&#x2F;stats.handlebars</span><br><span class="line">&lt;div class&#x3D;&quot;panel panel-default&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;panel-heading&quot;&gt;</span><br><span class="line">    &lt;h3 class&#x3D;&quot;panel-title&quot;&gt;统计数据&lt;&#x2F;h3&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;panel-body&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;row&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;col-md-4 text-left&quot;&gt;图片:&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;col-md-8 text-right&quot;&gt;&#123;&#123;sidebar.stats.images&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;row&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;col-md-4 text-left&quot;&gt;评论:&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;col-md-8 text-right&quot;&gt;&#123;&#123;sidebar.stats.comments&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;row&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;col-md-4 text-left&quot;&gt;浏览:&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;col-md-8 text-right&quot;&gt;&#123;&#123;sidebar.stats.views&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;row&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;col-md-4 text-left&quot;&gt;点赞:&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;col-md-8 text-right&quot;&gt;&#123;&#123;sidebar.stats.likes&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>最受欢迎图片组件（popular.handlebars）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; views&#x2F;partials&#x2F;popular.handlebars</span><br><span class="line">&lt;div class&#x3D;&quot;panel panel-default&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;panel-heading&quot;&gt;</span><br><span class="line">    &lt;h3 class&#x3D;&quot;panel-title&quot;&gt;最受欢迎&lt;&#x2F;h3&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;panel-body&quot;&gt;</span><br><span class="line">    &#123;&#123;#each sidebar.popular&#125;&#125;</span><br><span class="line">      &lt;div class&#x3D;&quot;col-md-4 text-center&quot; style&#x3D;&quot;padding-bottom: .5em;&quot;&gt;</span><br><span class="line">        &lt;a href&#x3D;&quot;&#x2F;images&#x2F;&#123;&#123;uniqueId&#125;&#125;&quot;&gt;</span><br><span class="line">          &lt;img src&#x3D;&quot;&#x2F;public&#x2F;upload&#x2F;&#123;&#123;filename&#125;&#125;&quot; style&#x3D;&quot;width: 75px; height: 75px;&quot;</span><br><span class="line">            class&#x3D;&quot;img-thumbnail&quot;&gt;</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &#123;&#123;&#x2F;each&#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>最新评论组件（comments.handlebars）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; views&#x2F;partials&#x2F;comments.handlebars</span><br><span class="line">&lt;div class&#x3D;&quot;panel panel-default&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;panel-heading&quot;&gt;</span><br><span class="line">    &lt;h3 class&#x3D;&quot;panel-title&quot;&gt;最新评论&lt;&#x2F;h3&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;panel-body&quot;&gt;</span><br><span class="line">    &lt;ul class&#x3D;&quot;media-list&quot;&gt;</span><br><span class="line">      &#123;&#123;#each sidebar.comments&#125;&#125;</span><br><span class="line">      &lt;li class&#x3D;&quot;media&quot;&gt;</span><br><span class="line">        &lt;a href&#x3D;&quot;&#x2F;images&#x2F;&#123;&#123;image.uniqueId&#125;&#125;&quot; class&#x3D;&quot;pull-left&quot;&gt;</span><br><span class="line">          &lt;img src&#x3D;&quot;&#x2F;public&#x2F;upload&#x2F;&#123;&#123;image.filename&#125;&#125;&quot; class&#x3D;&quot;media-object&quot;</span><br><span class="line">            height&#x3D;&quot;45&quot; width&#x3D;&quot;45&quot;&gt;</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;media-body&quot;&gt;</span><br><span class="line">          &#123;&#123;comment&#125;&#125;&lt;br&#x2F;&gt;</span><br><span class="line">          &lt;strong class&#x3D;&quot;media-heading&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;strong&gt;</span><br><span class="line">          &lt;small class&#x3D;&quot;text-muted&quot;&gt;&#123;&#123;timestamp&#125;&#125;&lt;&#x2F;small&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">      &#123;&#123;&#x2F;each&#125;&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>最后，我们在布局模板 layouts/main.handlebars 中加入所有组件模板，加入模板的语法为 &#123;&#123;&gt; component this&#125;&#125;。除此之外，由于我们用到了一些小图标，所以加上 font-awesome 的链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; views&#x2F;layouts&#x2F;main.handlebars</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Instagrammy&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;link href&#x3D;&quot;http:&#x2F;&#x2F;netdna.bootstrapcdn.com&#x2F;bootstrap&#x2F;3.1.1&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">  &lt;link href&#x3D;&quot;http:&#x2F;&#x2F;netdna.bootstrapcdn.com&#x2F;font-awesome&#x2F;4.0.3&#x2F;css&#x2F;font-awesome.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;page-header&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;col-md-6&quot;&gt;</span><br><span class="line">        &lt;h1&gt;&lt;a href&#x3D;&quot;&#x2F;&quot;&gt;Instagrammy&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;row&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;col-sm-8&quot;&gt;&#123;&#123;&#123;body&#125;&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;col-sm-4&quot;&gt;</span><br><span class="line">        &#123;&#123;&gt; stats this&#125;&#125;</span><br><span class="line">        &#123;&#123;&gt; popular this&#125;&#125;</span><br><span class="line">        &#123;&#123;&gt; comments this&#125;&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="将数据传入模板视图"><a href="#将数据传入模板视图" class="headerlink" title="将数据传入模板视图"></a>将数据传入模板视图</h3><p>如果没有数据传入，那么模板相应的数据部分将全都是空白。在这一步中，我们将用一些假数据来演示如何从控制器将数据传入模板视图。</p><p>首先在 home 控制器中构造一个 viewModel 对象，并在 render 函数中作为第二参数传入。可以看到 viewModel 对象与模板中的数据接口是完全一致的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; controllers&#x2F;home.js</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  index: function(req, res) &#123;</span><br><span class="line">    const viewModel &#x3D; &#123;</span><br><span class="line">      images: [</span><br><span class="line">        &#123;</span><br><span class="line">          uniqueId: 1,</span><br><span class="line">          title: &#39;示例图片1&#39;,</span><br><span class="line">          description: &#39;&#39;,</span><br><span class="line">          filename: &#39;sample1.jpg&#39;,</span><br><span class="line">          views: 0,</span><br><span class="line">          likes: 0,</span><br><span class="line">          timestamp: Date.now(),</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          uniqueId: 2,</span><br><span class="line">          title: &#39;示例图片2&#39;,</span><br><span class="line">          description: &#39;&#39;,</span><br><span class="line">          filename: &#39;sample2.jpg&#39;,</span><br><span class="line">          views: 0,</span><br><span class="line">          likes: 0,</span><br><span class="line">          timestamp: Date.now(),</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          uniqueId: 3,</span><br><span class="line">          title: &#39;示例图片3&#39;,</span><br><span class="line">          description: &#39;&#39;,</span><br><span class="line">          filename: &#39;sample3.jpg&#39;,</span><br><span class="line">          views: 0,</span><br><span class="line">          likes: 0,</span><br><span class="line">          timestamp: Date.now(),</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;;</span><br><span class="line">    res.render(&#39;index&#39;, viewModel);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; controllers&#x2F;image.js</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  index: function(req, res) &#123;</span><br><span class="line">    const viewModel &#x3D; &#123;</span><br><span class="line">      image: &#123;</span><br><span class="line">        uniqueId: 1,</span><br><span class="line">        title: &#39;示例图片1&#39;,</span><br><span class="line">        description: &#39;这是张测试图片&#39;,</span><br><span class="line">        filename: &#39;sample1.jpg&#39;,</span><br><span class="line">        views: 0,</span><br><span class="line">        likes: 0,</span><br><span class="line">        timestamp: Date.now(),</span><br><span class="line">      &#125;,</span><br><span class="line">      comments: [</span><br><span class="line">        &#123;</span><br><span class="line">          image_id: 1,</span><br><span class="line">          email: &#39;test@testing.com&#39;,</span><br><span class="line">          name: &#39;Test Tester&#39;,</span><br><span class="line">          comment: &#39;Test 1&#39;,</span><br><span class="line">          timestamp: Date.now(),</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          image_id: 1,</span><br><span class="line">          email: &#39;test@testing.com&#39;,</span><br><span class="line">          name: &#39;Test Tester&#39;,</span><br><span class="line">          comment: &#39;Test 2&#39;,</span><br><span class="line">          timestamp: Date.now(),</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;;</span><br><span class="line">    res.render(&#39;image&#39;, viewModel);</span><br><span class="line">  &#125;,</span><br><span class="line">  create: function(req, res) &#123;</span><br><span class="line">    res.send(&#39;The image:create POST controller&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  like: function(req, res) &#123;</span><br><span class="line">    res.send(&#39;The image:like POST controller&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  comment: function(req, res) &#123;</span><br><span class="line">    res.send(&#39;The image:comment POST controller&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在传入数据时，我们可以自定义一些 helper 函数在模板中使用。例如 timestamp 时间戳，Date.now() 返回的是一串数字，显然用户体验很不友好，因此我们需要将其转换为方便用户阅读的时间，例如 “几秒前”“两小时前”。这里我们选用 JavaScript 最流行的处理时间的库 moment.js，并通过 npm 安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i moment</span><br></pre></td></tr></table></figure><p>然后在 server/configure.js 中配置 handlebars 的 helper 函数 timeago：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; server&#x2F;configure.js</span><br><span class="line"></span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const exphbs &#x3D; require(&#39;express-handlebars&#39;);</span><br><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const bodyParser &#x3D; require(&#39;body-parser&#39;);</span><br><span class="line">const cookieParser &#x3D; require(&#39;cookie-parser&#39;);</span><br><span class="line">const morgan &#x3D; require(&#39;morgan&#39;);</span><br><span class="line">const methodOverride &#x3D; require(&#39;method-override&#39;);</span><br><span class="line">const errorHandler &#x3D; require(&#39;errorhandler&#39;);</span><br><span class="line">const moment &#x3D; require(&#39;moment&#39;);</span><br><span class="line"></span><br><span class="line">const routes &#x3D; require(&#39;.&#x2F;routes&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; function(app) &#123;</span><br><span class="line">  &#x2F;&#x2F; 定义 moment 全局语言</span><br><span class="line">  moment.locale(&#39;zh-cn&#39;);</span><br><span class="line"></span><br><span class="line">  app.engine(</span><br><span class="line">    &#39;handlebars&#39;,</span><br><span class="line">    exphbs.create(&#123;</span><br><span class="line">      helpers: &#123;</span><br><span class="line">        timeago: function(timestamp) &#123;</span><br><span class="line">          return moment(timestamp).startOf(&#39;minute&#39;).fromNow();</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;).engine,</span><br><span class="line">  );</span><br><span class="line">  app.set(&#39;view engine&#39;, &#39;handlebars&#39;);</span><br><span class="line"></span><br><span class="line">  app.use(morgan(&#39;dev&#39;));</span><br><span class="line">  app.use(bodyParser.urlencoded(&#123; extended: true &#125;));</span><br><span class="line">  app.use(bodyParser.json());</span><br><span class="line">  app.use(methodOverride());</span><br><span class="line">  app.use(cookieParser(&#39;secret-value&#39;));</span><br><span class="line">  app.use(&#39;&#x2F;public&#x2F;&#39;, express.static(path.join(__dirname, &#39;..&#x2F;public&#39;)));</span><br><span class="line"></span><br><span class="line">  if (app.get(&#39;env&#39;) &#x3D;&#x3D;&#x3D; &#39;development&#39;) &#123;</span><br><span class="line">    app.use(errorHandler());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  routes(app);</span><br><span class="line">  return app;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着在相应用到时间戳的地方加入 timeago 函数：</p><p>views/image.handlebars<br><img src="https://img.brookliu.xyz/blog/express%2BmongoDB-1-2.png" alt="timeago1"></p><p><img src="https://img.brookliu.xyz/blog/express%2BmongoDB-1-3.png" alt="timeago2"></p><p>views/partials/comments.handlebars<br><img src="https://img.brookliu.xyz/blog/express%2BmongoDB-1-4.png" alt="timeago3"></p><p>到这里我们实现了项目的视图和控制器完成了第一部分，下一部分我们来接入MongoDB数据库实现图片上传、点赞、删除、评论等功能。</p><p>原文地址<a href="https://tuture.co/2019/10/16/a0531f0/" target="_blank" rel="noopener">图灵社区</a>。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;初始化项目结构&quot;&gt;&lt;a href=&quot;#初始化项目结构&quot; class=&quot;headerlink&quot; title=&quot;初始化项目结构&quot;&gt;&lt;/a&gt;初始化项目结构&lt;/h3&gt;&lt;p&gt;首先创建目录，并初始化(如果你想放在GitHub上的话，先在GitHub上建一个仓库然后clone下来)：&lt;br&gt;初始化的时候可以一路enter下来，如果你不在意的话。&lt;/p&gt;</summary>
    
    
    
    <category term="Node" scheme="https://github.com/liubrook/liubrook.github.io/categories/Node/"/>
    
    
    <category term="Node" scheme="https://github.com/liubrook/liubrook.github.io/tags/Node/"/>
    
    <category term="Express" scheme="https://github.com/liubrook/liubrook.github.io/tags/Express/"/>
    
    <category term="MongoDB" scheme="https://github.com/liubrook/liubrook.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Hexo写作样式简介</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2020/10/09/Hexo%E5%86%99%E4%BD%9C%E6%A0%B7%E5%BC%8F%E7%AE%80%E4%BB%8B/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2020/10/09/Hexo%E5%86%99%E4%BD%9C%E6%A0%B7%E5%BC%8F%E7%AE%80%E4%BB%8B/</id>
    <published>2020-10-09T06:58:58.000Z</published>
    <updated>2020-10-09T07:08:37.527Z</updated>
    
    <content type="html"><![CDATA[<h4 id="note标签"><a href="#note标签" class="headerlink" title="note标签"></a>note标签</h4><a id="more"></a> <p>修改主题配置文件_config.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  style: flat</span><br><span class="line">  icons: true</span><br><span class="line">  border_radius: 3</span><br><span class="line">  light_bg_offset: 0</span><br></pre></td></tr></table></figure><div class="note default"><p>default</p></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;note default&quot;&gt;&lt;p&gt;default&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><div class="note primary"><p>primary</p></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;note primary&quot;&gt;&lt;p&gt;primary&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><div class="note success"><p>success</p></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;note success&quot;&gt;&lt;p&gt;success&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><div class="note info"><p>info</p></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;note info&quot;&gt;&lt;p&gt;info&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><div class="note warning"><p>warning</p></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;note warning&quot;&gt;&lt;p&gt;warning&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><div class="note danger"><p>danger</p></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;note danger&quot;&gt;&lt;p&gt;danger&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h4 id="tabs标签"><a href="#tabs标签" class="headerlink" title="tabs标签"></a>tabs标签</h4><div class="tabs" id="选项卡"><ul class="nav-tabs"><li class="tab"><a href="#选项卡-1">选项卡 1</a></li><li class="tab"><a href="#选项卡-2">选项卡 2</a></li><li class="tab active"><a href="#选项卡-3">选项卡 3</a></li></ul><div class="tab-content"><div class="tab-pane" id="选项卡-1"><p><strong>选项卡 1</strong></p></div><div class="tab-pane" id="选项卡-2"><p><strong>选项卡 2</strong></p></div><div class="tab-pane active" id="选项卡-3"><p><strong>这是选项卡 3</strong></p><p>上面的，3表示打开页面时，默认展示第三个选项卡</p></div></div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs 选项卡, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**选项卡 1**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**选项卡 2**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**这是选项卡 3**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><h4 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h4><ol><li><i class="fa fa-camera"></i> 照相机</li><li><i class="fa fa-battery-4"></i> 电池</li></ol><p>hexo 使用的是<a href="http://www.fontawesome.com.cn/icons-ui/" target="_blank" rel="noopener">fontawesome</a>图标，直接引用就可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. &lt;i class&#x3D;&quot;fa fa-camera&quot;&gt;&lt;&#x2F;i&gt; 照相机</span><br><span class="line">2. &lt;i class&#x3D;&quot;fa fa-battery-4&quot;&gt;&lt;&#x2F;i&gt; 电池</span><br></pre></td></tr></table></figure><h4 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h4><a class="btn" href="https://www.google.com" target="_blank" rel="noopener"><i class="fa fa-google fa-fw"></i>google一下</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btn https:&#x2F;&#x2F;www.google.com, google一下,  google fa-fw %&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;note标签&quot;&gt;&lt;a href=&quot;#note标签&quot; class=&quot;headerlink&quot; title=&quot;note标签&quot;&gt;&lt;/a&gt;note标签&lt;/h4&gt;</summary>
    
    
    
    <category term="hexo" scheme="https://github.com/liubrook/liubrook.github.io/categories/hexo/"/>
    
    
    <category term="hexo" scheme="https://github.com/liubrook/liubrook.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Docker简单上手03</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2020/10/09/Docker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B03/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2020/10/09/Docker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B03/</id>
    <published>2020-10-09T02:58:00.000Z</published>
    <updated>2020-10-09T06:33:17.788Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在<a href="https://brookliu.xyz/2020/10/07/Docker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B01/#more" target="_blank" rel="noopener">Docker简单上手01</a>中我们一起学习了Docker的容器化。</p><p>在<a href="https://brookliu.xyz/2020/10/08/Docker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B02/" target="_blank" rel="noopener">Docker简单上手02</a>中我们一起学习了不同容器通过Docker网络实现相互之间的通信。</p><a id="more"></a> <h3 id="Docker数据管理"><a href="#Docker数据管理" class="headerlink" title="Docker数据管理"></a>Docker数据管理</h3><p>今天我们一起学习上手Docker数据管理。Docker数据的管理方式主要分为三种：</p><ul><li>数据卷(Volume)，也是最为推荐的一种方式。</li><li>绑定挂载(Bind Mount)，Docker早期常用的数据管理方式。</li><li>tmpfs挂载。基于内存的数据管理。</li></ul><div class="note info"><p>注意</p><a href="https://docs.docker.com/storage/tmpfs/" target="_blank" rel="noopener">tmpfs挂载</a>只适用于Linux操作系统。</div><h4 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h4><h5 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h5><p>数据卷（Volume）也是常见的 Docker 对象类型的一种，因此也支持 create（创建）、inspect （查看详情）、ls （列出所有数据卷）、prune （删除无用数据卷）和 rm（删除）等操作。<br>首先创建一个数据卷：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create my-volume</span><br></pre></td></tr></table></figure><p>查看当前所有的数据卷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure><p>可以看到输出的信息最后一条</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local               my-volume</span><br></pre></td></tr></table></figure><p>然后我们输入命令查看my-volume数据卷的详细情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect my-volume</span><br></pre></td></tr></table></figure><p>可以看到输出了下面的信息：<br><img src="https://img.brookliu.xyz/blog/docker-3-1.png" alt="my-volume信息"></p><p>最后我们删除刚才创建的my-volume数据卷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm my-volume</span><br></pre></td></tr></table></figure><p><img src="https://static.tuture.co/c/442cc8d/170b032e4bd0e059.png" alt="数据卷"><br>从上图我们可以看到，数据卷在 “主机环境” 和 “容器环境” 之间架起了 “一道桥梁”。通常，我们在容器中将需要存储的数据写入数据卷所挂载的路径（位置），然后就会立即、自动地将这些数据存储到主机对应的区域。</p><h5 id="创建数据卷的方式"><a href="#创建数据卷的方式" class="headerlink" title="创建数据卷的方式"></a>创建数据卷的方式</h5><p>在创建带有数据卷的容器时，通常有两种选择：1）命名卷（Named Volume）；2）匿名卷（Anonymous Volume）。接下来我们就分别详细讲解。</p><h6 id="创建命名卷"><a href="#创建命名卷" class="headerlink" title="创建命名卷"></a>创建命名卷</h6><p>运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rum -it -v my:vol:&#x2F;data --name container1 alpine</span><br></pre></td></tr></table></figure><p>可以看到，我们通过 -v （或者 –volume ）参数指定了数据卷的配置为 my-vol:/data ，其中（你应该猜到了）my-vol 就是数据卷的名称，/data 就是容器中数据卷的路径。</p><p>在进入容器后，向/data目录中添加一个文件后退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch &#x2F;data&#x2F;file.txt</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>为了验证 /data 中的数据是否真的保存下来，我们删除 container1 容器，然后再创建一个新的容器 container2 ，查看其中的 /data 目录内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker rm container1</span><br><span class="line"></span><br><span class="line">docker run -it -v my-vol:&#x2F;data --name container2 alpine</span><br><span class="line"></span><br><span class="line">ls &#x2F;data</span><br><span class="line">&#x2F;&#x2F; 这里可以看到会输出</span><br><span class="line">file.txt</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>可以看到刚刚在 container1 中创建的 file.txt 文件！事实上，这种在容器之间共享数据卷的模式非常常见，Docker 提供了一个方便的参数 –volumes-from 来轻松实现数据卷共享：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v --volumes-from container2 --name container3 alpine</span><br><span class="line"></span><br><span class="line">ls &#x2F;data</span><br><span class="line">file.txt</span><br></pre></td></tr></table></figure><p>同样，container3 中也能访问到数据卷中的内容。</p><h6 id="创建匿名卷"><a href="#创建匿名卷" class="headerlink" title="创建匿名卷"></a>创建匿名卷</h6><p>创建匿名卷的方式就很简单了，之前我们通过 my-vol:/data 作为 -v 的参数，而创建匿名卷只需省略数据卷名称（my-vol 即可）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v &#x2F;data --name container4 alpine</span><br></pre></td></tr></table></figure><p>输入以下命令查看container4的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect container4</span><br></pre></td></tr></table></figure><p><img src="https://img.brookliu.xyz/blog/docker-3-2.png" alt="container4"></p><p>看一下Mount中的一些重要字段：</p><ul><li>Name 即数据卷的名称，由于是匿名卷，所以 Name 字段就是一串长长的随机数，命名卷则为指定的名称。</li><li>Source 为数据卷在主机文件系统中的存储路径（之前说了，Windows 和 Mac 在 Docker 虚拟机中）。</li><li>Destination 为数据卷在容器中的挂载点。</li><li>RW 指可读写（Read-Write），如果为 false ，则为只读数据卷。</li></ul><h5 id="在-Dockerfile-中使用数据卷"><a href="#在-Dockerfile-中使用数据卷" class="headerlink" title="在 Dockerfile 中使用数据卷"></a>在 Dockerfile 中使用数据卷</h5><p>在 Dockerfile 中使用数据卷非常简单，只需通过 VOLUME 关键词指定数据卷就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VOLUME &#x2F;data</span><br><span class="line"></span><br><span class="line"># 或者通过 JSON 数组的方式指定多个数据卷</span><br><span class="line">VOLUME [&quot;&#x2F;data1&quot;, &quot;&#x2F;data2&quot;, &quot;&#x2F;data3&quot;]</span><br></pre></td></tr></table></figure><div class="note warning"><p>注意</p><p>只能创建匿名卷</p><p>当通过docker run -v指定数据卷时，Dockerfile中的配置会被覆盖</p></div><h4 id="绑定挂载"><a href="#绑定挂载" class="headerlink" title="绑定挂载"></a>绑定挂载</h4><p>绑定挂载（Bind Mount）是出现最早的 Docker 数据管理和存储解决方案，它的大致思路和数据卷是一致的，只不过是直接建立本机文件系统和容器文件系统之间的映射关系，非常适合简单、灵活地在本机和容器之间传递数据。</p><p>我们可以试着把自己机器的桌面（或者其他路径）挂载到容器中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm -v ~&#x2F;Desktop:&#x2F;desktop alpine</span><br></pre></td></tr></table></figure><p>我们还是通过 -v 参数来进行配置，<del>/Desktop 是本机文件系统路径，/desktop 则是容器中的路径，</del>/Desktop:/desktop 则是将本机路径和容器路径进行绑定，仿佛架起了一道桥梁。这里的 –rm 选项是指在容器停止之后自动删除。</p><p>进入到容器之后，可以试试看 /desktop 下面有没有自己桌面上的东西，然后再在容器中创建一个文件，看看桌面上有没有收到这个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;# ls &#x2F;desktop</span><br><span class="line"></span><br><span class="line">&#x2F;# touch &#x2F;desktop&#x2F;from-container.txt</span><br></pre></td></tr></table></figure><p>你应该能看到自己的桌面上多了容器中创建的 from-container.txt 文件！</p><h3 id="动手实战"><a href="#动手实战" class="headerlink" title="动手实战"></a>动手实战</h3><p>上面我们熟悉了Docker数据管理的两种方式，说不如练，下面我们直接动手演示。</p><h4 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone -b volume-start https:&#x2F;&#x2F;github.com&#x2F;tuture-dev&#x2F;docker-dream.git</span><br><span class="line">cd docker-dream</span><br></pre></td></tr></table></figure><p>实战内容：</p><ul><li>存储和备份 Express 服务器输出的日志数据，而不是存储在” 朝生暮死 “的容器中。</li><li>MongoDB 镜像已经做了数据卷配置，所以我们只需实践一波怎么备份和恢复数据。</li></ul><h4 id="为-Express-服务器挂载数据卷"><a href="#为-Express-服务器挂载数据卷" class="headerlink" title="为 Express 服务器挂载数据卷"></a>为 Express 服务器挂载数据卷</h4><p>我们首先在 server/Dockerfile 中添加 VOLUME 配置，并且指定 LOG_PATH （日志输出路径环境变量，可参考 server/index.js 的源码）为 /var/log/server/access.log，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FROM node:10</span><br><span class="line"></span><br><span class="line"># 指定工作目录为 &#x2F;usr&#x2F;src&#x2F;app，接下来的命令全部在这个目录下操作</span><br><span class="line">WORKDIR &#x2F;usr&#x2F;src&#x2F;app</span><br><span class="line"></span><br><span class="line">VOLUME &#x2F;var&#x2F;log&#x2F;server</span><br><span class="line"></span><br><span class="line"># 将 package.json 拷贝到工作目录</span><br><span class="line">COPY package.json .</span><br><span class="line"></span><br><span class="line"># 安装 npm 依赖</span><br><span class="line">RUN npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line"># 拷贝源代码</span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line"># 设置环境变量（服务器的主机 IP 和端口）</span><br><span class="line">ENV MONGO_URI&#x3D;mongodb:&#x2F;&#x2F;dream-db:27017&#x2F;todos</span><br><span class="line">ENV HOST&#x3D;0.0.0.0</span><br><span class="line">ENV PORT&#x3D;4000</span><br><span class="line">ENV LOG_PATH&#x3D;&#x2F;var&#x2F;log&#x2F;server&#x2F;access.log</span><br><span class="line"></span><br><span class="line"># 开放 4000 端口</span><br><span class="line">EXPOSE 4000</span><br><span class="line"></span><br><span class="line"># 设置镜像运行命令</span><br><span class="line">CMD [ &quot;node&quot;, &quot;index.js&quot; ]</span><br></pre></td></tr></table></figure><p>然后 build 服务器镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t dream-server server&#x2F;</span><br></pre></td></tr></table></figure><p>现在我们把整个项目走起来，也就是进来前两篇文章的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 创建网络，便于容器互联</span><br><span class="line">docker network create dream-net</span><br><span class="line"></span><br><span class="line"># 启动 MongoDB 容器（dream-db）</span><br><span class="line">docker run --name dream-db --network dream-net -d mongo</span><br><span class="line"></span><br><span class="line"># 启动 Express API 容器（dream-api）</span><br><span class="line">docker run -p 4000:4000 --name dream-api --network dream-net -d dream-server</span><br><span class="line"></span><br><span class="line"># 构建提供 React 前端页面的 Nginx 服务器</span><br><span class="line">docker build -t dream-client client</span><br><span class="line"></span><br><span class="line"># 启动 Nginx 服务器容器（client）</span><br><span class="line">docker run -p 8080:80 --name client -d dream-client</span><br></pre></td></tr></table></figure><p>项目起来之后我们<code>docker ps</code>确保三个容器都已经开启:<br><img src="https://img.brookliu.xyz/blog/docker-3-3.png" alt="容器开启"></p><p>然后访问localhost:8080(服务器域名:8080)</p><h4 id="日志数据的备份"><a href="#日志数据的备份" class="headerlink" title="日志数据的备份"></a>日志数据的备份</h4><p>创建一个新的临时容器，通过共享数据卷的方式来备份数据。</p><ul><li><p>实现 dream-api 容器和数据卷之间的数据共享（已实现）。</p></li><li><p>创建临时容器，获取 dream-api 的数据卷。运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --volumes-from dream-api -v $(pwd):&#x2F;backup alpine</span><br></pre></td></tr></table></figure><div class="note info"><p>上面这句命令同时用到了上面讲解的数据卷和绑定挂载：</p><p>--volumes-from dream-api 用于容器之间共享数据卷，这里我们获取 dream-api 的数据卷</p><p>-v $(pwd):/backup 用于建立当前本机文件路径（pwd 命令获取）和临时容器内 /backup 路径的绑定挂载</p></div><ul><li>进入临时容器之后，我们把日志数据压缩成 tar 包放到 /backup 目录下，然后退出：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; # tar cvf &#x2F;backup&#x2F;backup.tar &#x2F;var&#x2F;log&#x2F;server&#x2F;</span><br><span class="line">tar: removing leading &#39;&#x2F;&#39; from member names</span><br><span class="line">var&#x2F;log&#x2F;server&#x2F;</span><br><span class="line">var&#x2F;log&#x2F;server&#x2F;access.log</span><br><span class="line">&#x2F; # exit</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>退出之后用下面的命令在当前目录查看日志的备份backup.tar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --volumes-from dream-api -v $(pwd):&#x2F;backup alpine tar cvf &#x2F;backup&#x2F;backup.tar &#x2F;var&#x2F;log&#x2F;server</span><br></pre></td></tr></table></figure><h4 id="数据库备份与恢复"><a href="#数据库备份与恢复" class="headerlink" title="数据库备份与恢复"></a>数据库备份与恢复</h4> <div class="note info"><p>提示</p><p>我们这里使用 MongoDB 自带的备份与恢复命令（mongodump 与 mongorestore ），其他数据库（例如 MySQL）也有类似的命令，都可以借鉴本文的方式。</p></div><h5 id="临时容器-容器互联"><a href="#临时容器-容器互联" class="headerlink" title="临时容器 + 容器互联"></a>临时容器 + 容器互联</h5><p>首先，我们的临时容器得连接上 dream-db 容器，并配置好绑定挂载，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm -v $(pwd):&#x2F;backup --network dream-net mongo sh</span><br></pre></td></tr></table></figure><p>和之前备份日志数据相比，我们要把这个临时容器连接到 dream-net 网络中，它才能访问到 dream-db 的数据进行备份。</p><p>第二步，进入到这个临时容器后，运行 mongodump 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; # mongodump -v --host dream-db:27017 --archive --gzip &gt; &#x2F;backup&#x2F;mongo-backup.gz</span><br></pre></td></tr></table></figure><p>此时，由于绑定挂载，输出到 /backup 的文件将保存到当前目录（pwd）中。退出后，就可以在当前目录下看到 mongo-backup.gz 文件了。</p><h5 id="提前做好绑定挂载"><a href="#提前做好绑定挂载" class="headerlink" title="提前做好绑定挂载"></a>提前做好绑定挂载</h5><p>在创建数据库容器的时候，运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name dream-db --network dream-net -v $(pwd):&#x2F;backup -d mongo</span><br></pre></td></tr></table></figure><p>然后再通过 docker exec 执行 mongodump 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec dream-db sh -c &#39;mongodump -v --archive --gzip &gt; &#x2F;backup&#x2F;mongo-backup.gz&#39;</span><br></pre></td></tr></table></figure><p>这样就可以实现创建数据库容器的时候就做好绑定挂载，然后通过 mongodump 把数据备份到挂载区域.这里我们用 sh -c 来执行一整条 Shell 命令（字符串形式），这样避免了重定向符 &gt; 引发的歧义（不理解的话可以把 sh -c ‘xxx’ 替换成 xxx）。可以看到，mongodump 的命令简单了许多，我们再也不需要指定 –host 参数，因为数据库就在本容器内。</p><p><font color="red">但是有个问题：如果已经创建了数据库，并且没有提前做绑定挂载，这种方法就行不通了！</font></p><h2><font color="red">注意，这不是演习！</font></h2><p>有了数据库备份文件，我们就可以肆无忌惮地来做一波” 演习 “了。通过以下命令，直接端了目前的数据库和 API 服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f --volumes dream-db</span><br><span class="line">docker rm -f dream-api</span><br></pre></td></tr></table></figure><p>没错，通过 –volumes 开关，我们不仅把 dream-db 容器删了，还顺带把挂载的数据卷全部删除！演习就是要足够逼真才行。这时候再访问 localhost:8080 ，之前的待办数据全部丢失！</p><p>现在让我们再次创建新的 dream-db 容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name dream-db --network dream-net -v $(pwd):&#x2F;backup -d mongo</span><br></pre></td></tr></table></figure><p>注意到，我们通过绑定挂载的方式把当前目录映射到容器的 /backup 目录，这意味着可以在这个新的容器中通过 /backup/mongo-backup.gz 来恢复数据，运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec dream-db sh -c &#39;mongorestore --archive --gzip &lt; &#x2F;backup&#x2F;mongo-backup.gz&#39;</span><br></pre></td></tr></table></figure><p>我们应该会看到输出了一些日志，提示我们数据恢复成功。最后重新开启 API 服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:4000 --name dream-api --network dream-net -d dream-server</span><br></pre></td></tr></table></figure><p>现在再次访问应用是不是发现数据都找回来了！</p><p>今天的docker上手到这里就结束了，共勉加油！</p><p>教程：<a href="https://tuture.co/2020/03/06/0X8ssR3/" target="_blank" rel="noopener">图灵社区：上手容器数据管理</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在&lt;a href=&quot;https://brookliu.xyz/2020/10/07/Docker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B01/#more&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker简单上手01&lt;/a&gt;中我们一起学习了Docker的容器化。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://brookliu.xyz/2020/10/08/Docker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B02/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker简单上手02&lt;/a&gt;中我们一起学习了不同容器通过Docker网络实现相互之间的通信。&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://github.com/liubrook/liubrook.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://github.com/liubrook/liubrook.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker简单上手02</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2020/10/08/Docker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B02/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2020/10/08/Docker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B02/</id>
    <published>2020-10-08T02:48:11.000Z</published>
    <updated>2020-10-09T02:54:10.353Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在<a href="https://brookliu.xyz/2020/10/07/Docker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B01/#more" target="_blank" rel="noopener">Docker简单上手01</a>中我们熟悉了常用的docker命令，并成功地容器化了第一个应用。这篇文章我们将实现后端API服务器+数据库的容器化。</p><a id="more"></a> <h3 id="熟悉流程"><a href="#熟悉流程" class="headerlink" title="熟悉流程"></a>熟悉流程</h3><p>下面我们就开始今天的内容学习：</p><h4 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 如果你看了上一篇教程，仓库已经克隆下来了</span><br><span class="line">cd docker-dream</span><br><span class="line">git fetch origin network-start</span><br><span class="line">git checkout network-start</span><br><span class="line"></span><br><span class="line"># 如果你打算直接从这篇教程开始</span><br><span class="line">git clone -b network-start https:&#x2F;&#x2F;github.com&#x2F;tuture-dev&#x2F;docker-dream.git</span><br><span class="line">cd docker-dream</span><br></pre></td></tr></table></figure><div class="note info"><p>提示</p>我直接用的上一篇文章中下载的项目但是在后面容器化的时候一直无法成功，后来发现是上一篇下载的项目和这一篇的不一样，建议直接重新克隆下载项目。</div><p>和之前容器化前端静态页面服务器相比，多了一个难点：服务器和数据库分别是两个独立的容器，但是服务器需要连接和访问数据库，怎么实现跨容器之间的通信？</p><h4 id="Network-类型"><a href="#Network-类型" class="headerlink" title="Network 类型"></a>Network 类型</h4><p>Network，顾名思义就是 “网络”，能够让不同的容器之间相互通信。首先有必要要列举一下 Docker Network 的五种驱动模式（driver）：</p><ul><li>bridge：默认的驱动模式，即 “网桥”，通常用于单机（更准确地说，是单个 Docker 守护进程）。</li><li>overlay：Overlay 网络能够连接多个 Docker 守护进程，通常用于集群，后续讲 Docker Swarm 的文章会重点讲解。</li><li>host：直接使用主机（也就是运行 Docker 的机器）网络，仅适用于 Docker 17.06+ 的集群服务。</li><li>macvlan：Macvlan 网络通过为每个容器分配一个 MAC 地址，使其能够被显示为一台物理设备，适用于希望直连到物理网络的应用程序（例如嵌入式系统、物联网等等）。</li><li>none：禁用此容器的所有网络。</li></ul><p>我们今天将围绕着默认的Bridge网络驱动展开。</p><h4 id="网络准备"><a href="#网络准备" class="headerlink" title="网络准备"></a>网络准备</h4><p>只是这么介绍的话我们还是无法理解，所以我们需要动手试一下来理解和感受Bridge Network。我们来用<a href="https://www.alpinelinux.org/" target="_blank" rel="noopener">Alpine Linux</a>镜像体验下。</p><p>网桥网络分为两类：</p><ul><li>默认网络(Docker运行时自带，不推荐用于生产环境)。</li><li>自定义网络(推荐使用)。</li></ul><h4 id="默认网络"><a href="#默认网络" class="headerlink" title="默认网络"></a>默认网络</h4><p>我们会在默认的 bridge 网络上连接两个容器 alpine1 和 alpine2。 运行以下命令，查看当前已有的网络：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure><p>应该会看到以下输出（注意你机器上的 ID 很有可能不一样）：<br><img src="https://img.brookliu.xyz/blog/docker-2-1.png" alt="网络输出图"></p><p>这三个默认网络分别对应上面的 bridge、host 和 none 网络类型。接下来我们将创建两个容器，分别名为 alpine1 和 alpine2，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --name alpine1 alpine</span><br><span class="line">docker run -dit --name alpine2 alpine</span><br></pre></td></tr></table></figure><p>-dit 是 -d（后台模式）、-i（交互模式）和 -t（虚拟终端）三个选项的合并。通过这个组合，我们可以让容器保持在后台运行而不会退出（没错，相当于是在 “空转”）。</p><p>用 <code>docker ps</code>命令确定以上两个容器均在后台运行：<br><img src="https://img.brookliu.xyz/blog/docker-2-2.png" alt="网络输出图2"></p><p>通过以下命令查看默认的 bridge 网络的详情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure><p>应该会输出 JSON 格式的网络详细数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;4741cab870f168d59a3b5eb1d67251d177dd3af14b8cccc39c130a3f0ec5e3a0&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2020-10-07T11:18:54.983568882+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.17.0.0&#x2F;16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;1af67ce67ec14f57199a6b4e9183330e017014ad33cad0f783b4a3ab9e763bd0&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;client&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;1b800afa81ba8e7d15c806c349166c5f24619d71710825860f4d4eef706badf8&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.2&#x2F;16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;27783577c5b621ff8d2dfdc2982bad4635ac093ed261aa4f4189788f8efe0807&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;alpine2&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;8539c75c6cc44dceb143aac1936e215e2f80f6b6a412c6f10b33722c4f9cf74b&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:04&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.4&#x2F;16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;e7a69f15fa39cdd2434dac9ec9e84f7d7b133f062dfe110cfcde297546830043&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;alpine1&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;0c0310de6ec103386a9485166b54826efa574aa6b3da7996c16385f1d0bb16c5&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.3&#x2F;16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;,</span><br><span class="line">            &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在这一大串信息里我们重点要关注的是两个字段：</p><ul><li>IPAM：IP 地址管理信息（IP Address Management），可以看到网关地址为 172.17.0.1（由于篇幅有限，想要了解网关的同学可自行查阅计算机网络以及 TCP/IP 协议方面的资料）。</li><li>Containers：包括此网络上连接的所有容器，可以看到我们刚刚创建的 alpine1 和 alpine2，它们的 IP 地址分别为 172.17.0.3 和 172.17.0.4（后面的 /16 是子网掩码，暂时不用考虑）。</li></ul><p>进入 alpine1 容器中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach alpine1</span><br></pre></td></tr></table></figure><blockquote><p>attach 命令只能进入设置了交互式运行的容器（也就是在启动时加了 -i 参数）。</p></blockquote><p>如果你看到前面的命令提示符变成 / #，说明我们已经身处容器之中了。我们通过 ping 命令测试一下网络连接情况，首先 ping 一下百度 baidu.com（-c 参数代表发送数据包的数量，这里我们设为 5）：<br><img src="https://img.brookliu.xyz/blog/docker-2-3.png" alt="ping百度"></p><p>看上图，全部都连上了没有丢包(这个取决于你的网络环境)。由此可见，容器内可以访问主机所连接的全部网络（包括 localhost）。</p><p>接下来测试能否连接到 alpine2，在刚才 docker network inspect 命令的输出中找到 alpine2 的 IP 为 172.17.0.3，尝试能否 ping 通：<br><img src="https://img.brookliu.xyz/blog/docker-2-4.png" alt="ping2"><br>完美！我们能够从 alpine1 中访问 alpine2 容器。作为练习，你可以自己尝试一下能否从 alpine2 容器中 ping 通 alpine1 哦。</p><blockquote><p>如果你不想让 alpine1 停下来，记得通过 Ctrl + P + Ctrl + Q（按住 Ctrl，然后依次按 P 和 Q 键）“脱离”（detach，也就是刚才 attach 命令的反义词）容器，而不是按 Ctrl + D 哦。</p></blockquote><h4 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h4><p>默认的 bridge 网络存在一个很大的问题：只能通过 IP 地址相互访问。这毫无疑问是非常麻烦的，当容器数量很多的时候难以管理，而且每次的 IP 都可能发生变化。</p><p>而自定义网络则很好地解决了这一问题。在同一个自定义网络中，每个容器能够通过彼此的名称相互通信，因为 Docker 为我们搞定了 DNS 解析工作，这种机制被称为服务发现（Service Discovery）。具体而言，我们将创建一个自定义网络 my-net，并创建 alpine3 和 alpine4 两个容器，连上 my-net。<br>首先创建自定义网络 my-net：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker network create my-net</span><br><span class="line"># 由于默认网络驱动为 bridge，因此相当于以下命令</span><br><span class="line"># docker network create --driver bridge my-net</span><br></pre></td></tr></table></figure><p>查看当前所有的网络：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure><p>可以看到刚刚创建的 my-net：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">4741cab870f1        bridge              bridge              local</span><br><span class="line">a5ccbe18d2ab        host                host                local</span><br><span class="line">5d8856725e7f        my-net              bridge              local</span><br><span class="line">a18954d078b5        none                null                local</span><br></pre></td></tr></table></figure><p>创建两个新的容器 alpine3 和 alpine4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --name alpine3 --network my-net alpine</span><br><span class="line">docker run -dit --name alpine4 --network my-net alpine</span><br></pre></td></tr></table></figure><p>通过 –network 参数指定容器想要连接的网络（也就是刚才创建的 my-net）。</p><blockquote><p>如果在一开始创建并运行容器时忘记指定网络，那么下次再想指定网络时，可以通过 docker network connect 命令再次连上（第一个参数是网络名称 my-net，第二个是需要连接的容器 alpine3）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect my-net alpine3</span><br></pre></td></tr></table></figure></blockquote><p>进入到 alpine3 中，测试能否 ping 通 alpine4：<br><img src="https://img.brookliu.xyz/blog/docker-2-5.png" alt="ping"></p><p>可以看到 alpine4 被自动解析成了 172.18.0.3。我们可以通过 docker network inspect 来验证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect --format &#39;&#123;&#123;range .Containers&#125;&#125;&#123;&#123;.Name&#125;&#125;: &#123;&#123;.IPv4Address&#125;&#125; &#123;&#123;end&#125;&#125;&#39; my-net</span><br></pre></td></tr></table></figure><h4 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h4><p>通过上面的例子我们明白了默认和自定义网络的一个大致流程，现在可以结束之前创建的容器的使命了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f alpine1 alpine2 alpine3 alpine4</span><br></pre></td></tr></table></figure><p>把创建的 my-net 也删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network rm my-net</span><br></pre></td></tr></table></figure><h3 id="动手实践"><a href="#动手实践" class="headerlink" title="动手实践"></a>动手实践</h3><p>下面我们来正式的进行今天的主题内容:</p><h4 id="容器化服务器"><a href="#容器化服务器" class="headerlink" title="容器化服务器"></a>容器化服务器</h4><p>我们首先对后端服务器也进行容器化。创建 server/Dockerfile，代码如下：<br><font color="blue">注意是在docker-dream目录下哦</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FROM node:10</span><br><span class="line"></span><br><span class="line"># 指定工作目录为 &#x2F;usr&#x2F;src&#x2F;app，接下来的命令全部在这个目录下操作</span><br><span class="line">WORKDIR &#x2F;usr&#x2F;src&#x2F;app</span><br><span class="line"></span><br><span class="line"># 将 package.json 拷贝到工作目录</span><br><span class="line">COPY package.json .</span><br><span class="line"></span><br><span class="line"># 安装 npm 依赖</span><br><span class="line">RUN npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line"># 拷贝源代码</span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line"># 设置环境变量（服务器的主机 IP 和端口）</span><br><span class="line">ENV MONGO_URI&#x3D;mongodb:&#x2F;&#x2F;dream-db:27017&#x2F;todos</span><br><span class="line">ENV HOST&#x3D;0.0.0.0</span><br><span class="line">ENV PORT&#x3D;4000</span><br><span class="line"></span><br><span class="line"># 开放 4000 端口</span><br><span class="line">EXPOSE 4000</span><br><span class="line"></span><br><span class="line"># 设置镜像运行命令</span><br><span class="line">CMD [ &quot;node&quot;, &quot;index.js&quot; ]</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以发现这次的Dockerfile比[上一篇教程]中的要复杂不少。每一行的含义已经注释在代码中了，我们看下多了哪些新东西：</p><ul><li>RUN 指令用于在容器中运行任何命令，这里我们通过 npm install 安装所有项目依赖（当然之前配置了一下 npm 镜像，可以安装得快一点）。</li><li>ENV 指令用于向容器中注入环境变量，这里我们设置了 数据库的连接字符串 MONGO_URI（注意这里给数据库取名为 <strong>dream-db</strong>，后面就会创建这个容器），还配置了服务器的 HOST 和 PORT。</li><li>EXPOSE 指令用于开放端口 4000。之前在用 Nginx 容器化前端项目时没有指定，是因为 Nginx 基础镜像已经开放了 8080 端口，无需我们设置；而这里用的 Node 基础镜像则没有开放，需要我们自己去配置。</li><li>CMD 指令用于指定此容器的启动命令（也就是 docker ps 查看时的 COMMAND 一列），对于服务器来说当然就是保持运行状态。</li></ul><div class="note warning"><p>注意</p>初次尝试容器的朋友很容易犯的一个错误就是忘记将服务器的 host 从 localhost（127.0.0.1）改成 0.0.0.0，导致服务器无法在容器之外被访问到。</div><p>与之前前端容器化类似，创建 server/.dockerignore 文件，忽略服务器日志 access.log 和 node_modules，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">access.log</span><br></pre></td></tr></table></figure><p>然后项目根目录下运行以下命令，构建服务器镜像，指定名称为 dream-server：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t dream-server server</span><br></pre></td></tr></table></figure><p>然后就会自动开始下载构建，这个时候我们需要等一会儿。</p><h4 id="连接服务器与数据库"><a href="#连接服务器与数据库" class="headerlink" title="连接服务器与数据库"></a>连接服务器与数据库</h4><p>首先创建一个自定义网络dream-net</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create dream-net</span><br></pre></td></tr></table></figure><p>然后使用官方的mongo镜像创建并运行MongoDB容器。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name dream-db --network dream-net -d mongo</span><br></pre></td></tr></table></figure><p>我们指定容器名称为 dream-db，所连接的网络为 dream-net，并且在后台模式下运行（-d）。</p><div class="note info"><p>提示</p>在同一自定义网络中的所有容器会互相暴露所有端口，不同的应用之间可以更轻松地相互通信；同时，除非通过 -p（--publish）手动开放端口，网络之外无法访问网络中容器的其他端口，实现了良好的隔离性。网络之内的互操作性和网络内外的隔离性也是 Docker Network 的一大优势所在。</div><div class="note danger"><p>危险</p>这里我们在开启 MongoDB 数据库容器时没有设置任何鉴权措施（例如设置用户名和密码），所有连接数据库的请求都可以任意修改数据，在生产环境是极其危险的。后续文章中我们会讲解如何在容器中管理机密信息（例如密码）。</div><p>然后运行服务器容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:4000 --name dream-api --network dream-net -d dream-server</span><br></pre></td></tr></table></figure><p>查看服务器容器的日志输出，确定 MongoDB 连接成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs dream-api</span><br></pre></td></tr></table></figure><p>看到输出下面的信息就代表成功了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Server is running on http:&#x2F;&#x2F;0.0.0.0:4000</span><br><span class="line">Mongoose connected.</span><br></pre></td></tr></table></figure><h4 id="容器化前端页面"><a href="#容器化前端页面" class="headerlink" title="容器化前端页面"></a>容器化前端页面</h4><p>在项目根目录下，通过以下命令进行容器化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t dream-client client</span><br></pre></td></tr></table></figure><p>然后运行容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:80 --name client -d dream-client</span><br></pre></td></tr></table></figure><p>可以通过 <code>docker ps</code> 命令检验三个容器是否全部正确开启：</p><p>最后，访问 localhost:8080(服务器域名:8080)就可以看到，我们在最后刷新了几次页面，数据记录也都还在，说明我们带有数据库的全栈应用跑起来了！</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在&lt;a href=&quot;https://brookliu.xyz/2020/10/07/Docker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B01/#more&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker简单上手01&lt;/a&gt;中我们熟悉了常用的docker命令，并成功地容器化了第一个应用。这篇文章我们将实现后端API服务器+数据库的容器化。&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://github.com/liubrook/liubrook.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://github.com/liubrook/liubrook.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker简单上手01</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2020/10/07/Docker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B01/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2020/10/07/Docker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B01/</id>
    <published>2020-10-07T03:43:52.000Z</published>
    <updated>2020-10-07T09:58:38.107Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前也有听说过docker但是因为没有具体的业务接触所以并没有具体的去了解过，最近手头的工作也暂时没有那么急所以趁着时间来看下。</p><a id="more"></a> <h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>系统：CentOS 7.6 64位</p><h4 id="查看Linux核心版本，3-10版本及以上才可以安装docker"><a href="#查看Linux核心版本，3-10版本及以上才可以安装docker" class="headerlink" title="查看Linux核心版本，3.10版本及以上才可以安装docker"></a>查看Linux核心版本，3.10版本及以上才可以安装docker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><h4 id="更新yum包"><a href="#更新yum包" class="headerlink" title="更新yum包"></a>更新yum包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><h4 id="查看docker是否曾经安装过"><a href="#查看docker是否曾经安装过" class="headerlink" title="查看docker是否曾经安装过"></a>查看docker是否曾经安装过</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">whereis docker</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果安装过，则删除之前的版本</span><br><span class="line">yum remove docker docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure><h4 id="安装需要的软件包"><a href="#安装需要的软件包" class="headerlink" title="安装需要的软件包"></a>安装需要的软件包</h4><p>yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><h4 id="设置yum源"><a href="#设置yum源" class="headerlink" title="设置yum源"></a>设置yum源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>默认安装最新版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure><p>安装某特定版本需增加版本号（如18.06.3.ce-3.el7）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce-18.06.3.ce</span><br></pre></td></tr></table></figure><h4 id="配置用户"><a href="#配置用户" class="headerlink" title="配置用户"></a>配置用户</h4><p>将 docker 的权限移交给非 root 用户，这样使用 docker 就不需要每次都 sudo 了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>注销用户或者重启之后就会生效。然后通过 systemd 服务配置 Docker 开机启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><h4 id="验证安装是否成功"><a href="#验证安装是否成功" class="headerlink" title="验证安装是否成功"></a>验证安装是否成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><p>如果存在Client和Server则成功<br><img src="https://tothers.top1buyer.com/docker-1-2.png" alt="安装成功"></p><h4 id="下载并安装-docker-compose"><a href="#下载并安装-docker-compose" class="headerlink" title="下载并安装 docker-compose"></a>下载并安装 docker-compose</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L &quot;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.27.4&#x2F;docker-compose-$(uname -s)-$(uname -m)&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><h4 id="配置并测试docker-compose"><a href="#配置并测试docker-compose" class="headerlink" title="配置并测试docker-compose"></a>配置并测试docker-compose</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br><span class="line"></span><br><span class="line">docker-compose version</span><br></pre></td></tr></table></figure><p><img src="https://tothers.top1buyer.com/WeChatf12c620346c9dac34e1fb7e84c0bb781.png" alt="成功图"></p><h4 id="配置镜像仓库"><a href="#配置镜像仓库" class="headerlink" title="配置镜像仓库"></a>配置镜像仓库</h4><p>默认的镜像仓库 Docker Hub 在国外，国内拉取速度比较感人。建议参考<a href="https://yeasy.gitbook.io/docker_practice/install/mirror" target="_blank" rel="noopener">这篇文章</a>配置镜像加速</p><p>到这里前期的准备和环境安装工作就完成了，下面就开始上手实践吧！</p><h3 id="上手实验"><a href="#上手实验" class="headerlink" title="上手实验"></a>上手实验</h3><h4 id="实例一：Hello-World"><a href="#实例一：Hello-World" class="headerlink" title="实例一：Hello World!"></a>实例一：Hello World!</h4><p>按照惯例，我们运行胰腺癌来自Docker的Hello World：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p><img src="https://tothers.top1buyer.com/docker-1-3.png" alt="运行图"></p><p>这个过程中Docker做了以下事情：</p><ul><li>检查本地是否有指定的 hello-world:latest 镜像（latest 是镜像标签，后面会细讲），如果没有，执行第 2 步，否则直接执行第 3 步。</li><li>本地没有指定镜像（Unable to find xxx locally），从 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 下载到本地。</li><li>根据本地的 hello-world:latest 镜像创建一个新的容器并运行其中的程序。</li><li>运行完毕后，容器退出，控制权返回给用户。</li></ul><h4 id="实例二：运行一个Nginx服务器"><a href="#实例二：运行一个Nginx服务器" class="headerlink" title="实例二：运行一个Nginx服务器"></a>实例二：运行一个Nginx服务器</h4><p>运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:80 nginx</span><br></pre></td></tr></table></figure><p><img src="https://tothers.top1buyer.com/docker-1-4.png" alt="Nginx运行图"></p><p>运行之后，你会发现一直卡住，也没有任何输出，但放心你的电脑并没有死机。让我们打开浏览器访问localhost:8080(如果像我一样用的服务器可以打开服务器域名:8080来查看)</p><p>打开链接会看到Welecome to nginx！我们可以继续访问一些不存在的路由，比如localhost:8080/index，同样会提示404。这个时候我们运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>可以看到Docker容器的输出，就有内容了。<br>总结下刚才Docker做的事情：</p><ul><li>检查本地是否有指定的 nginx:latest 镜像（关于 latest 标签，后面会细讲），如果没有，执行第 2 步，否则直接执行第 3 步。</li><li>本地没有指定镜像（Unable to find xxx locally），从 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 下载到本地。</li><li>根据本地的 nginx:latest 镜像创建一个新的容器，并通过 <code>**-p（--publish**）</code>参数建立本机的 8080 端口与容器的 80 端口之间的映射，然后运行其中的程序。</li><li>Nginx 服务器程序保持运行，容器也不会退出。</li></ul><h4 id="实例三：后台运行Nginx"><a href="#实例三：后台运行Nginx" class="headerlink" title="实例三：后台运行Nginx"></a>实例三：后台运行Nginx</h4><p>看上去很酷，不过像 Nginx 服务器这样的进程我们更希望把它抛到后台一直运行。按 Ctrl + C 退出当前的容器，然后再次运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:80 --name my-nginx -d nginx</span><br></pre></td></tr></table></figure><p>注意到与之前不同的是，我们：</p><ul><li>加了一个参数 –name，用于指定容器名称为 my-nginx。</li><li>加了一个选项 -d（–detach），表示 “后台运行”。</li></ul><blockquote><p>容器的名称必须是唯一的，如果已经存在同一名称的容器（即使已经不再运行）就会创建失败。如果遇到这种情况，可以删除之前不需要的容器（后面会讲解怎么删除）。</p></blockquote><p>Docker 会输出一串长长的 64 位容器 ID，然后把终端的控制权返回给了我们。我们试着访问 localhost:8080(服务器域名:8080)，还能看到那一串熟悉的 Welcome to nginx!，说明服务器真的在后台运行起来了。</p><p>那我们怎么管理这个服务器呢？就像熟悉的 UNIX ps 命令一样，docker ps 命令可以让我们查看当前容器的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>输出结果是这样的:<br><img src="https://tothers.top1buyer.com/docker-1-5.png" alt="ps输出"></p><p>从这张表中，就可以清晰地看到了我们在后台运行的 Nginx 服务器容器的一些信息：</p><ul><li>容器 ID（Container ID）为 f104751ca7db（你机器上的可能不一样）。</li><li>所用镜像（Image）为 nginx。</li><li>运行命令 / 程序（Command）为 nginx -g ‘daemon of…，这个是 Nginx 镜像自带的运行命令，暂时不用关心。</li><li>创建时间（Created）为 an hour ago（一小时之前）。</li><li>当前状态（Status）为 Up About an hout（已运行 超过一小时）。</li><li>端口（Ports）为 0.0.0.0:8080-&gt;80/tcp，意思是访问本机的 0.0.0.0:8080 的所有请求会被转发到该容器的 TCP 80 端口。</li><li>名称（Names）为刚才指定的 my-nginx。</li></ul><p>如果我们要让容器停下来，通过 docker stop 命令指定容器名称或 ID 进行操作即可，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop my-nginx</span><br></pre></td></tr></table></figure><h4 id="实例四：交互式运行"><a href="#实例四：交互式运行" class="headerlink" title="实例四：交互式运行"></a>实例四：交互式运行</h4><p>运行以下命令，让我们进入到一个 Ubuntu 镜像中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name dreamland ubuntu</span><br></pre></td></tr></table></figure><p>可以看到我们加了 -it 选项，等于是同时指定 -i（–interactive，交互式模式）和 -t（–tty，分配一个模拟终端） 两个选项。以上命令的输出如下：<br><img src="https://tothers.top1buyer.com/docker-1-6.png" alt="ubuntu输出图"></p><p>这时我们已经在这个Ubuntu镜像中了，可以运行一些命令来看一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br><span class="line"></span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>按 Ctrl + D （或者输入 exit 命令）即可退出。你可以在 docker ps 的终端再次检查容器是否已经被关闭了。</p><h4 id="销毁容器"><a href="#销毁容器" class="headerlink" title="销毁容器"></a>销毁容器</h4><p>我们刚才创建的 Docker 容器也只是用于初步探索，后续不会再用到。由于 Docker 容器是直接存储在我们本地硬盘上的，及时清理容器也能够让我们的硬盘压力小一些。我们可以通过以下命令查看所有容器（包括已经停止的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>类似 Shell 中的 rm 命令，我们可以通过 docker rm 命令销毁容器，例如删除我们之前创建的 dreamland 容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm dreamland</span><br><span class="line"># 或者指定容器 ID，记得替换成自己机器上的</span><br><span class="line"># docker rm f104751ca7db（你机器上的可能不一样）。</span><br></pre></td></tr></table></figure><p>但如果我们想要销毁所有容器怎么办？一次次输入 docker rm 删除显然不方便，可以通过以下命令轻松删除所有容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>docker ps -aq 会输出所有容器的 ID，然后作为参数传给 docker rm 命令，就可以根据 ID 删除所有容器啦。</p><p>删除运行中的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f dreamland</span><br></pre></td></tr></table></figure><p>同样的，我们可以删除所有容器，无论处于什么状态:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -aq)</span><br></pre></td></tr></table></figure><h3 id="容器化第一个应用：开启筑梦之旅"><a href="#容器化第一个应用：开启筑梦之旅" class="headerlink" title="容器化第一个应用：开启筑梦之旅"></a>容器化第一个应用：开启筑梦之旅</h3><p>在之前的步骤中，我们体验了别人为我们提前准备好的镜像（例如 hello-world、nginx 和 ubuntu），这些镜像都可以在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 镜像仓库中找到。在这一步，我们将开始筑梦之旅：学习如何容器化（Containerization）你的应用。</p><p>运行以下命令来获取代码，然后进入项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone -b start-point https:&#x2F;&#x2F;github.com&#x2F;tuture-dev&#x2F;docker-dream.git</span><br><span class="line">cd docker-dream</span><br></pre></td></tr></table></figure><p>如果没有安装git，可以运行 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><p>来安装，也可以到<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">GIT官网</a>来查看如何安装你所对应的平台。</p><p>在这一步中，我们将容器化这个用 React 编写的前端应用，用 Nginx 来提供前端页面的访问。</p><h4 id="什么是容器化"><a href="#什么是容器化" class="headerlink" title="什么是容器化"></a>什么是容器化</h4><p>什么是容器化:</p><ul><li>编写代码：我们已经提供了写好的代码。</li><li>构建镜像。</li><li>创建和运行容器：通过容器的方式运行我们的应用。</li></ul><h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><p>构建 Docker 镜像主要包括两种方式：</p><ul><li>手动：根据现有的镜像创建并运行一个容器，进入其中进行修改，然后运行 docker commit 命令根据修改后的容器创建新的镜像。</li><li>自动：创建 Dockerfile 文件，指定构建镜像的命令，然后通过 docker build 命令直接创建镜像。</li></ul><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>我们先把前端项目 client 构建成一个静态页面。确保你的机器上已经安装 Node 和 npm（点击<a href="https://nodejs.org/en/" target="_blank" rel="noopener">这里</a>下载，或使用 <a href="https://github.com/nvm-sh/nvm">nvm</a>），然后进入到 client 目录下，安装所有依赖，并构建项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd client</span><br><span class="line">npm install</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>如果安装node和npm出现问题的可以看下我之前的这篇文章<a href="https://brookliu.xyz/2019/12/27/Linux%E4%B8%8B%E5%AE%89%E8%A3%85node/#more" target="_blank" rel="noopener">Linux安装Node</a>。</p><p>等待一阵子后，你应该可以看到 client/build 目录，存放了我们要展示的前端静态页面。</p><p>创建 Nginx 配置文件 client/config/nginx.conf，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    root &#x2F;www;</span><br><span class="line">    index index.html;</span><br><span class="line">    sendfile on;</span><br><span class="line">    sendfile_max_chunk 1M;</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">    gzip_static on;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        try_files $uri $uri&#x2F; &#x2F;index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置大致意思是：监听 80 端口，网页根目录在 /www，首页文件是 index.html，如果访问 / 则提供文件 index.html。</p><h4 id="创建-Dockerfile"><a href="#创建-Dockerfile" class="headerlink" title="创建 Dockerfile"></a>创建 Dockerfile</h4><p>然后就是这一步骤中最重要的代码：Dockerfile！创建 client/Dockerfile 文件，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx:1.13</span><br><span class="line"></span><br><span class="line"># 删除 Nginx 的默认配置</span><br><span class="line">RUN rm &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf</span><br><span class="line"></span><br><span class="line"># 添加自定义 Nginx 配置</span><br><span class="line">COPY config&#x2F;nginx.conf &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;</span><br><span class="line"></span><br><span class="line"># 将前端静态文件拷贝到容器的 &#x2F;www 目录下</span><br><span class="line">COPY build &#x2F;www</span><br></pre></td></tr></table></figure><p>可以看到我们用了 Dockerfile 中的三个指令：</p><ul><li>FROM 用于指定基础镜像，这里我们基于 nginx:1.13 镜像作为构建的起点。</li><li>RUN 命令用于在容器内运行任何命令（当然前提是命令必须存在）。</li><li>COPY 命令用于从 Dockerfile 所在的目录拷贝文件到容器指定的路径。</li></ul><p>现在可以来构建我们的镜像了，运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 如果你已经在 client 目录中</span><br><span class="line">#（注意最后面有个点，代表当前目录）</span><br><span class="line">docker build -t dream-client .</span><br><span class="line"></span><br><span class="line"># 如果你回到了项目根目录</span><br><span class="line">docker build -t dream-client client</span><br></pre></td></tr></table></figure><p>可以看到我们指定了 -t（–tag，容器标签）为 dream-client，最后指定了构建容器的上下文目录（也就是 当前目录 . 或 client）。</p><p>运行以上的命令之后，你会发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon  289.4MB</span><br></pre></td></tr></table></figure><p>接着运行了一系列的 Step（4 个），然后提示镜像构建成功。</p><p>为什么这个构建上下文（Build Context）这么大？因为我们把比 “黑洞” 还 “重” 的 node_modules 也加进去了！（忍不住想起了下面这张图）<br><img src="https://tothers.top1buyer.com/docker-1-7.png" alt="构建"></p><p>Docker 提供了类似 .gitignore 的机制，让我们可以在构建镜像时忽略特定的文件或目录。创建 client/.dockerignore 文件（注意 dockerignore 前面有一个点）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br></pre></td></tr></table></figure><p>再次运行构建命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t dream-client .</span><br></pre></td></tr></table></figure><p><img src="https://tothers.top1buyer.com/docker-1-7.png" alt="再次构建构建"><br>可以看到这次只有1.217MB，而且速度也明显快了很多.</p><h4 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h4><p>终于到了容器化的最后一步 —— 创建并运行我们的容器！通过以下命令运行刚才创建的 dream-client 镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:80 --name client -d dream-client</span><br></pre></td></tr></table></figure><p>与之前类似，我们还是设定端口映射规则为 8080:80，容器名称为 client，并且通过 -d 设置为后台运行。然后访问 localhost:8080(老样子–服务器域名:8080)：<br><img src="https://tothers.top1buyer.com/docker-1-7.png" alt="运行容器"><br>可以看到如图所示的页面，表示容器运行成功.</p><h4 id="关于镜像标签"><a href="#关于镜像标签" class="headerlink" title="关于镜像标签"></a>关于镜像标签</h4><p>在刚才的实战中，你也许已经注意到在拉取和构建镜像时，Docker 总是会为我们加上一个 :latest 标签，这个 :latest 的含义便是 “最新” 的意思。和软件的版本机制一样，镜像也可以通过标签实现 “版本化”。</p><p>实际上，我们完全可以在拉取或构建镜像时指定标签（通常被认为是一种好的做法）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:1.13</span><br><span class="line">docker build -t dream-client:1.0.0</span><br></pre></td></tr></table></figure><p>还可以给现有的镜像打上标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 把默认的 latest 镜像打上一个 newest 标签</span><br><span class="line">docker tag dream-client dream-client:newest</span><br><span class="line"># 甚至可以同时修改镜像的名称和标签</span><br><span class="line">docker tag dream-client:1.0.0 dream-client2:latest</span><br></pre></td></tr></table></figure><p>可以看到，标签未必一定是版本，还可以是任何字符串（当然最好要有意义，否则过了一阵子你也不记得这个打了这个标签的容器有什么作用了）。</p><h4 id="关于-Dockerfile"><a href="#关于-Dockerfile" class="headerlink" title="关于 Dockerfile"></a>关于 Dockerfile</h4><p>Dockerfile 实际上是默认名称，我们当然可以取一个别的名字，例如 myDockerfile，然后在构建镜像时指定 -f（–file）参数即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f myDockerfile -t dream-client .</span><br></pre></td></tr></table></figure><p>这里举两个经典的使用场景：</p><ul><li>例如在 Web 开发时，分别创建 Dockerfile.dev 用于构建开发镜像，创建 Dockerfile.prod 构建生产环境下的镜像；</li><li>在训练 AI 模型时，创建 Dockerfile.cpu 用于构建用 CPU 训练的镜像，创建 Dockerfile.gpu 构建用 GPU 训练的镜像。</li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这篇文章是我跟着图灵社区的流程走了一遍所记录的过程，<a href="https://tuture.co/2020/01/01/442cc8d/" target="_blank" rel="noopener">点击这里查看图灵社区</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前也有听说过docker但是因为没有具体的业务接触所以并没有具体的去了解过，最近手头的工作也暂时没有那么急所以趁着时间来看下。&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://github.com/liubrook/liubrook.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://github.com/liubrook/liubrook.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Webpack上传腾讯云</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2020/09/18/Webpack%E4%B8%8A%E4%BC%A0%E8%85%BE%E8%AE%AF%E4%BA%91/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2020/09/18/Webpack%E4%B8%8A%E4%BC%A0%E8%85%BE%E8%AE%AF%E4%BA%91/</id>
    <published>2020-09-18T09:08:16.000Z</published>
    <updated>2020-09-18T09:31:41.160Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>我们公司之前的项目一直都是打包之后上传七牛，但是最近一段时间总是出现打包文件找不到的情况，中间过程就省略了，最后决定把项目文件放到腾讯云上。</p><a id="more"></a><h3 id="腾讯云准备工作"><a href="#腾讯云准备工作" class="headerlink" title="腾讯云准备工作"></a>腾讯云准备工作</h3><ul><li>进入腾讯云控制台。</li><li>打开对象存储。</li><li>点击存储桶列表-创建存储桶。</li><li>在存储桶列表里点击刚创建的桶-点击右侧权限管理-存储桶访问权限-公有读私有写。<br>如果有CDN加速需求的话。<ul><li>点击右侧域名与传输管理-自定义CDN加速域名-添加域名(这一步看你是想要采用默认CDN加速域名还是自定义的)。</li><li>如果是自定义加速域名的话除了域名的HTTPS配置，在腾讯云上还要进行配置:<ul><li>控制台-点击内容分发网络-左侧证书管理-配置对应的证书。(我开始不知道要做这一步，文件上传到腾讯云之后一直无法访问，后来提了工单才知道，耽误了几个小时)。</li></ul></li></ul></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i tencent-cloud-webpack-plugin</span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>支持的配置项:</p><ul><li><code>secretId</code> COS SecretId</li><li><code>secretKey</code> COS SecretKey</li><li><code>bucket</code> COS 存储对象名称，格式为对象名称加应用 ID，如：<code>bucket-1250000000</code></li><li><code>region</code> COS 存储地域，参见<a href="https://cloud.tencent.com/document/product/436/6224" target="_blank" rel="noopener">官方文档</a></li><li><code>path</code> 存储路径， 默认为 <code>[hash]</code>，也可以指定 hash 长度，如: <code>[hash:8]</code></li><li><code>exclude</code> 可选，排除特定文件，正则表达式，如: <code>/index\.html$/</code></li><li><code>include</code> 可选，指定要上传的文件，正则表达式，如: <code>/app\.js$/</code></li><li><code>batch</code> 可选，批量上传文件并发数，默认 20</li></ul><p><strong><em>注: Webpack 的 <code>output.publicPath</code> 要指向 COS（或自定义的）域名地址</em></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">const</span> CosPlugin = <span class="built_in">require</span>(<span class="string">'cos-webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里用项目名加上时间戳用来在腾讯云中区分标识</span></span><br><span class="line"><span class="keyword">const</span> fileName = <span class="string">'projectName/'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 Plugin</span></span><br><span class="line"><span class="keyword">const</span> cosPlugin = <span class="keyword">new</span> CosPlugin(&#123;</span><br><span class="line">    secretId: defaultSettings.tencent.secretId,</span><br><span class="line">    secretKey: defaultSettings.tencent.secretKey,</span><br><span class="line">    bucket: defaultSettings.tencent.bucket,</span><br><span class="line">    region: defaultSettings.tencent.region,</span><br><span class="line">    path: fileName</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Webpack 的配置</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> output: &#123;</span><br><span class="line">    publicPath: IS_PROD ? defaultSettings.tencent.publicPath + fileName + <span class="string">'/dist'</span> : <span class="string">'/'</span>,</span><br><span class="line">    outputDir: <span class="string">'dist'</span>,</span><br><span class="line">    assetsDir: <span class="string">'static'</span>,</span><br><span class="line"> &#125;,</span><br><span class="line"> plugins: [</span><br><span class="line">   cosPlugin</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"> ]</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><a href="https://github.com/liubrook/tencent-cloud-webpack">示例项目</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;我们公司之前的项目一直都是打包之后上传七牛，但是最近一段时间总是出现打包文件找不到的情况，中间过程就省略了，最后决定把项目文件放到腾讯云上。&lt;/p&gt;</summary>
    
    
    
    <category term="Webpack" scheme="https://github.com/liubrook/liubrook.github.io/categories/Webpack/"/>
    
    
    <category term="Webpack" scheme="https://github.com/liubrook/liubrook.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>浏览器输入URL后发生了什么？</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2020/01/15/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2020/01/15/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2020-01-15T12:10:24.000Z</published>
    <updated>2020-09-24T03:38:17.516Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器输入URL之后大体上可以分为六步:<br>合成URL-DNS域名解析-建立TCP连接-发送请求，返回结果-关闭TCP连接-浏览器渲染</p><a id="more"></a>  <h3 id="合成URL"><a href="#合成URL" class="headerlink" title="合成URL"></a>合成URL</h3><p>用户输入URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL。</p><h3 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h3><p>在网络世界，记住网站的名称很容易，但是记住网站的IP地址却很难。这时候我们就需要一个地址簿，就是DNS服务器。DNS服务器是高可用、高并发和分布式的，它是树状结构，如图：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/1.png" alt="DNS图"></p><ul><li>根DNS服务器：返回顶级域DNS服务器的IP地址.</li><li>顶级域DNS服务器：返回权威DNS服务器的IP地址.</li><li>权威DNS服务器：返回相应主机的IP地址.</li></ul><p>DNS的域名查找，在客户端和浏览器、本地DNS之间的查询方式是递归查询；在本地DNS服务器与根域及其子域之间的查询方式迭代查询；<br>递归过程：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/2.png" alt="DNS查询图"></p><p>在客户端输入URL之后，会有一个递归查找的过程，从浏览器缓存中查找-&gt;本地的hosts文件查找-&gt;在本地DNS解析器缓存查找-&gt;本地DNS服务器查找，这个过程中任何一步找到了都会结束查找流程。</p><p>如果本地DNS服务器无法查询到，则根据本地DNS服务器设置的转发器进行查询。若未用转发模式，则迭代查找过程如下图：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/2.png" alt="迭代查找图"></p><p>结合起来的过程，可以用一个图表示：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/4.png" alt="DNS图"></p><p>在查找过程中，有以下优化点：</p><ul><li><p>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种：浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存。</p></li><li><p>在域名和IP的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均很，也可以根据地址和运营商做全局的负载均衡。</p><h3 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h3><p>首先，判断是不是HTTPS，如果是的话则HTTPS其实是HTTP+SSL/TLS两部分组成，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户短的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。</p></li></ul><p>进行三次握手，建立TCP连接：</p><ul><li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后客户端今日SYN_SEND状态，等待服务器的确认。</li><li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段)中，一并发送给客户端，此时服务器进入SYN_RECV状态。</li><li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</li></ul><p>SSL握手过程：</p><ul><li>第一阶段：建立安全能力，包括协议版本、会话Id、密码构件、压缩方法、初始随机数。</li><li>第二阶段：服务器发送证书、密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号。</li><li>第三阶段：如果有证书请求客户端发送此证书，之后客户端发送密钥交换数据，也可以发送证书验证消息。</li><li>第四阶段：变更密码构件和结束握手协议。</li></ul><p>完成了之后，客户端和服务器端就可以开始传送数据。</p><p><font color="blue">备注：</font></p><p>ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0。TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1。</p><p>SYN(SYNchronization)：在连接建立时用来同步序号。当SYN=1而ACK=0时，表示这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1.因此，SYN置为1就表示这是一个连接请求或连接接受报文。</p><p>FIN(finis)：用来释放一个连接。当FIN=1时，表示此报文段的发送方的数据已经发送完毕，并要求释放连接。</p><h3 id="发送HTTP请求，服务器处理请求，返回响应结果"><a href="#发送HTTP请求，服务器处理请求，返回响应结果" class="headerlink" title="发送HTTP请求，服务器处理请求，返回响应结果"></a>发送HTTP请求，服务器处理请求，返回响应结果</h3><p>TCP连接建立后，浏览器就可以利用HTTP/HTTPS协议向服务器发送请求了。服务器接收到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200。</p><h3 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h3><ul><li>第一次分手：主机1(可以是客户端，也可以是服务器端)，设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了。</li><li>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1返回一个ACK报文段，ACKnowledgment Number为Sequence Number + 1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我同意你的关闭请求。</li><li>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2今日LAST_ACK状态。</li><li>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1今日TIME_WAIT状态，主机2收到主机1的ACK报文段以后就关闭连接。此时，主机1等到2MSL后仍然没有收到回复，则证明主机2已正常关闭，主机1也可以关闭连接了。</li></ul><h3 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h3><p>按照渲染的时间顺序，流水线可分为如下几个子阶段：构建DOM树、样式计算、布局阶段、分层、栅格化、限时。如图：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/5.png" alt="渲染图"></p><ul><li>渲染进程将HTML内容转换为能够读懂DOM树结构。</li><li>渲染引擎将CSS样式表转换为浏览器可以理解的styleSheets，计算出DOM节点的样式。</li><li>创建布局树，并计算元素的布局信息。</li><li>对布局树进行分层，并生成分层树。</li><li>为每个图层生成绘制列表，并将其提交到合成线程，合成线程将图层分图块，并栅格化将图块转换成位图。</li><li>合成线程发送绘制图块命令给浏览器进程，浏览器进程根据指令生成页面，并显示到显示器上。</li></ul><h4 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h4><p>浏览器从网络或硬盘中获得HTML字节数据后会经过一个流程将字节解析为DOM树，先讲HTML的原始字节数据转换为文件指定编码的自负，然后浏览器会根据HTML规范来讲字符串转换成各种令牌标签，如html、body等。最终解析成一个树状的对象模型，就是dom树。<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/6.png" alt="DOM"></p><p>具体步骤：</p><ul><li>转码(Bytes-&gt;Characters)–读取接收到的HTML二进制数据，按照指定编码格式将字节转换为HTML字符串。</li><li>Tokens转化(Characters-&gt;Tokens)–解析HTML，将HTML字符串转换为结构清晰的Tokens，每个Token都有特殊的含义同时有自己的一套规则。</li><li>构建Node(Tokens-&gt;Nodes)–每个Node都添加特定的属性(或属性访问器)，通过指针能够确定Node的父子兄弟关系和所属treeScope。</li><li>构建DOM树(Nodes-&gt;DOM Tree)–最重要的工作是建立起每个节点的父子兄弟关系。</li></ul><h4 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h4><p>渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。</p><p>CSS样式来源主要有3种，分别是通过link引用的外部CSS文件、style标签内的CSS、元素的style属性内嵌的CSS，其样式计算过程主要为：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/7.png" alt="CSS"></p><p>可以看到上面的CSS文本中有很多属性值，如2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化，处理完成后再处理样式的继承和层叠， 有些文章将这个过程成为CSSOM的构建过程。</p><h4 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h4><p>布局过程，即排除<code>&lt;script&gt;、&lt;meta&gt;</code>等功能化、非视觉节点，排除display:none的节点，计算元素的位置信息，确定元素的位置，构建一颗只包含可见元素布局树，如图：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/8.png" alt="布局图"></p><p>这个过程需要注意的是回流和重绘。</p><h4 id="生成分层树"><a href="#生成分层树" class="headerlink" title="生成分层树"></a>生成分层树</h4><p>页面中有很多复杂的效果，如一些复杂的3D变化、页面滚动，或者使用z-indexing做z轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成占用的图层，并生成一颗对应的图层树(LayerTree)。</p><p>如果你熟悉PS，相信你会很容易理解图层的概念，正是这些图层添加在一起构成了最终的页面图像，在浏览器中，你可以打开Chrome的‘开发者工具’，选择‘layers’标签。渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。</p><p>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。</p><h4 id="栅格化"><a href="#栅格化" class="headerlink" title="栅格化"></a>栅格化</h4><p>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。</p><p>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口(viewport)。在有些情况下，有的图层可以很大比如有的页面你使用滚动条要滚动到好久才能到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p><h4 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h4><p>最后，合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上，渲染过程完成。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;浏览器输入URL之后大体上可以分为六步:&lt;br&gt;合成URL-DNS域名解析-建立TCP连接-发送请求，返回结果-关闭TCP连接-浏览器渲染&lt;/p&gt;</summary>
    
    
    
    <category term="浏览器" scheme="https://github.com/liubrook/liubrook.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="https://github.com/liubrook/liubrook.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Javascript数组去重</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2020/01/05/Javascript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2020/01/05/Javascript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</id>
    <published>2020-01-05T12:47:48.000Z</published>
    <updated>2020-09-24T02:57:54.263Z</updated>
    
    <content type="html"><![CDATA[<p>常见的Javascript数组去重的12种方法</p><a id="more"></a>  <h4 id="利用ES6-Set去重-ES6中最常用"><a href="#利用ES6-Set去重-ES6中最常用" class="headerlink" title="利用ES6 Set去重(ES6中最常用)"></a>利用ES6 Set去重(ES6中最常用)</h4><p>不考虑兼容性，这种去重的方法代码最少。这种方法无法去掉“{}”空对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    return Array.from(new Set(arr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用for嵌套for，然后splice去重-ES5中最常用"><a href="#利用for嵌套for，然后splice去重-ES5中最常用" class="headerlink" title="利用for嵌套for，然后splice去重(ES5中最常用)"></a>利用for嵌套for，然后splice去重(ES5中最常用)</h4><p>双重循环，外层循环元素，内层循环时比较值。值相同时，则删除这个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        for (var j &#x3D; i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">            if (arr[i] &#x3D;&#x3D; arr[j]) &#123;</span><br><span class="line">                &#x2F;&#x2F; 第一个等同于第二个，splice方法删除第二个</span><br><span class="line">                arr.splice(j, 1);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用indexOf去重"><a href="#利用indexOf去重" class="headerlink" title="利用indexOf去重"></a>利用indexOf去重</h4><p>新建一个空的结果数组，for循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进结果数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#39;type error!&#39;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var array &#x3D; [];</span><br><span class="line">    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (array.indexOf(arr[i]) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">            array.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用sort"><a href="#利用sort" class="headerlink" title="利用sort()"></a>利用sort()</h4><p>利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&quot;type error!&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    arr &#x3D; arr.sort()</span><br><span class="line">    var array &#x3D; [arr[0]];</span><br><span class="line">    for (var i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i] !&#x3D;&#x3D; arr[i - 1]) &#123;</span><br><span class="line">            array.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用对象的属性不能相同的特点进行去重-这种数组去重的方法有问题，不建议用，有待改进"><a href="#利用对象的属性不能相同的特点进行去重-这种数组去重的方法有问题，不建议用，有待改进" class="headerlink" title="利用对象的属性不能相同的特点进行去重(这种数组去重的方法有问题，不建议用，有待改进)"></a>利用对象的属性不能相同的特点进行去重(这种数组去重的方法有问题，不建议用，有待改进)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#39;type error!&#39;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var array &#x3D; [];</span><br><span class="line">    var obj &#x3D; &#123;&#125;;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (!obj[arr[i]]) &#123;</span><br><span class="line">            array.push(arr[i])</span><br><span class="line">            obj[arr[i]] &#x3D; 1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            obj[arr[i]]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用includes"><a href="#利用includes" class="headerlink" title="利用includes"></a>利用includes</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#39;type error!&#39;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var array &#x3D; [];</span><br><span class="line">    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (!array.includes(arr[i])) &#123;</span><br><span class="line">            array.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用hasOwnProperty判断是否存在对象属性"><a href="#利用hasOwnProperty判断是否存在对象属性" class="headerlink" title="利用hasOwnProperty判断是否存在对象属性"></a>利用hasOwnProperty判断是否存在对象属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    var obj &#x3D; &#123;&#125;;</span><br><span class="line">    return arr.filter(function(item, index, arr) &#123;</span><br><span class="line">        return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] &#x3D; true)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用filter"><a href="#利用filter" class="headerlink" title="利用filter"></a>利用filter</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    return arr.filter(function(item, index, arr) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当前元素，在原始数组中的第一个索引&#x3D;&#x3D;当前索引值，否则返回当前元素</span><br><span class="line">        return arr.indexOf(item, 0) &#x3D;&#x3D;&#x3D; index;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用递归去重"><a href="#利用递归去重" class="headerlink" title="利用递归去重"></a>利用递归去重</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    var array &#x3D; arr;</span><br><span class="line">    var len &#x3D; array.length;</span><br><span class="line">    arr.sort((a, b) &#x3D;&gt; a - b)</span><br><span class="line">    function loop(index) &#123;</span><br><span class="line">        if (index &gt;&#x3D; 1) &#123;</span><br><span class="line">            if (array[index] &#x3D;&#x3D;&#x3D; array[index - 1]) &#123;</span><br><span class="line">                array.splice(index, 1)</span><br><span class="line">            &#125;</span><br><span class="line">            loop(index - 1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    loop(len - 1);</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用Map数据结构去重"><a href="#利用Map数据结构去重" class="headerlink" title="利用Map数据结构去重"></a>利用Map数据结构去重</h4><p>创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function arraynonRepeatfy(arr) &#123;</span><br><span class="line">    let map &#x3D; new Map();</span><br><span class="line">    let array &#x3D; new Array();</span><br><span class="line">    for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (map.has(arr[i])) &#123;</span><br><span class="line">            map.set(arr[i], true)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.set(arr[i], false)</span><br><span class="line">            array.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用reduce-includes"><a href="#利用reduce-includes" class="headerlink" title="利用reduce+includes"></a>利用reduce+includes</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    return arr.reduce((prev, cur) &#x3D;&gt; prev.includes(cur) ? prev : [...prev, cur], [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="…new-Set-arr"><a href="#…new-Set-arr" class="headerlink" title="[…new Set(arr)]"></a>[…new Set(arr)]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...new Set(arr)]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;常见的Javascript数组去重的12种方法&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>前端常见面试题-1</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2020/01/02/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-1/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2020/01/02/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-1/</id>
    <published>2020-01-02T02:47:48.000Z</published>
    <updated>2020-09-24T02:51:58.745Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1，http的状态码中，499是什么？如何出现499？如何排查解决？"><a href="#1，http的状态码中，499是什么？如何出现499？如何排查解决？" class="headerlink" title="1，http的状态码中，499是什么？如何出现499？如何排查解决？"></a>1，http的状态码中，499是什么？如何出现499？如何排查解决？</h3><p>499对应的是“client has closed connection”，客户端请求等待连接已经关闭，这很有可能是因为服务器端处理的时间过长，客户端等的‘不耐烦了’。还可能是因为两次提交post请求过快就会出现499。<br>解决方法:</p><ul><li>前端将timeout最大等待时间设置大一些。</li><li>nginx上配置proxt_ignore_client_abort on;<a id="more"></a>  <h3 id="2，如何遍历一个dom树"><a href="#2，如何遍历一个dom树" class="headerlink" title="2，如何遍历一个dom树"></a>2，如何遍历一个dom树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function traversal(node) &#123;</span><br><span class="line">    &#x2F;&#x2F; 对node的处理</span><br><span class="line">    if (node &amp;&amp; node.nodeType &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">        console.log(node.tagName);</span><br><span class="line">    &#125;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; node.childNodes.length; i++) &#123;</span><br><span class="line">        const item &#x3D; node.childNodes[i];</span><br><span class="line">        if (item.nodeType &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; 递归先序遍历子节点</span><br><span class="line">            traversal(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3，new操作符都做了什么？"><a href="#3，new操作符都做了什么？" class="headerlink" title="3，new操作符都做了什么？"></a>3，new操作符都做了什么？</h3><p>四大步骤：</p><ul><li>创建一个空对象，并且this变量引用该对象。</li><li>继承了函数的原型。</li><li>属性和方法被加入到this引用的对象中，并且执行了该函数func。</li><li>新创建的对象由this所引用，并且最后隐式的返回this。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function new(func) &#123;</span><br><span class="line">    let target &#x3D; &#123;&#125;;</span><br><span class="line">    target.__proto__ &#x3D; func.prototype;</span><br><span class="line">    let res - func.call(target);</span><br><span class="line">    if (typeof(res) &#x3D;&#x3D; &#39;object&#39; &#125;&#125; typeof(res) &#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4，简单实现call"><a href="#4，简单实现call" class="headerlink" title="4，简单实现call"></a>4，简单实现call</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; es3</span><br><span class="line">Function.prototype.call2 &#x3D; function (context) &#123;</span><br><span class="line">    var context &#x3D; context || window; &#x2F;&#x2F; 因为传进来的context有可能是null</span><br><span class="line">    context.fn &#x3D; this;</span><br><span class="line">    var args &#x3D; [];</span><br><span class="line">    for (var i &#x3D; 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">        args.push(&quot;arguments[&quot; + i + &quot;]&quot;); &#x2F;&#x2F;不这么做的话 字符串的引号会被自动去掉 变成了变量 导致报错</span><br><span class="line">    &#125;</span><br><span class="line">    args &#x3D; args.join(&quot;,&quot;);</span><br><span class="line">    var result &#x3D; eval(&quot;context.fn(&quot; + args + &quot;)&quot;); &#x2F;&#x2F;相当于执行了context.fn(arguments[1], arguments[2]);</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result; &#x2F;&#x2F; 因为有可能this函数会有返回值return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; es6</span><br><span class="line">Function.prototype.call2 &#x3D; function (context) &#123;</span><br><span class="line">    context &#x3D; context ? Object(context) : window;</span><br><span class="line">    context.fn &#x3D; this;</span><br><span class="line">    let args &#x3D; [...arguments].slice(1)</span><br><span class="line">    let result &#x3D; context.fn(...args);</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5，简单实现apply"><a href="#5，简单实现apply" class="headerlink" title="5，简单实现apply"></a>5，简单实现apply</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; es3</span><br><span class="line">Function.prototype.apply2 &#x3D; function(context, arr) &#123;</span><br><span class="line">    context &#x3D; context ? Object(context) : window;</span><br><span class="line">    context.fn &#x3D; this;</span><br><span class="line">    var result;</span><br><span class="line">    &#x2F;&#x2F; 判断是否存在第二个参数</span><br><span class="line">    if (!arr) &#123;</span><br><span class="line">        result &#x3D; context.fn();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var args &#x3D; [];</span><br><span class="line">        for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            args.push(&quot;arr[&quot; + i + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        result &#x3D; eval(&quot;context.fn(&quot; + args + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; es6</span><br><span class="line">Function.prototype.apply2 &#x3D; function(context, arr) &#123;</span><br><span class="line">    context &#x3D; context ? Object(context) : window;</span><br><span class="line">    context.fn &#x3D; this;</span><br><span class="line">    let result;</span><br><span class="line">    if (!arr) &#123;</span><br><span class="line">        result &#x3D; context.fn();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        result &#x3D; context.fn(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6，简单实现bind"><a href="#6，简单实现bind" class="headerlink" title="6，简单实现bind"></a>6，简单实现bind</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line">    var _this &#x3D; this;</span><br><span class="line">    var argsParent &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var args &#x3D; argsParent.contact(Array.prototype.slice.call(arguments));</span><br><span class="line">        _this.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7，https对称加密和非对称加密"><a href="#7，https对称加密和非对称加密" class="headerlink" title="7，https对称加密和非对称加密"></a>7，https对称加密和非对称加密</h3><p>对称加密：发送方和接收方需要持有同一把密钥，发送消息和接收消息均使用该密钥。相对于非加密对称，加密对称具有更高的加解密速度，但双方都需要实现知道密钥，密钥在传输过程中可能会被窃取，因此安全性没有非对称加密高。</p><p>非对称加密；接收方在发送消息前需要事先生成公钥和私钥，然后将公钥发送给发送方，发送方收到公钥后，将待发送数据用公钥加密，发送给接收方。接收方收到数据后，用私钥解密。在这个过程中，公钥负责加密，私钥负责解密，数据在传输过程中即使被截获，攻击者由于没有私钥也无法破解数据。非对称加密算法的加解密速度低于对称加密算法，但是安全性更高。</p><h3 id="8，简单实现promise"><a href="#8，简单实现promise" class="headerlink" title="8，简单实现promise"></a>8，简单实现promise</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 简易版本的promise</span><br><span class="line">&#x2F;&#x2F; 第一步：列出三大块 this.then resolve&#x2F;reject fn(resolve, reject)</span><br><span class="line">&#x2F;&#x2F; 第二步：this.then负责注册所有的函数 resolve&#x2F;reject负责执行所有函数</span><br><span class="line">&#x2F;&#x2F; 第三步：在resolve&#x2F;reject里面要加上setTimeout，防止还没尽兴then注册，就直接执行resolve了</span><br><span class="line">&#x2F;&#x2F; 第四步：resolve&#x2F;reject里面要返回this，这样就可以链式调用了</span><br><span class="line">&#x2F;&#x2F; 第五步：三个状态的管理 pending fulfilled rejected</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  *****promise的链式调用，在then里面return一个promise这样才能then里面加上异步函数</span><br><span class="line">&#x2F;&#x2F; 加上了catch</span><br><span class="line">function PromiseM(fn) &#123;</span><br><span class="line">    var value &#x3D; null;</span><br><span class="line">    var callbacks &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F; 加入状态，为了解决在Promise异步操作成功之后调用的then注册的回调不会执行的问题</span><br><span class="line">    var state &#x3D; &#39;pending&#39;;</span><br><span class="line">    var _this &#x3D; this;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 注册所有的回调函数</span><br><span class="line">    this.then &#x3D; function (fulfilled, rejected) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果想链式promise，那就要在这边return一个new Promise</span><br><span class="line">        return new PromiseM(function (resolve, reject) &#123;</span><br><span class="line">            &#x2F;&#x2F; 异常处理</span><br><span class="line">            try &#123;</span><br><span class="line">                if (state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                    callbacks.push(fulfilled);</span><br><span class="line">                    &#x2F;&#x2F; 实现链式调用</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;) &#123;</span><br><span class="line">                    var data &#x3D; fulfilled(value);</span><br><span class="line">                    &#x2F;&#x2F; 为了能够让两个promise连接起来</span><br><span class="line">                    resolve(data);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (state &#x3D;&#x3D;&#x3D; &#39;rejected&#39;) &#123;</span><br><span class="line">                    var data &#x3D; rejected(data);</span><br><span class="line">                    &#x2F;&#x2F; 为了能让两个promise连接起来</span><br><span class="line">                    resolve(data);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">                _this.catch(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 执行所有的回调函数</span><br><span class="line">    function resolve(valueNew) &#123;</span><br><span class="line">        value &#x3D; valueNew;</span><br><span class="line">        state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">        execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 执行所有的回调函数</span><br><span class="line">    function reject(valueNew) &#123;</span><br><span class="line">        value &#x3D; valueNew;</span><br><span class="line">        state &#x3D; &#39;rejected&#39;;</span><br><span class="line">        execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function execute() &#123;</span><br><span class="line">        &#x2F;&#x2F; 加入延时机制，防止promise里面有同步函数导致resolve先执行，then还没注册上函数</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            callbacks.forEach(function(cb) &#123;</span><br><span class="line">                value &#x3D; cb(value);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.catch &#x3D; function (e) &#123;</span><br><span class="line">        console.log(JSON.stringify(e));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 经典 实现异步回调</span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1，http的状态码中，499是什么？如何出现499？如何排查解决？&quot;&gt;&lt;a href=&quot;#1，http的状态码中，499是什么？如何出现499？如何排查解决？&quot; class=&quot;headerlink&quot; title=&quot;1，http的状态码中，499是什么？如何出现499？如何排查解决？&quot;&gt;&lt;/a&gt;1，http的状态码中，499是什么？如何出现499？如何排查解决？&lt;/h3&gt;&lt;p&gt;499对应的是“client has closed connection”，客户端请求等待连接已经关闭，这很有可能是因为服务器端处理的时间过长，客户端等的‘不耐烦了’。还可能是因为两次提交post请求过快就会出现499。&lt;br&gt;解决方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端将timeout最大等待时间设置大一些。&lt;/li&gt;
&lt;li&gt;nginx上配置proxt_ignore_client_abort on;</summary>
    
    
    
    <category term="面试题" scheme="https://github.com/liubrook/liubrook.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面试题" scheme="https://github.com/liubrook/liubrook.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JS计算精度丢失问题</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/12/28/JS%E8%AE%A1%E7%AE%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/12/28/JS%E8%AE%A1%E7%AE%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/</id>
    <published>2019-12-28T15:41:05.000Z</published>
    <updated>2020-09-24T02:45:48.517Z</updated>
    
    <content type="html"><![CDATA[<p>JS运算中经常会遇到精度丢失的问题，对于这种情况可以采用以下方法来编写公共方法。</p><a id="more"></a>  <h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jQuery.add &#x3D; function(arg1, arg2) &#123;</span><br><span class="line"></span><br><span class="line">    var r1, r2, m;</span><br><span class="line">    </span><br><span class="line">    try &#123; r1 &#x3D; arg1.toString().split(&quot;.&quot;)[1].length &#125; catch (e) &#123; r1 &#x3D; 0 &#125;</span><br><span class="line">   </span><br><span class="line">    try &#123; r2 &#x3D; arg2.toString().split(&quot;.&quot;)[1].length &#125; catch (e) &#123; r2 &#x3D; 0 &#125;</span><br><span class="line">    </span><br><span class="line">    m &#x3D; Math.pow(10, Math.max(r1, r2))</span><br><span class="line">    </span><br><span class="line">    return (arg1 * m + arg2 * m) &#x2F; m</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">jQuery.cut &#x3D; function(arg1, arg2) &#123;</span><br><span class="line"> </span><br><span class="line">   var r1, r2, m, n;</span><br><span class="line"> </span><br><span class="line">   try &#123; r1 &#x3D; arg1.toString().split(&quot;.&quot;)[1].length &#125; catch (e) &#123; r1 &#x3D; 0 &#125;</span><br><span class="line"></span><br><span class="line">   try &#123; r2 &#x3D; arg2.toString().split(&quot;.&quot;)[1].length &#125; catch (e) &#123; r2 &#x3D; 0 &#125;</span><br><span class="line"></span><br><span class="line">   m &#x3D; Math.pow(10, Math.max(r1, r2));</span><br><span class="line">    &#x2F;&#x2F;last modify by deeka</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;动态控制精度长度</span><br><span class="line"></span><br><span class="line">    n &#x3D; (r1 &gt;&#x3D; r2) ? r1 : r2;</span><br><span class="line"></span><br><span class="line">    return ((arg1 * m - arg2 * m) &#x2F; m).toFixed(n);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.mul &#x3D; function(arg1, arg2) &#123;</span><br><span class="line"></span><br><span class="line">    var m &#x3D; 0, s1 &#x3D; arg1.toString(), s2 &#x3D; arg2.toString();</span><br><span class="line"></span><br><span class="line">    try &#123; m +&#x3D; s1.split(&quot;.&quot;)[1].length &#125; catch (e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    try &#123; m +&#x3D; s2.split(&quot;.&quot;)[1].length &#125; catch (e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    return Number(s1.replace(&quot;.&quot;, &quot;&quot;)) * Number(s2.replace(&quot;.&quot;, &quot;&quot;)) &#x2F; Math.pow(10, m)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">jQuery.div &#x3D; function(arg1, arg2) &#123;</span><br><span class="line"></span><br><span class="line">    var t1 &#x3D; 0, t2 &#x3D; 0, r1, r2;</span><br><span class="line"></span><br><span class="line">    try &#123; t1 &#x3D; arg1.toString().split(&quot;.&quot;)[1].length &#125; catch (e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    try &#123; t2 &#x3D; arg2.toString().split(&quot;.&quot;)[1].length &#125; catch (e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    with (Math) &#123;</span><br><span class="line"></span><br><span class="line">        r1 &#x3D; Number(arg1.toString().replace(&quot;.&quot;, &quot;&quot;))</span><br><span class="line"></span><br><span class="line">        r2 &#x3D; Number(arg2.toString().replace(&quot;.&quot;, &quot;&quot;))</span><br><span class="line"></span><br><span class="line">        return (r1 &#x2F; r2) * pow(10, t2 - t1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;JS运算中经常会遇到精度丢失的问题，对于这种情况可以采用以下方法来编写公共方法。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Linux下安装node</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/12/27/Linux%E4%B8%8B%E5%AE%89%E8%A3%85node/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/12/27/Linux%E4%B8%8B%E5%AE%89%E8%A3%85node/</id>
    <published>2019-12-27T09:05:45.000Z</published>
    <updated>2020-10-07T09:37:07.171Z</updated>
    
    <content type="html"><![CDATA[<p>今天在学习docker方面的知识，需要在服务器上安装node和npm，安装过程中碰到了一些问题，做一下记录。</p><a id="more"></a>  <h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>服务器系统：CentOS 7.6 64位</p><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><ul><li>打开node下载地址<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">Node下载</a>。</li><li>选择长期支持版-Linux二进制文件(x64)-(64-bit).(这个根据自己的系统来选择)。</li><li>右键复制链接地址。</li><li>打开服务器- cd /usr/local (这个看你习惯把这些工具安装到哪里)。</li><li>wget <a href="https://nodejs.org/dist/v12.18.4/node-v12.18.4-linux-x64.tar.xz(这里是你刚才复制的链接地址)。" target="_blank" rel="noopener">https://nodejs.org/dist/v12.18.4/node-v12.18.4-linux-x64.tar.xz(这里是你刚才复制的链接地址)。</a></li><li>下载完成后 tar xf node-v12.18.4-linux-x64.tar.xz(解压)</li><li>解压后把Node的路径链接到环境里</li><li>export NODE_HOME=/usr/local/node-v12.18.4-linux-x64/bin(注意这里是你安装的版本，不要搞错了)</li><li>export PATH=$NODE_HOME:$PATH</li></ul><p>这个时候你用node -v或者npm -v就可以查看了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天在学习docker方面的知识，需要在服务器上安装node和npm，安装过程中碰到了一些问题，做一下记录。&lt;/p&gt;</summary>
    
    
    
    <category term="Node" scheme="https://github.com/liubrook/liubrook.github.io/categories/Node/"/>
    
    
    <category term="Node" scheme="https://github.com/liubrook/liubrook.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序常见问题(1)</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/12/24/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-1/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/12/24/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-1/</id>
    <published>2019-12-24T01:54:28.000Z</published>
    <updated>2020-09-24T02:45:30.045Z</updated>
    
    <content type="html"><![CDATA[<p>以下是在做小程序开发过程中碰到的一些常见问题.</p><a id="more"></a>  <p>1、如果你在微信开发者工具中发现并没有换行，不要惊讶，利用真机预览一下，就可以看到效果了。<br>接下来看看代码，其实很简单，代码中使用了大家熟知的\r\n</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wx.showModal(&#123;</span><br><span class="line">    title: &#39;提示&#39;,</span><br><span class="line">    content: &#39;第一行内容\r\n第二行内容\r\n第三行内容\r\n第四行内容&#39;,</span><br><span class="line">    success: function (res) &#123; </span><br><span class="line">    if (res.confirm) &#123;</span><br><span class="line">            console.log(&#39;用户点击确定&#39;)</span><br><span class="line">        &#125; else if (res.cancel) &#123;</span><br><span class="line">            console.log(&#39;用户点击取消&#39;)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2、使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button::after&#123; border: none; &#125;</span><br></pre></td></tr></table></figure><p>来去除边框</p><p>3、text自动换行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word-break: keep-all;</span><br><span class="line">word-wrap: break-word</span><br></pre></td></tr></table></figure><p>4、弹出框禁止底层页面滚动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catchtouchmove&#x3D;&quot;true&quot;</span><br></pre></td></tr></table></figure><p>开发者工具上测试无效，真机有效</p><p>5、微信小程序隐藏scroll-view滚动条的简单实现就是在wxss里加入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">::-webkit-scrollbar&#123;</span><br><span class="line">  width: 0;</span><br><span class="line">  height: 0;</span><br><span class="line">  color: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;以下是在做小程序开发过程中碰到的一些常见问题.&lt;/p&gt;</summary>
    
    
    
    <category term="微信小程序" scheme="https://github.com/liubrook/liubrook.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="https://github.com/liubrook/liubrook.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript-15-DOM-4</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/12/20/Javascript-15-DOM-4/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/12/20/Javascript-15-DOM-4/</id>
    <published>2019-12-20T14:34:35.000Z</published>
    <updated>2020-09-24T02:46:40.279Z</updated>
    
    <content type="html"><![CDATA[<h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>为了让开发人员更方便地控制页面，“DOM2级遍历和范围”模块定义了“范围”(range)接口。通过范围可以选择文档中的一个区域，而不必考虑修改节点的界限。</p><a id="more"></a>  <h4 id="DOM中的范围"><a href="#DOM中的范围" class="headerlink" title="DOM中的范围"></a>DOM中的范围</h4><p>DOM2级在Document类型中定义了createRange()方法。在兼容DOM的浏览器中，这个方法属于document对象。使用hasFeature()或者直接检测该方法，都可以确定浏览器是否支持范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var supportsRange &#x3D; document.implementation.hasFeature(&quot;Range&quot;, &quot;2.0&quot;);</span><br><span class="line">var alsoSupportsRange &#x3D; (typeof document.createRange &#x3D;&#x3D; &quot;function&quot;);</span><br><span class="line">&#x2F;&#x2F; 如果浏览器支持，那么就可以使用createRange()来创建DOM范围。</span><br><span class="line">var range &#x3D; document.createRange();</span><br></pre></td></tr></table></figure><p>新创建的范围也直接与创建它的文档关联在一起，不能用于其他文档。创建了范围之后，接下来就可以使用它在后台选择文档中的特定部分。而创建范围并设置了其位置之后，还可以针对范围的内容执行很多种操作，从而实现对底层DOM树的更精细的控制。</p><p>每个范围由一个Range类型的实例表示，这个实例拥有很多属性和方法。</p><ul><li>startContainer:包含范围起点的节点(即选区中第一个节点的父节点)。</li><li>startOffset：范围在startContainer中起点的偏移量。如果startContainer是文本姐弟哪、注释节点或CDATA节点，那么startOffset就是范围起点之前跳过的字符数量。否则。startOffset就是范围中第一子节点的索引。</li><li>endContainer：包含范围终点的节点(即选区中最后一个节点的父节点)。</li><li>endOffset：范围在endContainer中终点的偏移量(与startOffset遵循相同的取值规则)。</li><li>commonAncestorContainer: startContainer和endContainer共同的祖先节点在文档树中位置最深的那个。<br>在把防伪放到文档中特定的位置时，这些属性都会被赋值。    </li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;范围&quot;&gt;&lt;a href=&quot;#范围&quot; class=&quot;headerlink&quot; title=&quot;范围&quot;&gt;&lt;/a&gt;范围&lt;/h3&gt;&lt;p&gt;为了让开发人员更方便地控制页面，“DOM2级遍历和范围”模块定义了“范围”(range)接口。通过范围可以选择文档中的一个区域，而不必考虑修改节点的界限。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript-15-DOM-3</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/12/15/Javascript-15-DOM-3/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/12/15/Javascript-15-DOM-3/</id>
    <published>2019-12-15T07:16:42.000Z</published>
    <updated>2020-09-15T09:57:09.683Z</updated>
    
    <content type="html"><![CDATA[<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>“DOM2级遍历和范围”模块定义了两个用于辅助完成顺序遍历DOM结构的类型：NodeIterator和TreeWalker。这两个类型能够基于给定的起点对DOM结构执行深度优先(depth-first)的遍历操作。在于DOM兼容的浏览器中都可以访问到这些类型的对象。IE不支持DOM遍历。使用下列代码可以检测浏览器对DOM2级遍历能力的支持情况。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var supportsTraversals &#x3D; document.implementation.hasFeature(&quot;Traversal&quot;, &quot;2.0&quot;);</span><br><span class="line">var supportsNodeIterator &#x3D; (typeof document.createNodeIterator &#x3D;&#x3D; &quot;function&quot;);</span><br><span class="line">var supportsTreeWalker &#x3D; (typeof document.createTreeWalker &#x3D;&#x3D; &quot;function&quot;);</span><br></pre></td></tr></table></figure><p>如前所述，DOM遍历是深度优先的DOM结构遍历，也就是说，移动的方向至少有两个(取决于使用的遍历类型)。遍历以给定节点为根，不可能向上超出DOM树的根节点。</p><h4 id="NodeIterator"><a href="#NodeIterator" class="headerlink" title="NodeIterator"></a>NodeIterator</h4><p>可以使用document.createNodeIterator()方法创建它的新实例。接受以下4个参数。</p><ul><li>root：想要作为搜索起点的树中的节点。</li><li>whatToShow：表示想要访问哪些节点的数字代码。</li><li>filter：是一个NodeFilter对象，或者一个表示应该接受还是拒绝某种特定节点的函数。</li><li>entityReferenceExpansion：布尔值，表示是否要拓展实体引用。这个参数在HTML中没有用，因为其中的实体引用不能拓展。</li></ul><p>whatToShow参数是一个位掩码，通过应用一或多个过滤器(filter)来确定要访问哪些节点。这个参数的值以常量的形式在NodeFilter类型中定义，如下所示：</p><ul><li><p>NodeFilter.SHOW_ALL：显示所有类型的节点。</p></li><li><p>NodeFilter.SHOW_ELEMENT：显示元素节点。</p></li><li><p>NodeFilter.SHOW_ATTRIBUTE：显示特性节点。由于DOM结构原因，实际上不能使用这个值。</p></li><li><p>NodeFilter.SHOW_TEXT：显示文本节点。</p></li><li><p>NodeFilter.SHOW_CDATA_SECTION：显示CDATA节点。对HTML页面没用。</p></li><li><p>NodeFilter.SHOW_ENTITY_REFERENCE：显示实体引用节点。对HTML页面没用。</p></li><li><p>NodeFilter.SHOW_ENTITYE：显示实体节点。对HTML页面没用。</p></li><li><p>NodeFilter.SHOW_PROCESSING_INSTRUCTION：显示处理指令节点。对HTML页面没用。</p></li><li><p>NodeFilter.SHOW_COMMENT：显示注释节点。</p></li><li><p>NodeFilter.SHOW_DOCUEMNT：显示文档节点。</p></li><li><p>NodeFilter.SHOW_DOCUMENT_TYPE：显示文档类型节点。</p></li><li><p>NodeFilter.SHOW_DOCUMENT_FRAGMENT：显示文档片段节点。对HTML页面没用。</p></li><li><p>NodeFilter.SHOW_NOTATION：显示符号节点。对HTML页面没用。</p><p>除了NodeFilter.SHOW_ALL之外，可以使用按位或操作符来组合多个选项。</p><p>可以通过createNodeIterator()方法的filter参数来指定自定义的NodeFilter对象，或者指定一个功能类似节点过滤器(node filter)的函数，每个NOdeFilter对象只有一个方法，即acceptNode()；如果应该访问给定的节点，该方法返回NodeFilter.FILTER_ACCEPT，如果不应该访问给定的节点，该方法返回NodeFilter.FILTER_SKIP。由于NodeFilter是一个抽象的类型，因此不能直接创建它的实例。在必要时，只要创建一个包含acceptNode()方法的对象，然后将这个对象传入createNodeIterator()中即可。</p><p>NodeIterator类型的两个主要方法是nextNode()和previousNode()。顾名思义，在深度优先的DOM子树遍历中，nextNode()方法主要用于向前前进一步，而previousNode()用于向后后退一步。在刚刚创建的NodeIterator对象中，有一个内部指针指向根节点，因此第一次调用nextNode()会返回根节点。当遍历到DOM子树的最后一个节点时，nextNode()返回null。previousNode()方法的工作机制类似。当遍历到DOM子树的最后一个节点，且previousNode()返回根节点之后，再次调用它就会返回null。</p><p>由于nextNode()和previousNode()方法都基于NodeIterator在DOM结构中的内部指针工作，所以DOM结构的变化会反映在遍历的结果中。</p><h4 id="TreeWalker"><a href="#TreeWalker" class="headerlink" title="TreeWalker"></a>TreeWalker</h4><p>TreeWalker是NodeIterator的一个更高级的版本。除了包括nextNode()和previousNode()在内的相同的功能之外，这个类型还提供了下列用于在不同方向上遍历DOM结构的方法。</p><ul><li>parentNode()：遍历到当前节点的父节点。</li><li>firstChild()：遍历到当前节点的第一个子节点。</li><li>lastChild()：遍历到当前节点的最后一个子节点。</li><li>nextSibing()：遍历到当前节点的下一个同辈节点。</li><li>previousSibing()：遍历到当前节点的上一个同辈节点。</li></ul></li></ul><p>创建TreeWalker对象要使用document.createTreeWalker()方法，这个方法接受的4个参数与document.createNodeIterator()方法相同：作为遍历起点的根节点、要显示的节点类型、过滤器、一个表示是否拓展实体引用的布尔值。</p><p>TreeWalker真正强大的地方在于能够在DOM结构中沿任何方向移动。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;遍历&quot;&gt;&lt;a href=&quot;#遍历&quot; class=&quot;headerlink&quot; title=&quot;遍历&quot;&gt;&lt;/a&gt;遍历&lt;/h3&gt;&lt;p&gt;“DOM2级遍历和范围”模块定义了两个用于辅助完成顺序遍历DOM结构的类型：NodeIterator和TreeWalker。这两个类型能够基于给定的起点对DOM结构执行深度优先(depth-first)的遍历操作。在于DOM兼容的浏览器中都可以访问到这些类型的对象。IE不支持DOM遍历。使用下列代码可以检测浏览器对DOM2级遍历能力的支持情况。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript-15-DOM-2</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/12/05/Javascript-15-DOM-2/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/12/05/Javascript-15-DOM-2/</id>
    <published>2019-12-05T14:24:32.000Z</published>
    <updated>2020-09-15T09:56:26.774Z</updated>
    
    <content type="html"><![CDATA[<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p>在HTML中定义样式的方式有3种：</p><ul><li>通过<code>&lt;link/&gt;</code>元素包含外部样式表文件。</li><li>使用<code>&lt;style/&gt;</code>元素定义嵌入式样式。</li><li>使用style特性定义针对特定元素的样式。<a id="more"></a><h4 id="访问元素的样式"><a href="#访问元素的样式" class="headerlink" title="访问元素的样式"></a>访问元素的样式</h4></li></ul><p>任何支持style特性的HTML元素在Javascript中都有一个对应的style属性。这个style对象是CSSStyleDeclaration的实例，包含着通过HTML的style特性指定的所有样式信息，但不包含与外部样式表或嵌入样式表经层叠而来的样式。在style特性中指定的任何CSS属性都将表现为这个style对象的相应属性。对于使用短划线(分割不同词汇，例如background-image)的CSS属性名，必须将其转换成驼峰大小写形式，才能通过Javascript来访问。</p><p>多数情况下，都可以通过简单地转换属性名的格式来实现转换。其中一个不能直接转换的CSS属性就是float。由于float是JavaScript的保留字，因此不能用作属性名。</p><h5 id="DOM样式属性和方法"><a href="#DOM样式属性和方法" class="headerlink" title="DOM样式属性和方法"></a>DOM样式属性和方法</h5><ul><li>cssText：如前所述，通过它能够访问到style特性中的CSS代码。</li><li>length：应用给元素的CSS属性的数量。</li><li>parentRule：表示CSS信息的CSSRule对象。</li><li>getPropertyCSSValue(propertyName)：返回包含给定属性值的CSSValue类型。</li><li>getPropertyPriority(propertyName)：如果给定的属性使用了！important设置，则返回“important”；否则，则返回空字符串。</li><li>getPropertyValue(propertyName)：返回给定属性的字符串值。</li><li>item(index)：返回给定位置的CSS属性的名称。</li><li>removeProperty(propertyName)：从样式中删除给定属性。</li><li>setProperty(propertyName, value, priority)：将给定属性设置为相应的值，并加上优先权标志(“important”或者一个空字符串)。</li></ul><p>通过cssText属性可以访问style特性中的CSS代码。在读取模式下，cssText的值会重写整个styl特性的值；也就是说，以前通过style特性指定的样式信息都将丢失。</p><h5 id="计算的样式"><a href="#计算的样式" class="headerlink" title="计算的样式"></a>计算的样式</h5><p>getComputedStyle()方法接受两个参数：要取得计算样式的元素和一个伪元素字符串。如果不需要伪元素信息，第二个参数可以是null。该方法返回一个CSSStyleDeclaration对象(与style属性的类型相同)，其中包含当前元素的所有计算的样式。</p><p>无论在哪个浏览器中，最重要的一条是要记住所有计算的样式都是只读的；不能修改计算后样式对象中的CSS属性。此外，计算后的样式也包含属于浏览器内部样式表的样式信息，因此任何具有默认值的CSS属性都会表现在计算后的样式中。</p><h4 id="操作样式表"><a href="#操作样式表" class="headerlink" title="操作样式表"></a>操作样式表</h4><p>CSSStyleSheet类型表示的是样式表，包括通过<code>&lt;link&gt;</code>元素包含的样式表和在<code>&lt;style&gt;</code>元素中定义的样式表。它只表示样式表，而不管这些样式表在HTML中是如何定义的。</p><p>CSSStyleSheet继承自StyleSheet，后者可以作为一个基础接口来定义非CSS样式表。从StyleSheet接口继承而来的属性如下：</p><ul><li>disabled：表示样式表是否被禁用的布尔值。这个属性是可读/写的，将这个值设置为true可以禁用样式表。</li><li>href：如果样式表是通过<code>&lt;link&gt;</code>包含的，则是样式表的URL，否则是null；</li><li>media：当前样式表支持的所有媒体类型的集合。与所有DOM集合一样，这个集合也有一个length属性和一个item()方法。也可以使用方括号语法取得集合中特定的项。如果集合是空列表，表示样式表适用于所有媒体。</li><li>ownerNode：指向拥有当前样式表的节点的指针，样式表可能是在HTML中通过<code>&lt;link&gt;</code>或<code>&lt;style&gt;</code>引入的(在XML中可能使用过处理指令引入的)。如果当前样式表是其他样式表通过@import导入的，则这个属性为null。IE不支持这个属性。</li><li>parentStyleSheet：在当前样式表是通过@import导入的情况下，这个属性是一个指向导入它的样式表的指针。</li><li>title：ownerNode中title属性的值。</li><li>type：表示样式表类型的字符串。对CSS样式表而言，这个字符串是“type/css”。<br>除了disabled属性之外，其他属性都是只读的。在支持以上所有这些属性的基础上，CSSStyleSheet类型还支持下列属性和方法：</li><li>cssRules：样式表中包含的样式规则的集合。IE不支持这个属性，但有一个类似的rules属性。</li><li>ownerRule：如果样式表是通过@import导入的，这个属性就是一个指针，指向表示导入的规则，否则，值为null。IE不支持这个属性。</li><li>deleteRule(index)：删除cssRules集合中指定位置的规则。IE不支持这个方法，但支持一个类似的removeRule()方法。</li><li>insertRule(rule，index)：向cssRules中指定的位置插入rule字符串。IE不支持这个方法，但支持一个类似的addRule()方法。</li></ul><p>应用与文档的所有样式表是通过document.styleSheets集合来表示的。通过这个集合的length属性可以获知文档中样式表的数量，而通过方括号语法或item()方法可以访问每一个样式表。</p><h4 id="元素大小"><a href="#元素大小" class="headerlink" title="元素大小"></a>元素大小</h4><h5 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h5><p>偏移量(offset dimension)，包括元素在屏幕上占用的所有可见的空间。元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条、边框大小(不包括外边距)。通过下列4个属性可以取得元素的偏移量：</p><ul><li>offsetHeight：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、(可见的)水瓶滚动条的高度、上边框高度和下边框高度。</li><li>offsetWidth：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、(可见的)垂直滚动条的宽度、左边框宽度和右边框宽度。</li><li>offsetLeft：元素的左外边框至包含元素的左内边框之间的像素距离。</li><li>offsetTop：元素的上外边框至包含元素的上内边框之间的像素距离。</li></ul><h5 id="客户区大小"><a href="#客户区大小" class="headerlink" title="客户区大小"></a>客户区大小</h5><p>元素的客户区大小(client dimension)指的是元素内容及其内边距所占据的空间大小。</p><ul><li>clientWidth：元素内容区宽度加上左右内边距宽度。</li><li>clientHeight：元素内容区高度加上上下内边距高度。</li></ul><h5 id="滚动大小"><a href="#滚动大小" class="headerlink" title="滚动大小"></a>滚动大小</h5><p>滚动大小(scroll dimension)，指的是包含滚动内容的元素的大小。以下4个与滚动大小相关的属性：</p><ul><li>scrollHeight：在没有滚动条的情况下，元素内容的总高度。</li><li>scrollWidth：在没有滚动条的情况下，元素内容的总宽度。</li><li>scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。</li><li>scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。</li></ul><h5 id="确定元素大小"><a href="#确定元素大小" class="headerlink" title="确定元素大小"></a>确定元素大小</h5><p>getBoundingClientRect()方法，该方法返回一个矩形对象，包含4个属性：left、top、right、bottom。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;样式&quot;&gt;&lt;a href=&quot;#样式&quot; class=&quot;headerlink&quot; title=&quot;样式&quot;&gt;&lt;/a&gt;样式&lt;/h3&gt;&lt;p&gt;在HTML中定义样式的方式有3种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过&lt;code&gt;&amp;lt;link/&amp;gt;&lt;/code&gt;元素包含外部样式表文件。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;&amp;lt;style/&amp;gt;&lt;/code&gt;元素定义嵌入式样式。&lt;/li&gt;
&lt;li&gt;使用style特性定义针对特定元素的样式。</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript-15-DOM-1</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/12/04/Javascript-15-DOM-1/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/12/04/Javascript-15-DOM-1/</id>
    <published>2019-12-04T11:33:10.000Z</published>
    <updated>2020-09-15T09:55:41.447Z</updated>
    
    <content type="html"><![CDATA[<p>DOM1级主要定义的是HTML和XML文档的底层结构。DOM2和DOM3级则在这个结构的基础上引入了更多的交互能力，也支持了更高级的XML特性。为此，DOM2和DOM3级分为许多模块(模块之间具有某种关联)，分别描述了DOM的某个非常具体的子集。这些模块如下：</p><ul><li>DOM2级核心：在1级核心基础上构建，为节点添加了更多的方法和属性。</li><li>DOM2级视图：为文档定义了基于样式信息的不同视图。</li><li>DOM2级事件：说明了如何使用事件与DOM文档交互。</li><li>DOM2级样式：定义了如何以编程方式来访问和改变CSS样式信息。</li><li>DOM2级遍历和范围：引入了遍历DOM文档和选择其特定部分的新接口。</li><li>DOM2级HTML：在1级HTML基础上构建，添加了更多属性、方法、新接口。<a id="more"></a><h3 id="DOM变化"><a href="#DOM变化" class="headerlink" title="DOM变化"></a>DOM变化</h3></li></ul><p>DOM2级和3级的目的在于扩展DOM API，以满足操作XML的所有需求，同时提供更好的错误处理及特性检测能力。从某种意义上讲，实现这一目的很大程度意味着对命名空间的支持。“DOM2级核心”没有引入新类型，它只是在DOM1级的基础上通过增加新方法和新属性来增加了既有类型。“DOM3级核心”同样增强了既有类型，但也引入了一些新类型，</p><p>类似地，“DOM2 级视图”和“DOM2 级HTML”模块也增强了DOM 接口，提供了新的属性和方法。由于这两个模块很小，因此我们将把它们与“DOM2 级核心”放在一起，讨论基本JavaScript 对象的变化。可以通过下列代码来确定浏览器是否支持这些DOM 模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var supportsDOM2Core &#x3D; document.implementation.hasFeature(&quot;Core&quot;, &quot;2.0&quot;);</span><br><span class="line">var supportsDOM3Core &#x3D; document.implementation.hasFeature(&quot;Core&quot;, &quot;3.0&quot;);</span><br><span class="line">var supportsDOM2HTML &#x3D; document.implementation.hasFeature(&quot;HTML&quot;, &quot;2.0&quot;);</span><br><span class="line">var supportsDOM2Views &#x3D; document.implementation.hasFeature(&quot;Views&quot;, &quot;2.0&quot;);</span><br><span class="line">var supportsDOM2XML &#x3D; document.implementation.hasFeature(&quot;XML&quot;, &quot;2.0&quot;);</span><br></pre></td></tr></table></figure><h4 id="针对XML命名空间的变化"><a href="#针对XML命名空间的变化" class="headerlink" title="针对XML命名空间的变化"></a>针对XML命名空间的变化</h4><p>有了XML命名空间，不同XML文档的元素就可以混合在一起，共同构成格式良好的文档，而不必担心发生命名冲突。从技术上说，HTML不支持XML命名空间，但XHTML支持XML命名空间。</p><p>XHTML的命名空间是<a href="http://www.w3.org/1999/xhtml，在任何格式良好XHTML页面中，都应该将其包含在`" target="_blank" rel="noopener">http://www.w3.org/1999/xhtml，在任何格式良好XHTML页面中，都应该将其包含在`</a><html>`元素中，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;Example XHTML page&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        Hello world!</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h5 id="Node类型的变化"><a href="#Node类型的变化" class="headerlink" title="Node类型的变化"></a>Node类型的变化</h5><p>在DOM2级中，Node类型包含下列特定于命名空间的属性。</p><ul><li>localName：不带命名空间前缀的节点名称。</li><li>namespaceURI：命名空间URI或者(在未指定的情况下是)null.</li><li>prefix：命名空间前缀或者(在未指定的情况下是)null。</li></ul><p>DOM3级在此基础上更进一步，又引入了下列与命名空间有关的方法。</p><ul><li>isDefaultNamespace(namespaceURI)：在指定的namespaceURI是当前节点的默认命名空间的情况下返回true。</li><li>lookupNamespaceURI(prefix)：返回给定prefix的命名空间。</li><li>lookupPrefix(namespaceURI)：返回给定namespaceURI的前缀。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">alert(document.body.isDefaultNamespace(&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;); &#x2F;&#x2F;true</span><br><span class="line">&#x2F;&#x2F;假设svg 中包含着对&lt;s:svg&gt;的引用</span><br><span class="line">alert(svg.lookupPrefix(&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot;)); &#x2F;&#x2F;&quot;s&quot;</span><br><span class="line">alert(svg.lookupNamespaceURI(&quot;s&quot;)); &#x2F;&#x2F;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Document类型的变化"><a href="#Document类型的变化" class="headerlink" title="Document类型的变化"></a>Document类型的变化</h5><p>DOM2级中的Document类型也发生了变化，包含下列与命名空间有关的方法。</p><ul><li>createElementNS(namespaceURI, tagName)：使用给定的tagName创建一个属于命名空间namespaceURI的新元素。</li><li>createAttributeNS(namespaceURI, attributeName)：使用给定的attributeName创建一个属于命名空间namespaceURI的新特性。</li><li>getElementsBytagNameNS(namespaceURI, tagName)：返回属于命名空间namespaceURI的tagName元素的NodeList。</li></ul><p>使用这些方法时需要传入表示命名空间的URI(而不是命名空间前缀)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建一个新的SVG 元素</span><br><span class="line">var svg &#x3D; document.createElementNS(&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot;,&quot;svg&quot;);</span><br><span class="line">&#x2F;&#x2F;创建一个属于某个命名空间的新特性</span><br><span class="line">var att &#x3D; document.createAttributeNS(&quot;http:&#x2F;&#x2F;www.somewhere.com&quot;, &quot;random&quot;);</span><br><span class="line">&#x2F;&#x2F;取得所有XHTML 元素</span><br><span class="line">var elems &#x3D; document.getElementsByTagNameNS(&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;, &quot;*&quot;);tps:&#x2F;&#x2F;blog.csdn.net&#x2F;Jane617_min&#x2F;article&#x2F;details&#x2F;49683873</span><br></pre></td></tr></table></figure><h5 id="Element类型的变化"><a href="#Element类型的变化" class="headerlink" title="Element类型的变化"></a>Element类型的变化</h5><ul><li>getAttributeNS(namespaceURI,localName)：取得属于命名空间namespaceURI 且名为localName 的特性。</li><li>getAttributeNodeNS(namespaceURI,localName)：取得属于命名空间namespaceURI 且名为localName 的特性节点。</li><li>getElementsByTagNameNS(namespaceURI, tagName)：返回属于命名空间namespaceURI的tagName 元素的NodeList。</li><li>hasAttributeNS(namespaceURI,localName)：确定当前元素是否有一个名为localName的特性，而且该特性的命名空间是namespaceURI。注“DOM2 级核心”也增加了一个hasAttribute()方法，用于不考虑命名空间的情况。</li><li>removeAttriubteNS(namespaceURI,localName)：删除属于命名空间namespaceURI 且名为localName 的特性。</li><li>setAttributeNS(namespaceURI,qualifiedName,value)：设置属于命名空间namespaceURI 且名为qualifiedName 的特性的值为value。</li><li>setAttributeNodeNS(attNode)：设置属于命名空间namespaceURI 的特性节点。<br>除了第一个参数之外，这些方法与DOM1 级中相关方法的作用相同；第一个参数始终都是一个命名空间URI。</li></ul><h5 id="NameNodeMap类型的变化"><a href="#NameNodeMap类型的变化" class="headerlink" title="NameNodeMap类型的变化"></a>NameNodeMap类型的变化</h5><p>NamedNodeMap 类型也新增了下列与命名空间有关的方法。由于特性是通过NamedNodeMap 表示的，因此这些方法多数情况下只针对特性使用。</p><ul><li>getNamedItemNS(namespaceURI,localName)：取得属于命名空间namespaceURI 且名为localName 的项。</li><li>removeNamedItemNS(namespaceURI,localName)：移除属于命名空间namespaceURI 且名为localName 的项。</li><li>setNamedItemNS(node)：添加node，这个节点已经事先指定了命名空间信息。<br>由于一般都是通过元素访问特性，所以这些方法很少使用。</li></ul><h4 id="其他方面的变化"><a href="#其他方面的变化" class="headerlink" title="其他方面的变化"></a>其他方面的变化</h4><h5 id="DocumentType类型的变化"><a href="#DocumentType类型的变化" class="headerlink" title="DocumentType类型的变化"></a>DocumentType类型的变化</h5><p>DOcumentType类型新增了3个属性：publicId、systemId、internalSubset。其中，前两个属性表示的是文档类型声明中的两个信息段，这两个信息段在DOM1级中是没有办法访问到的。</p><h5 id="Document类型的变化-1"><a href="#Document类型的变化-1" class="headerlink" title="Document类型的变化"></a>Document类型的变化</h5><p>Document类型的变化中唯一与命名空间无关的方法是importNode()。这个方法的用途是从一个文档中取得一个节点，然后将其导入另一个文档，使其成为这个文档结构的一部分。需要注意的是，每个节点都有一个ownerDocument属性，表示所属文档。如果调用appendChild()时传入的节点属于不同的文档(ownerDocument属性的值不一样)，则会导致错误。但在调用importNode()时传入不同文档的节点则会返回一个新节点，这个新节点的所有权归当前文档所有。</p><p>importNode()方法与Element的cloneNode()方法非常相似，它接受两个参数：要复制的节点和一个表示是否复制子节点的布尔值。返回的结果是原来节点的副本，但能够在当前文档中使用。</p><p>createDocumenttype()方法用于创建一个新的Documenttype节点，接受三个参数：文档类型名称、publicId、systemId。由于既有文档的文档类型不能改变，因此createDocumentType()只在创建新文档时有用；创建新文档需要用到createDocument()方法。这个方法接受3个参数：针对文档中元素的namespaceURI、文档元素的标签名、新文档的文档类型。</p><p>createHTML-Document()方法用来创建一个完整的HTML文档，包括<code>&lt;html&gt;、&lt;head&gt;、&lt;title&gt;、&lt;body&gt;</code>元素。这个方法只接受一个参数，即新创建文档的标题(放在<code>&lt;title&gt;</code>元素中的字符串)，返回新的HTML文档。</p><h5 id="Node类型的变化-1"><a href="#Node类型的变化-1" class="headerlink" title="Node类型的变化"></a>Node类型的变化</h5><p>Node类型中唯一与命名空间无关的变化，就是添加了isSupported()方法。与DOM1级为document.implementation引入的hasFeature()方法类似，isSupported()方法用于确定当前节点具有什么能力。这个方法接受两个参数：特性名和版本号。如果浏览器实现了相应特性，而且能够基于给定节点执行该特性，isSupported()就返回true。由于不同实现在决定对什么特性返回true或false时并不一致，这个方法同样也村子啊与hasFeature()方法相同的问题。为此，建议在确定某个特性是否可用时，最好还是使用能力检测。</p><p>DOM3级引入了两个辅助比较节点的方法：isSameNode()和isEuqalNode()。这两个方法都接受一个节点参数，并在传入节点与引用的节点相同或相等时返回true。所谓相同，值得时两个节点引用的时同一个对象。所谓相等，指的是两个节点是相同的类型，具有相等的属性(nodeName、nodeValue等)，而且它们的attributes和childNodes属性也相等(相同位置包含相同的值)。</p><p>setUserData()方法会将数据指定给节点，它接受三个参数：要设置的键、实际的数据和处理函数。</p><h5 id="框架的变化"><a href="#框架的变化" class="headerlink" title="框架的变化"></a>框架的变化</h5><p>框架和内嵌框架分别用HTMLFrameElement和HTMLIFrameElement表示，它们在DOM2级中都有了一个新属性-contentDocument。这个属性包含一个指针，指向表示框架内容的文档对象。在此之前，无法直接通过元素取得这个文档对象</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;DOM1级主要定义的是HTML和XML文档的底层结构。DOM2和DOM3级则在这个结构的基础上引入了更多的交互能力，也支持了更高级的XML特性。为此，DOM2和DOM3级分为许多模块(模块之间具有某种关联)，分别描述了DOM的某个非常具体的子集。这些模块如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOM2级核心：在1级核心基础上构建，为节点添加了更多的方法和属性。&lt;/li&gt;
&lt;li&gt;DOM2级视图：为文档定义了基于样式信息的不同视图。&lt;/li&gt;
&lt;li&gt;DOM2级事件：说明了如何使用事件与DOM文档交互。&lt;/li&gt;
&lt;li&gt;DOM2级样式：定义了如何以编程方式来访问和改变CSS样式信息。&lt;/li&gt;
&lt;li&gt;DOM2级遍历和范围：引入了遍历DOM文档和选择其特定部分的新接口。&lt;/li&gt;
&lt;li&gt;DOM2级HTML：在1级HTML基础上构建，添加了更多属性、方法、新接口。</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript-14-DOM-4</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/11/28/Javascript-14-DOM-4/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/11/28/Javascript-14-DOM-4/</id>
    <published>2019-11-28T02:14:18.000Z</published>
    <updated>2020-09-15T09:54:55.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h3><p>注释在DOM中是通过Comment类型来表示的。Comment节点具有下列特征：</p><a id="more"></a><ul><li>nodeType的值为8；</li><li>nodeName的值为“#comment”；</li><li>nodeValue的值是注释的内容；</li><li>parentNode可能是Document或Element；</li><li>不支持(没有)子节点；</li></ul><p>Comment类型与Text类型继承自相同的基类，因此它拥有除了splitText()之外所有字符串操作方法。与Text类型相似，也可以通过nodeValue或data属性来取得注释的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注释节点可以通过其父节点来访问，以下面的代码为例</span><br><span class="line">&lt;div id&#x3D;&quot;myDiv&quot;&gt;&lt;!-- A comment --&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#x2F;&#x2F; 在此，注释节点是&lt;div&gt;元素的一个子节点，因此可以通过下面的代码来访问它</span><br><span class="line">var div &#x3D; document.getElementById(&#39;myDiv&#39;);</span><br><span class="line">var comment &#x3D; div.firstChild;</span><br><span class="line">alert(comment.data); &#x2F;&#x2F; &quot;A comment&quot;</span><br></pre></td></tr></table></figure><p>使用document.createComment()并为其传递注释文本也可以创注释节点，如下面的例子所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var comment &#x3D; document.createComment(&quot;A comment&quot;);</span><br></pre></td></tr></table></figure><h3 id="CDATASection类型"><a href="#CDATASection类型" class="headerlink" title="CDATASection类型"></a>CDATASection类型</h3><p>CDATASection类型只针对基于XML的文档，表示的是CDATA区域。与Comment类似，继承自Text类型，因此拥有除了splitText()之外的所有字符串操作方法。具有以下特征：</p><ul><li>nodeType的值为4；</li><li>nodeName的值为“#cdata-section”；</li><li>nodeValue的值是CDATA区域中的内容；</li><li>parentNode可能是Document或Element；</li><li>不支持(没有)子节点；</li></ul><p>在真正的XML文档中，可以使用document.createCDATASection()来创建CDATA区域，只需为其传入节点的内容即可。</p><h3 id="DucumentType类型"><a href="#DucumentType类型" class="headerlink" title="DucumentType类型"></a>DucumentType类型</h3><p>该类型在Web浏览器中并不常用，仅有Firefox、Safari、Opera支持。DocumentType包含着与文档的doctype有关的所有信息，它具有下列特征：</p><ul><li>nodeType的值为10;</li><li>nodeName的值为doctype的名称；</li><li>nodeValue的值为null；</li><li>parentNode是Document；</li><li>不支持(没有)子节点；</li></ul><h3 id="DocumentFragment类型"><a href="#DocumentFragment类型" class="headerlink" title="DocumentFragment类型"></a>DocumentFragment类型</h3><p>在所有节点类型中，只有DocumentFragment在文档中没有对应的标记。Dom规定文档片段(document fragment)是一种“轻量级”的文档，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。DocumentFragment节点具有下列特征：</p><ul><li>nodeType的值为11;</li><li>nodeName的值为“#document-fragment”;</li><li>nodeValue的值为null；</li><li>parentNode的值为null；</li><li>子节点可以是Element、ProcessingInstruction、Comment、Text、CDATASection或EntityReference。</li></ul><h3 id="Attr类型"><a href="#Attr类型" class="headerlink" title="Attr类型"></a>Attr类型</h3><p>元素的特性在DOM中以Attr类型来表示。在所有浏览器中(包括IE8)，都可以访问Attr类型的构造函数和原型。从技术角度讲，特性就是存在于元素的attributes属性中的节点。特性节点具有下列特征：</p><ul><li>nodeType的值为2；</li><li>nodeName的值是特性的名称；</li><li>nodeValue的值是特性的值；</li><li>parentNode的值为null；</li><li>在HTML中不支持(没有)子节点；</li><li>在XML中子节点可以是Text或EntityReference。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Comment类型&quot;&gt;&lt;a href=&quot;#Comment类型&quot; class=&quot;headerlink&quot; title=&quot;Comment类型&quot;&gt;&lt;/a&gt;Comment类型&lt;/h3&gt;&lt;p&gt;注释在DOM中是通过Comment类型来表示的。Comment节点具有下列特征：&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript-14-DOM-3</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/11/24/Javascript-14-DOM-3/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/11/24/Javascript-14-DOM-3/</id>
    <published>2019-11-24T15:53:29.000Z</published>
    <updated>2020-09-15T09:53:56.064Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h3><p>Element类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。具有以下特征：</p><a id="more"></a><ul><li>nodeType的值为1；</li><li>nodeName的值为元素的标签名；</li><li>nodeValue的值为null；</li><li>parentNode可能是Document或Element；</li><li>其子节点可能是Element、Text、Comment、ProcessingInstruction、CDATASection或EnttyReference。</li></ul><p>要访问元素的标签名，可以使用nodeName属性，也可以使用tagName属性；这两个属性会返回相同的值。</p><h4 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h4><p>所有HTML元素都由HTMLElement类型表示，不是直接通过这个类型，也是通过它的子类型来表示。HTMLElement类型直接继承自Element并添加了一些属性。添加的这些属性分别对应于每个HTML元素中都存在的下列标准特性：</p><ul><li>id，元素在文档中的唯一标识符。</li><li>title，有关元素的附加说明信息，一版通过工具提示条显示出来。</li><li>lang，元素内容的语言代码，很少使用。</li><li>dir，语言的方向，值为“ltr”(left-to-right，从左至右)或“rtl”(right-to-left，从右至左)，也很少使用。</li><li>className，与元素的class特性对应，即为元素指定的CSS类。没有讲这个属性命名为class，是因为class是JS的保留字。</li></ul><h4 id="取得特性"><a href="#取得特性" class="headerlink" title="取得特性"></a>取得特性</h4><p>每个元素都有一或多个特性，这些特性的用途是给出相应元素或其内容的附加信息，操作特性的DOM方法主要有三个，分别是getAttribute()、serAttribute()、removeAttribute()。这三个方法可以针对任何特性使用，包括那些以HTMLElement类型属性定义的特性。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var div &#x3D; document.getElementById(&#39;myDiv&#39;);</span><br><span class="line">alert(div.getAttribute(&#39;id&#39;)); &#x2F;&#x2F; &quot;myDiv&quot;</span><br><span class="line">alert(div.getAttribute(&#39;class&#39;)); &#x2F;&#x2F; &quot;bd&quot;</span><br><span class="line">alert(div.getAttribute(&#39;title&#39;)); &#x2F;&#x2F; &quot;Body text&quot;</span><br><span class="line">alert(div.getAttribute(&#39;lang&#39;)); &#x2F;&#x2F; &quot;en&quot;</span><br><span class="line">alert(div.getAttribute(&#39;dir&#39;)); &#x2F;&#x2F; &quot;ltr&quot;</span><br></pre></td></tr></table></figure><p>注意，传递给getAttribute()的特性名与实际的特性名相同。因此想要得到class特性值，应该传入“class”而不是“className”，后者只有在通过对象属性访问特性时采用。如果给定名称的特性不存在，则返回null。</p><p>特性的名称是不区分大小写的，即“ID”和‘id’代表的是同一个特性。另外也要注意，根据HTML5规范，自定义特性应该加上data-前缀以便验证。</p><p>有两类特殊的特性，它们虽然有对应的属性名，但属性的值与通过getAttribute()返回的值并不相同。第一类特性就是style，用于通过CSS为元素指定样式。在通过getAttribute()访问时，返回的style特性值中包含的是CSS文本，而通过属性来访问它则会返回一个对象，由于style属性是用于以编程方式访问元素样式的，因此并没有直接映射到style特性。</p><p>第二类与众不同的特性是onclick这样的事件处理程序。当在元素上使用时，onclick特性中包含的是JS代码，如果通过getAttribute()访问，则会返回相应代码的字符串。而在访问onclick属性时，则会返回一个JS函数(如果未在元素中指定相应特性，则返回null)。这是因为onclick及其他事件处理程序本身就应该被赋予函数值。</p><h4 id="设置特性"><a href="#设置特性" class="headerlink" title="设置特性"></a>设置特性</h4><p>setAttribute()，这个方法接受两个参数：要设置的特性名和值。如果特性已经存在，会以指定的值替换现有的值；如果特性不存在，则会创建该属性并设置相应的值。</p><p>removeAttribute()，用于彻底删除元素的特性，调用这个方法不仅会清楚特性的值，而且也会从元素中完全删除特性。</p><h4 id="attributes属性"><a href="#attributes属性" class="headerlink" title="attributes属性"></a>attributes属性</h4><p>Element类型是使用attributes属性的唯一一个DOM节点类型。attributes属性中包含一个NameNodeMap，与nodeList类似，也是一个“动态”集合。元素的每一个特性都由一个Attr节点表示，每个节点都保存在NameNodeMap对象中。NameNodeMap对象拥有下列方法。</p><ul><li>getNamedItem(name)：返回nodeName属性等于name的节点。</li><li>removeNamedItem(name)：从列表中移除nodeName属性等于name的节点。</li><li>setNamedItem(node)：向列表中添加节点，以节点的nodeName属性为索引。</li><li>item(pos)：返回位于数字pos位置处的节点，</li></ul><h4 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h4><p>使用document.createElement()方法可以创建新元素，这恶搞方法只接受一个参数，即要创建元素的标签名。这个标签名在HTML文档中不区分大小写，而在XML(包括XHTML)文档中，则是区分大小写的。</p><p>在使用createElement()方法创建新元素的同时，也为新元素设置了ownerDocument属性。此外，还可以操作元素的特性，为它添加更多的子节点，以及执行其他操作。在新元素上设置这些特性只是给它们赋予了相应的信息。由于新元素尚未被添加到文档树中，因此设置这些特性不会影响浏览器的显示。要把新元素添加到文档树，可以使用appendChild()、insertBefore()、replaceChild()方法。</p><p>一旦将元素添加到文档树中，浏览器就会立即呈现该元素。此后，对这个元素所作的任何修改都会实时反映在浏览器中。</p><h4 id="元素的子节点"><a href="#元素的子节点" class="headerlink" title="元素的子节点"></a>元素的子节点</h4><p>元素可以有任意数目的子节点和后代节点，因为元素可以是其他元素的子节点。元素的childNodes属性中包含了它的所有子节点，这些子节点可能是元素、文本节点、注释、处理指令。</p><h3 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h3><p>文本节点由Text类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的HTML字符，但不能包含HTML代码。Text节点具有以下特征：</p><ul><li>nodeType的值为3；</li><li>nodeName的值为“#text”；</li><li>nodeValue的值为节点所包含的文本；</li><li>parentNode是一个Element；</li><li>不支持子节点</li></ul><p>可以通过nodeValue属性或data属性访问Text节点中包含的文本，这两个属性中包含的值相同。对nodeValue的修改也会通过data反映出来，反之亦然。使用下列方法可以操作节点中的文本。</p><ul><li>appendData(text): 将text添加到节点的末尾。</li><li>deleteData(offset, count)：从offset指定的位置开始嘶喊出count个字符。</li><li>insertData(offset, text)：在offset指定的位置插入text。</li><li>replaceData(offset, count, text)：用text替换从offset指定的位置开始到offset+count为止处的文本。</li><li>splitText(offset)：从offset指定的位置将当前文本节点分成两个文本节点。</li><li>substringData(offset, count)：提取从offset指定的位置开始到offset+count为止处的字符串。</li></ul><h4 id="创建文本节点"><a href="#创建文本节点" class="headerlink" title="创建文本节点"></a>创建文本节点</h4><p>document.createTextNode()创建新文本节点，这个方法接受一个参数–要插入节点中的文本。与设置已有文本节点的值一样，作为参数的文本也将按照HTML或XML的格式进行编码。</p><h4 id="规范化文本节点"><a href="#规范化文本节点" class="headerlink" title="规范化文本节点"></a>规范化文本节点</h4><p>DOM文档中存在相邻的同胞文本节点很容易导致混乱，因为分不清哪个文本节点表示哪个字符串。另外，DOM文档中出现相邻文本节点的情况也不在少数，于是就催生了一个能够将相邻文本节点合并的方法。这个方法是由Node类型定义的(因而在所有节点类型中都存在)，名叫normalize()。如果在一个包含两个或多个文本节点的父元素上调用normalize()方法，则会将所有文本节点合并成一个节点，结果节点的nodeValue等于将合并前每个文本节点的nodevalue值拼接起来的值。</p><p>浏览器在解析文档时永远不会创建相邻的文本节点。这种情况只会作为执行DOM操作的结果出现。</p><h4 id="分割文本节点"><a href="#分割文本节点" class="headerlink" title="分割文本节点"></a>分割文本节点</h4><p>splitText()：将一个文本节点分成两个文本节点，即按照执行的位置分割nodeValue值。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点与愿节点的parentNode相同。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Element类型&quot;&gt;&lt;a href=&quot;#Element类型&quot; class=&quot;headerlink&quot; title=&quot;Element类型&quot;&gt;&lt;/a&gt;Element类型&lt;/h3&gt;&lt;p&gt;Element类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。具有以下特征：&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript-14-DOM-2</title>
    <link href="https://github.com/liubrook/liubrook.github.io/2019/11/18/Javascript-14-DOM-2/"/>
    <id>https://github.com/liubrook/liubrook.github.io/2019/11/18/Javascript-14-DOM-2/</id>
    <published>2019-11-18T13:33:54.000Z</published>
    <updated>2020-09-15T09:53:13.653Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h3><p>JS通过Document类型表示文档。在浏览器中，document对象是HTMLDocument(继承自Document类型)的一个实例，表示整个HTML页面。其中，document对象是window对象的一个属性，因此可以将其作为全局对象来访问，Document节点具有以下特征：</p><a id="more"></a><ul><li>nodeType的值为9；</li><li>nodeName的值为“#document”；</li><li>nodeValue的值为null；</li><li>parentNode的值为null；</li><li>ownerDocument的值为null；</li><li>其子节点可能是一个DocumentType(最多一个)、Element(最多一个)、ProcessingInstruction或Comment。</li></ul><p>Document类型可以表示HTML页面或者其他基于XML的文档。不过，最常见的应用还是作为HTMLDocument实例的document对象。通过这个文档对象，不仅可以取得与页面有关的信息，而且还能操作页面的外观及其底层结构。</p><h4 id="文档的子节点"><a href="#文档的子节点" class="headerlink" title="文档的子节点"></a>文档的子节点</h4><p>虽然DOM标准规定Document节点的子节点可以是DocumentType、Element、ProcessingInstruction或Comment，但还有两个内置的访问其子节点的快捷方式。第一个就是DocumentElement属性，该属性始终指向HTML页面中的<code>&lt;html&gt;</code>元素。另一个就是通过ChildNodes列表访问文档元素。</p><p>作为HTMLDocument的实例，document对象还有一个body属性，直接指向<code>&lt;body&gt;</code>元素。</p><p>所有浏览器都支持document.documentElement和document.body属性。</p><h4 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h4><p>作为HTMLDocument的一个实例，document对象还有一些标准的Document对象所没有的属性。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 取得文档标题</span><br><span class="line">var originalTitle &#x3D; document.title;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置文档标题</span><br><span class="line">document.title &#x3D; &quot;New page title&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取得完整的URL</span><br><span class="line">var url &#x3D; document.URL;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取得域名</span><br><span class="line">var domain &#x3D; document.domain;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取得来源页面的URL</span><br><span class="line">var referrer &#x3D; document.referrer;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 假设页面来自p2p.wrox.com域</span><br><span class="line">document.domain &#x3D; &quot;wrox.com&quot;; &#x2F;&#x2F; 成功</span><br><span class="line"></span><br><span class="line">document.domain &#x3D; &quot;nczonline.net&quot;; &#x2F;&#x2F; 出错</span><br></pre></td></tr></table></figure><h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><p>Document类型提供了两个方法。</p><p>1，getElementById()，接收一个参数：要取得元素的ID，找到则返回该元素，不存在则返回null。注意，这里的ID必须与页面中元素的id严格匹配，包括大小写。</p><p>2，getElementsByTagName()，接收一个参数：要取得元素的标签名，而返回的是包含零或多个元素的NodeList。</p><p>只有HTMLDocument类型才有的方法：getElementsByName()，返回带有给定name特性的所有元素。</p><h4 id="特殊集合"><a href="#特殊集合" class="headerlink" title="特殊集合"></a>特殊集合</h4><ul><li>document.anchors，包含文档中所有带name特性的<code>&lt;a&gt;</code>元素。</li><li>document.applets，包含文档中所有的<code>&lt;applet&gt;</code>元素，因为不再推荐使用<code>&lt;applet&gt;</code>元素，所以这个集合已经不建议使用了。</li><li>document.forms，包含文档中所有的<code>&lt;form&gt;</code>元素，与document.getElementsByTagName(‘form’)得到的结果相同。</li><li>document.images，包含文档中所有的<code>&lt;img&gt;</code>元素，与document.getElementsByTagName(‘img’)得到的结果相同。</li><li>document.links，包含文档中所有带href特性的<code>&lt;a&gt;</code>元素。</li></ul><h4 id="DOM一致性检测"><a href="#DOM一致性检测" class="headerlink" title="DOM一致性检测"></a>DOM一致性检测</h4><p>由于DOM分为多个级别，也包含多个部分，因此检测浏览器实现了DOM的哪些部分就十分必要。document.implementation属性就是这些提供相应信息和功能的对象。与浏览器对DOM的实现直接对应。、DOM1级只为document.implementation规定了一个方法，即hasFeature()。这个方法接受两个参数:要检测的DOM功能的名称及版本号。如果浏览器支持给定名称和版本的功能，则该方法返回true。</p><p>下表列出了可以检测的不同的值及版本号：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZS1zdGF0aWMuc2VnbWVudGZhdWx0LmNvbS8yODgvNjgyLzI4ODY4MjY2My01N2NmNmZlNTEwY2QyX2FydGljbGV4?x-oss-process=image/format,png" alt=""></p><h4 id="文档写入"><a href="#文档写入" class="headerlink" title="文档写入"></a>文档写入</h4><ul><li><p>write();</p></li><li><p>writeIn();</p></li><li><p>open();</p></li><li><p>close();</p><p>write()和writeIn()接受一个字符串参数，既要写入到输出流的文本。write()会原样写入，而writeIn()则会在字符串的末尾添加一个换行符(\n)。</p><p>open()和close()分别用于打开和关闭网页的输出流。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Document类型&quot;&gt;&lt;a href=&quot;#Document类型&quot; class=&quot;headerlink&quot; title=&quot;Document类型&quot;&gt;&lt;/a&gt;Document类型&lt;/h3&gt;&lt;p&gt;JS通过Document类型表示文档。在浏览器中，document对象是HTMLDocument(继承自Document类型)的一个实例，表示整个HTML页面。其中，document对象是window对象的一个属性，因此可以将其作为全局对象来访问，Document节点具有以下特征：&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://github.com/liubrook/liubrook.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
