<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>1024肥宅</title>
  
  
  <link href="https://brookliu.xyz/atom.xml" rel="self"/>
  
  <link href="https://brookliu.xyz/"/>
  <updated>2021-03-15T03:32:18.026Z</updated>
  <id>https://brookliu.xyz/</id>
  
  <author>
    <name>Brookliu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[LeetCode1550题存在连续三个奇数的数组] | 刷题打卡</title>
    <link href="https://brookliu.xyz/2021/03/13/LeetCode1550%E9%A2%98%E5%AD%98%E5%9C%A8%E8%BF%9E%E7%BB%AD%E4%B8%89%E4%B8%AA%E5%A5%87%E6%95%B0%E7%9A%84%E6%95%B0%E7%BB%84-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    <id>https://brookliu.xyz/2021/03/13/LeetCode1550%E9%A2%98%E5%AD%98%E5%9C%A8%E8%BF%9E%E7%BB%AD%E4%B8%89%E4%B8%AA%E5%A5%87%E6%95%B0%E7%9A%84%E6%95%B0%E7%BB%84-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/</id>
    <published>2021-03-13T01:31:55.000Z</published>
    <updated>2021-03-15T03:32:18.026Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>题目地址：<a href="https://leetcode-cn.com/problems/three-consecutive-odds/" target="_blank" rel="noopener">1550. 存在连续三个奇数的数组</a></p><a id="more"></a> <p>给你一个整数数组 arr，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 true ；否则，返回 false 。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [2,6,4,1]</span><br><span class="line">输出：false</span><br><span class="line">解释：不存在连续三个元素都是奇数的情况。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,34,3,4,5,7,23,12]</span><br><span class="line">输出：true</span><br><span class="line">解释：存在连续三个元素都是奇数的情况，即 [5,7,23] 。</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= arr.length &lt;= 1000<br>1 &lt;= arr[i] &lt;= 1000</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目给定一个整数数组<code>arr</code>，判断数组中是否有连续<code>三个元素都是奇数</code>。</p><p>这道题的思路很简单，我们就是判断数组中有没有<code>arr[i]</code>、<code>arr[i + 1]</code>、<code>arr[i + 2]</code>都是奇数的情况。</p><p>那么如何判断一个数是<code>奇数</code>呢？</p><p>这里我们就要用到<code>按位与</code>了，那么什么是<code>按位与</code>呢？</p><blockquote><p>按位与运算符“&amp;”是双目运算符。其功能是参与运算的两数各对应的二进位相与。只有对应的两个二进位都为1时，结果位才为1。参与运算的两个数均以补码出现。<br>整数在计算机中用二进制的位来表示，C语言提供一些运算符可以直接操作整数中的位，称为位运算，这些运算符的操作数都必须是整型的。</p></blockquote><p><a href="https://baike.baidu.com/item/%E6%8C%89%E4%BD%8D%E4%B8%8E/9601818?fr=aladdin" target="_blank" rel="noopener">按位与</a></p><p>&amp;是位运算<br>是从bit的角度进行判断，判断奇偶的原因是1的只有第一位是1，其它都是0<br>所以你拿其它数字跟他进行&amp;运算，它会无视除了第一位的所有位（其它位都变成了0）<br>奇数第一位是1，偶数第一位是0，所以造成了可以判断奇偶的现象。</p><p>所以这道题的解题代码如下。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var threeConsecutiveOdds &#x3D; function (arr) &#123;</span><br><span class="line">  const n &#x3D; arr.length;</span><br><span class="line">  for (let i &#x3D; 0; i &lt;&#x3D; n - 3; ++i) &#123;</span><br><span class="line">    if ((arr[i] &amp; 1) &amp; (arr[i + 1] &amp; 1) &amp; (arr[i + 2] &amp; 1)) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="刷题打卡记录"><a href="#刷题打卡记录" class="headerlink" title="刷题打卡记录"></a>刷题打卡记录</h3><p>这里是之前的刷题打卡记录，大家有兴趣的可以看下，如果有什么不同的见解和看法或者觉得有什么错误的，欢迎在评论区留言！🙏🙏🙏</p><p><a href="https://juejin.cn/post/6934563298180333581" target="_blank" rel="noopener">[LeetCode0303题区域和检索 - 数组不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934660944475717646" target="_blank" rel="noopener">[LeetCode1200. 最小绝对差] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934918546619105288" target="_blank" rel="noopener">[LeetCode0304题二维区域和检索 - 矩阵不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935086070560194568" target="_blank" rel="noopener">[LeetCode11题盛最多水的容器] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935249377183137829" target="_blank" rel="noopener">[LeetCode0338题比特位计数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935454523255160863" target="_blank" rel="noopener">[LeetCode209题长度最小的子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935665904986357796" target="_blank" rel="noopener">[LeetCode236题二叉树的最近公共祖先] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935690559067521061" target="_blank" rel="noopener">[LeetCode141题环形链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936070093278871560" target="_blank" rel="noopener">[LeetCode53题最大子序和] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936183050594156551" target="_blank" rel="noopener">[LeetCode48题旋转图像] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936930668551077925" target="_blank" rel="noopener">[LeetCode155题最小栈] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937188252432465933" target="_blank" rel="noopener">[LeetCode1124题表现良好的最长时间段] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937219016452734989" target="_blank" rel="noopener">[LeetCode274题H指数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937290523367440391" target="_blank" rel="noopener">[LeetCode367题有效的完全平方数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937464816500113421" target="_blank" rel="noopener">[LeetCode1047题删除字符串中的所有相邻重复项] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937577608624209956" target="_blank" rel="noopener">[LeetCode160题相交链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937681886776918046" target="_blank" rel="noopener">[LeetCode1438题绝对差不超过限制的最长连续子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937838732502368293" target="_blank" rel="noopener">[LeetCode434题字符串中的单词数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937944127577260062" target="_blank" rel="noopener">[LeetCode75题颜色分类] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938044913942528037" target="_blank" rel="noopener">[LeetCode513题找树左下角的值] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938234807327555620" target="_blank" rel="noopener">[LeetCode94题二叉树的中序遍历] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938301455086387208" target="_blank" rel="noopener">[LeetCode617题合并二叉树] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938603834797195301" target="_blank" rel="noopener">[LeetCode331题验证二叉树的前序序列化] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938643505657053192" target="_blank" rel="noopener">[LeetCode1281题整数的各位积和之差] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938701752447270942" target="_blank" rel="noopener">[LeetCode172题阶乘后的零] | 刷题打卡</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>加油！hxdm！！！💪💪💪</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h3&gt;&lt;p&gt;题目地址：&lt;a href=&quot;https://leetcode-cn.com/problems/three-consecutive-odds/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1550. 存在连续三个奇数的数组&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://brookliu.xyz/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="https://brookliu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://brookliu.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode172题阶乘后的零] | 刷题打卡</title>
    <link href="https://brookliu.xyz/2021/03/12/LeetCode172%E9%A2%98%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    <id>https://brookliu.xyz/2021/03/12/LeetCode172%E9%A2%98%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/</id>
    <published>2021-03-12T03:31:22.000Z</published>
    <updated>2021-03-15T03:31:45.808Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>题目地址: <a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/" target="_blank" rel="noopener">172. 阶乘后的零</a></p><a id="more"></a> <p>给定一个整数 n，返回 n! 结果尾数中零的数量。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 0</span><br><span class="line">解释: 3! &#x3D; 6, 尾数中没有零。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: 1</span><br><span class="line">解释: 5! &#x3D; 120, 尾数中有 1 个零.</span><br></pre></td></tr></table></figure><p>说明: 你算法的时间复杂度应为 O(log n) 。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目给定整数<code>n</code>，求<code>n</code>阶乘后结果中<code>0</code>的个数。</p><p>我们先来了解下什么是<code>阶乘</code>:</p><blockquote><p>阶乘是基斯顿·卡曼（Christian Kramp，1760～1826）于 1808 年发明的运算符号，是数学术语。<br>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且0的阶乘为1。自然数n的阶乘写作n!。1808年，基斯顿·卡曼引进这个表示法。<br>亦即n!=1×2×3×…×(n-1)×n。阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×n。<br><a href="https://baike.baidu.com/item/%E9%98%B6%E4%B9%98/4437932?fr=aladdin" target="_blank" rel="noopener">阶乘</a></p></blockquote><p>在<code>0-9</code>中只有<code>2 x 5 = 10</code>，这是什么意思呢？</p><p>意思是有一对<code>2</code>和<code>5</code>，尾数就会多1一个<code>0</code>。如果还没明白，我们这样算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1的阶乘</span><br><span class="line">1 &#x3D; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2的阶乘</span><br><span class="line">1x2 &#x3D; 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3的阶乘</span><br><span class="line"></span><br><span class="line">1x2x3 &#x3D; 6</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 4的阶乘</span><br><span class="line">1x2x3x4 &#x3D; 24</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 5的阶乘尾数有几个0？</span><br><span class="line">1x2x3x4x5 &#x3D; 120</span><br><span class="line">&#x2F;&#x2F; 有1个0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 6的阶乘</span><br><span class="line">1x2x3x4x5x6 &#x3D; 720</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 7的阶乘</span><br><span class="line"></span><br><span class="line">1x2x3x4x5x6x7 &#x3D; 5040</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 8的阶乘尾数有几个0</span><br><span class="line">1x2x3x4x5x6x7x8 &#x3D; 40320</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 9的阶乘</span><br><span class="line"></span><br><span class="line">1x2x3x4x5x6x7x8x9 &#x3D; 362880</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 10的阶乘</span><br><span class="line">1x2x3x4x5x6x7x8x9x10 &#x3D; 3628800</span><br></pre></td></tr></table></figure><p><code>5</code>的阶乘有一对<code>2</code>和<code>5</code>，<code>10</code>的阶乘有两对<code>2</code>和<code>5</code>(2的倍数有2、4、6、8、10，5的倍数有5、10)。</p><p>所以求<code>n</code>阶乘的尾数<code>0</code>的个数，就是求<code>2</code>和<code>5</code>一对的倍数，<code>2</code>的倍数比<code>5</code>的倍数多，所以最终就是求<code>5</code>的倍数出现了多少次，尾数就有多少个<code>0</code>。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var trailingZeroes &#x3D; function (n) &#123;</span><br><span class="line">  let res &#x3D; 0;</span><br><span class="line">  while (n &gt;&#x3D; 5) &#123;</span><br><span class="line">    let k &#x3D; Math.floor(n &#x2F; 5);</span><br><span class="line">    res +&#x3D; k;</span><br><span class="line">    n &#x3D; k;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="刷题打卡记录"><a href="#刷题打卡记录" class="headerlink" title="刷题打卡记录"></a>刷题打卡记录</h3><p>这里是之前的刷题打卡记录，大家有兴趣的可以看下，如果有什么不同的见解和看法或者觉得有什么错误的，欢迎在评论区留言！🙏🙏🙏</p><p><a href="https://juejin.cn/post/6934563298180333581" target="_blank" rel="noopener">[LeetCode0303题区域和检索 - 数组不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934660944475717646" target="_blank" rel="noopener">[LeetCode1200. 最小绝对差] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934918546619105288" target="_blank" rel="noopener">[LeetCode0304题二维区域和检索 - 矩阵不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935086070560194568" target="_blank" rel="noopener">[LeetCode11题盛最多水的容器] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935249377183137829" target="_blank" rel="noopener">[LeetCode0338题比特位计数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935454523255160863" target="_blank" rel="noopener">[LeetCode209题长度最小的子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935665904986357796" target="_blank" rel="noopener">[LeetCode236题二叉树的最近公共祖先] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935690559067521061" target="_blank" rel="noopener">[LeetCode141题环形链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936070093278871560" target="_blank" rel="noopener">[LeetCode53题最大子序和] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936183050594156551" target="_blank" rel="noopener">[LeetCode48题旋转图像] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936930668551077925" target="_blank" rel="noopener">[LeetCode155题最小栈] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937188252432465933" target="_blank" rel="noopener">[LeetCode1124题表现良好的最长时间段] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937219016452734989" target="_blank" rel="noopener">[LeetCode274题H指数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937290523367440391" target="_blank" rel="noopener">[LeetCode367题有效的完全平方数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937464816500113421" target="_blank" rel="noopener">[LeetCode1047题删除字符串中的所有相邻重复项] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937577608624209956" target="_blank" rel="noopener">[LeetCode160题相交链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937681886776918046" target="_blank" rel="noopener">[LeetCode1438题绝对差不超过限制的最长连续子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937838732502368293" target="_blank" rel="noopener">[LeetCode434题字符串中的单词数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937944127577260062" target="_blank" rel="noopener">[LeetCode75题颜色分类] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938044913942528037" target="_blank" rel="noopener">[LeetCode513题找树左下角的值] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938234807327555620" target="_blank" rel="noopener">[LeetCode94题二叉树的中序遍历] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938301455086387208" target="_blank" rel="noopener">[LeetCode617题合并二叉树] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938603834797195301" target="_blank" rel="noopener">[LeetCode331题验证二叉树的前序序列化] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938643505657053192" target="_blank" rel="noopener">[LeetCode1281题整数的各位积和之差] | 刷题打卡</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>加油！hxdm！！！💪💪💪</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;题目地址: &lt;a href=&quot;https://leetcode-cn.com/problems/factorial-trailing-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;172. 阶乘后的零&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://brookliu.xyz/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="https://brookliu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://brookliu.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode1281题整数的各位积和之差] | 刷题打卡 </title>
    <link href="https://brookliu.xyz/2021/03/12/LeetCode1281%E9%A2%98%E6%95%B4%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E7%A7%AF%E5%92%8C%E4%B9%8B%E5%B7%AE-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    <id>https://brookliu.xyz/2021/03/12/LeetCode1281%E9%A2%98%E6%95%B4%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E7%A7%AF%E5%92%8C%E4%B9%8B%E5%B7%AE-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/</id>
    <published>2021-03-12T01:30:41.000Z</published>
    <updated>2021-03-15T03:31:08.583Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>原题地址: <a href="https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/" target="_blank" rel="noopener">1281. 整数的各位积和之差</a></p><a id="more"></a> <p>给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 234</span><br><span class="line">输出：15 </span><br><span class="line">解释：</span><br><span class="line">各位数之积 &#x3D; 2 * 3 * 4 &#x3D; 24 </span><br><span class="line">各位数之和 &#x3D; 2 + 3 + 4 &#x3D; 9 </span><br><span class="line">结果 &#x3D; 24 - 9 &#x3D; 15</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 4421</span><br><span class="line">输出：21</span><br><span class="line">解释： </span><br><span class="line">各位数之积 &#x3D; 4 * 4 * 2 * 1 &#x3D; 32 </span><br><span class="line">各位数之和 &#x3D; 4 + 4 + 2 + 1 &#x3D; 11 </span><br><span class="line">结果 &#x3D; 32 - 11 &#x3D; 21</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><p>1 &lt;= n &lt;= $10^5$</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>求一个整数<code>n</code>的<code>各位数字之积</code>和<code>各位数字之和</code>!</p><p>这道题有两种基本解法：</p><h4 id="转字符串"><a href="#转字符串" class="headerlink" title="转字符串"></a>转字符串</h4><p>转字符串的做法就很简单：</p><ul><li>把<code>n</code>转成字符串<code>str</code>。</li><li>循环字符串<code>str</code>，每个值<code>str[i]</code>依次相加、相乘(注意对<code>str[i]</code>的处理)。</li><li>然后就可以得到题目中所要求的<code>积</code>和<code>和</code>了，然后返回差即可。</li></ul></li></ul><h4 id="不转字符串"><a href="#不转字符串" class="headerlink" title="不转字符串"></a>不转字符串</h4><p>这道题其实主要就是如何拿到<code>n</code>的每一位，所以如果不将<code>n</code>转成字符串的话，我们可以用<code>%</code>的方法来<code>取余</code>解答这道题。</p><p>设定<code>sum</code>为和，<code>total</code>为积，初始值都为<code>0</code>。</p><ul><li><code>n % 10</code>可以取到<code>n</code>的个位，对应的<code>sum</code>和<code>total</code>存起来。</li><li>上一步我们已经取到了<code>n</code>的个位，所以这一步我们去掉已经拿到的值 <code>Math.floor(n / 10)</code>，然后继续上一步即可。</li><li>直到不满足<code>n &gt; 0</code>的情况结束，返回<code>sum - total</code>即可。</li></ul><h4 id="eval函数"><a href="#eval函数" class="headerlink" title="eval函数"></a>eval函数</h4><p>我在看题解的时候，发现了一个很机智的解法，可以说是<code>巧用JavaScript</code>，贴出来秀一下。</p><ul><li>将<code>n</code>转字符串然后分割成数组。</li><li>将数组用<code>*</code>和<code>+</code>的形式连接成字符串。</li><li>用<code>eval</code>函数执行字符串。</li></ul><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="转字符串-1"><a href="#转字符串-1" class="headerlink" title="转字符串"></a>转字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var subtractProductAndSum &#x3D; function(n) &#123;</span><br><span class="line">    var str &#x3D; n.toString();</span><br><span class="line">    var sum &#x3D; 0,total &#x3D; 1;</span><br><span class="line">    for(let i &#x3D; 0 ; i&lt; str.length ; i++)&#123;</span><br><span class="line">        sum &#x3D; sum + parseInt(str[i]);</span><br><span class="line">        total &#x3D; total * parseInt(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return total - sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不转字符串-1"><a href="#不转字符串-1" class="headerlink" title="不转字符串"></a>不转字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var subtractProductAndSum &#x3D; function(n) &#123;</span><br><span class="line">    let sum &#x3D; 0;</span><br><span class="line">    let total &#x3D; 1;</span><br><span class="line">    while (n) &#123;</span><br><span class="line">        sum &#x3D; n % 10 + sum;</span><br><span class="line">        total &#x3D; n % 10 * total;</span><br><span class="line">        n &#x3D; Math.floor(n&#x2F;10);</span><br><span class="line">    &#125;</span><br><span class="line">    return total - sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="eval函数-1"><a href="#eval函数-1" class="headerlink" title="eval函数"></a>eval函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var subtractProductAndSum &#x3D; function(n) &#123;</span><br><span class="line">    let arr &#x3D; n.toString().split(&#39;&#39;);</span><br><span class="line">    let a &#x3D; eval(arr.join(&#39;*&#39;));</span><br><span class="line">    let b &#x3D; eval(arr.join(&#39;+&#39;));</span><br><span class="line">    return a-b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="刷题打卡记录"><a href="#刷题打卡记录" class="headerlink" title="刷题打卡记录"></a>刷题打卡记录</h3><p>这里是之前的刷题打卡记录，大家有兴趣的可以看下，如果有什么不同的见解和看法或者觉得有什么错误的，欢迎在评论区留言！🙏🙏🙏</p><p><a href="https://juejin.cn/post/6934563298180333581" target="_blank" rel="noopener">[LeetCode0303题区域和检索 - 数组不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934660944475717646" target="_blank" rel="noopener">[LeetCode1200. 最小绝对差] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934918546619105288" target="_blank" rel="noopener">[LeetCode0304题二维区域和检索 - 矩阵不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935086070560194568" target="_blank" rel="noopener">[LeetCode11题盛最多水的容器] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935249377183137829" target="_blank" rel="noopener">[LeetCode0338题比特位计数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935454523255160863" target="_blank" rel="noopener">[LeetCode209题长度最小的子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935665904986357796" target="_blank" rel="noopener">[LeetCode236题二叉树的最近公共祖先] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935690559067521061" target="_blank" rel="noopener">[LeetCode141题环形链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936070093278871560" target="_blank" rel="noopener">[LeetCode53题最大子序和] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936183050594156551" target="_blank" rel="noopener">[LeetCode48题旋转图像] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936930668551077925" target="_blank" rel="noopener">[LeetCode155题最小栈] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937188252432465933" target="_blank" rel="noopener">[LeetCode1124题表现良好的最长时间段] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937219016452734989" target="_blank" rel="noopener">[LeetCode274题H指数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937290523367440391" target="_blank" rel="noopener">[LeetCode367题有效的完全平方数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937464816500113421" target="_blank" rel="noopener">[LeetCode1047题删除字符串中的所有相邻重复项] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937577608624209956" target="_blank" rel="noopener">[LeetCode160题相交链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937681886776918046" target="_blank" rel="noopener">[LeetCode1438题绝对差不超过限制的最长连续子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937838732502368293" target="_blank" rel="noopener">[LeetCode434题字符串中的单词数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937944127577260062" target="_blank" rel="noopener">[LeetCode75题颜色分类] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938044913942528037" target="_blank" rel="noopener">[LeetCode513题找树左下角的值] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938234807327555620" target="_blank" rel="noopener">[LeetCode94题二叉树的中序遍历] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938301455086387208" target="_blank" rel="noopener">[LeetCode617题合并二叉树] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938603834797195301" target="_blank" rel="noopener">[LeetCode331题验证二叉树的前序序列化] | 刷题打卡</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>加油！hxdm！！！💪💪💪</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h3&gt;&lt;p&gt;原题地址: &lt;a href=&quot;https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1281. 整数的各位积和之差&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://brookliu.xyz/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="https://brookliu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://brookliu.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode331题验证二叉树的前序序列化] | 刷题打卡</title>
    <link href="https://brookliu.xyz/2021/03/12/LeetCode331%E9%A2%98%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    <id>https://brookliu.xyz/2021/03/12/LeetCode331%E9%A2%98%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/</id>
    <published>2021-03-12T00:30:06.000Z</published>
    <updated>2021-03-15T03:30:29.552Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>题目地址：<a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/" target="_blank" rel="noopener">331. 验证二叉树的前序序列化</a></p><a id="more"></a> <p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _9_</span><br><span class="line">    &#x2F;   \</span><br><span class="line">   3     2</span><br><span class="line">  &#x2F; \   &#x2F; \</span><br><span class="line"> 4   1  #  6</span><br><span class="line">&#x2F; \ &#x2F; \   &#x2F; \</span><br><span class="line"># # # #   # #</span><br></pre></td></tr></table></figure><p>例如，上面的二叉树可以被序列化为字符串 “9,3,4,#,#,1,#,#,2,#,6,#,#”，其中 # 代表一个空节点。</p><p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p><p>每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 ‘#’ 。</p><p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 “1,,3” 。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;1,#&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;9,#,#,1&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目给定了一串以逗号分割的序列<code>preorder</code>，要求验证<code>preorder</code>是不是正确的二叉树的前序序列化，不能重构树。</p><p>在题目描述里我们知道了<code>二叉树的前序序列化</code>的含义，在树中，所有节点的入度之和等于出度之和。所以我们可以根据这个特点判断输入序列是否为有效的！</p><p>在一棵二叉树中：</p><p>1、每个空节点（ “#” ）会提供 0 个出度和 1 个入度。</p><p>2、每个非空节点会提供 2 个出度和 1 个入度。</p><p>所以，我们先将<code>preorder</code>转成数组<code>nodes</code>，定义一个<code>dif = 1</code>来计算度数。</p><blockquote><p>我们加入一个非空节点时，都会先减去一个入度，再加上两个出度。但是由于根节点没有父节点，所以其入度为 0，出度为 2。因此 diff 初始化为 1，是为了在加入根节点的时候，先减去一个入度，再加上两个出度，此时 diff 正好应该是2.</p></blockquote><p>要验证二叉树<code>preorder</code>，就要遍历<code>nodes</code>，每个节点都累加 <code>dif</code> = 出度 - 入度 。在遍历到任何一个节点的时候，要求<code>dif &gt; 0</code>，原因是还没遍历到该节点的子节点，所以此时的出度应该大于等于入度。当所有节点遍历完成之后，整棵树的<code>dif === 0</code> 。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; preorder</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var isValidSerialization &#x3D; function(preorder) &#123;</span><br><span class="line">    let nodes &#x3D; preorder.split(&#39;,&#39;);</span><br><span class="line">    let dif &#x3D; 1;</span><br><span class="line">    for (node of nodes) &#123;</span><br><span class="line">        dif -&#x3D; 1;</span><br><span class="line">        if (dif &lt; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node !&#x3D;&#x3D; &#39;#&#39;) &#123;</span><br><span class="line">            dif +&#x3D; 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dif &#x3D;&#x3D;&#x3D; 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="刷题打卡记录"><a href="#刷题打卡记录" class="headerlink" title="刷题打卡记录"></a>刷题打卡记录</h3><p>这里是之前的刷题打卡记录，大家有兴趣的可以看下，如果有什么不同的见解和看法或者觉得有什么错误的，欢迎在评论区留言！🙏🙏🙏</p><p><a href="https://juejin.cn/post/6934563298180333581" target="_blank" rel="noopener">[LeetCode0303题区域和检索 - 数组不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934660944475717646" target="_blank" rel="noopener">[LeetCode1200. 最小绝对差] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934918546619105288" target="_blank" rel="noopener">[LeetCode0304题二维区域和检索 - 矩阵不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935086070560194568" target="_blank" rel="noopener">[LeetCode11题盛最多水的容器] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935249377183137829" target="_blank" rel="noopener">[LeetCode0338题比特位计数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935454523255160863" target="_blank" rel="noopener">[LeetCode209题长度最小的子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935665904986357796" target="_blank" rel="noopener">[LeetCode236题二叉树的最近公共祖先] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935690559067521061" target="_blank" rel="noopener">[LeetCode141题环形链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936070093278871560" target="_blank" rel="noopener">[LeetCode53题最大子序和] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936183050594156551" target="_blank" rel="noopener">[LeetCode48题旋转图像] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936930668551077925" target="_blank" rel="noopener">[LeetCode155题最小栈] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937188252432465933" target="_blank" rel="noopener">[LeetCode1124题表现良好的最长时间段] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937219016452734989" target="_blank" rel="noopener">[LeetCode274题H指数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937290523367440391" target="_blank" rel="noopener">[LeetCode367题有效的完全平方数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937464816500113421" target="_blank" rel="noopener">[LeetCode1047题删除字符串中的所有相邻重复项] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937577608624209956" target="_blank" rel="noopener">[LeetCode160题相交链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937681886776918046" target="_blank" rel="noopener">[LeetCode1438题绝对差不超过限制的最长连续子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937838732502368293" target="_blank" rel="noopener">[LeetCode434题字符串中的单词数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937944127577260062" target="_blank" rel="noopener">[LeetCode75题颜色分类] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938044913942528037" target="_blank" rel="noopener">[LeetCode513题找树左下角的值] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938234807327555620" target="_blank" rel="noopener">[LeetCode94题二叉树的中序遍历] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938301455086387208" target="_blank" rel="noopener">[LeetCode617题合并二叉树] | 刷题打卡</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>加油！hxdm！！！💪💪💪</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;题目地址：&lt;a href=&quot;https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;331. 验证二叉树的前序序列化&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://brookliu.xyz/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="https://brookliu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://brookliu.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode617题合并二叉树] | 刷题打卡</title>
    <link href="https://brookliu.xyz/2021/03/11/LeetCode617%E9%A2%98%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    <id>https://brookliu.xyz/2021/03/11/LeetCode617%E9%A2%98%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/</id>
    <published>2021-03-11T03:29:33.000Z</published>
    <updated>2021-03-15T03:29:53.948Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>题目地址: <a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">617. 合并二叉树</a></p><a id="more"></a> <p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \   \ </span><br><span class="line"> 5   4   7</span><br></pre></td></tr></table></figure><p>注意: 合并必须从两个树的根节点开始。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>之前<a href="https://juejin.cn/post/6938234807327555620" target="_blank" rel="noopener">[LeetCode94题二叉树的中序遍历] | 刷题打卡</a>中因为题目要求的是<code>中序遍历</code>，所以采用的是<code>中序遍历</code>解答。</p><p>这道题给定两个二叉树<code>t1</code>和<code>t2</code>，要合并二叉树，我们就直接用<code>前序遍历</code>来<code>递归</code>实现吧!(这里看你想用哪种递归方式都可以)</p><p>在解题过程中我们将<code>t2</code>合并到<code>t1</code>上。</p><p>第一步，合并两个二叉树，我们首先要做情况判断，不要一上来就直接开始<code>递归</code>，先对<code>t1</code>和<code>t2</code>进行判断：<br>     - <code>t1</code>为空就返回<code>t2</code>，不去管<code>t2</code>是否为空(<code>t2</code>要是空的话返回的也是空，所以这里不用管<code>t2</code>)。<br>     - <code>t2</code>为空就返回<code>t1</code>(经过了上一步的判断<code>t1</code>肯定不为空)。</p><p>第二步，经过了判断步骤之后证明<code>t1</code>和<code>t2</code>的节点肯定都不为空，用<code>t1.val + t2.val</code>来覆盖<code>t1.val</code>实现题目中要求<code>重叠节点的值的合并</code>。</p><p>第三步，因为我们说用<code>前序遍历</code>来解答，所以这里递归遍历<code>t1</code>和<code>t2</code>的左子树，重复一、二步会取它们左子树的值合并。</p><p>第四步，递归遍历<code>t1</code>和<code>t2</code>的右子树，重复一、二步会取它们右子树的值合并。</p><p>最后，我们返回<code>t1</code>即可。(因为我们是将<code>t2</code>合并到<code>t1</code>上，所以返回<code>t1</code>)。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var mergeTrees &#x3D; function(t1, t2) &#123;</span><br><span class="line">    if(!t1) return t2;</span><br><span class="line">    if(!t2) return t1;</span><br><span class="line">    t1.val &#x3D; t1.val + t2.val;</span><br><span class="line">    t1.left &#x3D; mergeTrees(t1.left, t2.left);</span><br><span class="line">    t1.right &#x3D; mergeTrees(t1.right, t2.right);</span><br><span class="line">    return t1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="刷题打卡记录"><a href="#刷题打卡记录" class="headerlink" title="刷题打卡记录"></a>刷题打卡记录</h3><p>这里是之前的刷题打卡记录，大家有兴趣的可以看下，如果有什么不同的见解和看法或者觉得有什么错误的，欢迎在评论区留言！🙏🙏🙏</p><p><a href="https://juejin.cn/post/6934563298180333581" target="_blank" rel="noopener">[LeetCode0303题区域和检索 - 数组不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934660944475717646" target="_blank" rel="noopener">[LeetCode1200. 最小绝对差] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934918546619105288" target="_blank" rel="noopener">[LeetCode0304题二维区域和检索 - 矩阵不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935086070560194568" target="_blank" rel="noopener">[LeetCode11题盛最多水的容器] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935249377183137829" target="_blank" rel="noopener">[LeetCode0338题比特位计数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935454523255160863" target="_blank" rel="noopener">[LeetCode209题长度最小的子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935665904986357796" target="_blank" rel="noopener">[LeetCode236题二叉树的最近公共祖先] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935690559067521061" target="_blank" rel="noopener">[LeetCode141题环形链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936070093278871560" target="_blank" rel="noopener">[LeetCode53题最大子序和] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936183050594156551" target="_blank" rel="noopener">[LeetCode48题旋转图像] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936930668551077925" target="_blank" rel="noopener">[LeetCode155题最小栈] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937188252432465933" target="_blank" rel="noopener">[LeetCode1124题表现良好的最长时间段] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937219016452734989" target="_blank" rel="noopener">[LeetCode274题H指数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937290523367440391" target="_blank" rel="noopener">[LeetCode367题有效的完全平方数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937464816500113421" target="_blank" rel="noopener">[LeetCode1047题删除字符串中的所有相邻重复项] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937577608624209956" target="_blank" rel="noopener">[LeetCode160题相交链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937681886776918046" target="_blank" rel="noopener">[LeetCode1438题绝对差不超过限制的最长连续子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937838732502368293" target="_blank" rel="noopener">[LeetCode434题字符串中的单词数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937944127577260062" target="_blank" rel="noopener">[LeetCode75题颜色分类] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938044913942528037" target="_blank" rel="noopener">[LeetCode513题找树左下角的值] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938234807327555620" target="_blank" rel="noopener">[LeetCode94题二叉树的中序遍历] | 刷题打卡</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>加油！hxdm！！！💪💪💪</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;题目地址: &lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-binary-trees/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;617. 合并二叉树&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://brookliu.xyz/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="https://brookliu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://brookliu.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode94题二叉树的中序遍历] | 刷题打卡</title>
    <link href="https://brookliu.xyz/2021/03/11/LeetCode94%E9%A2%98%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    <id>https://brookliu.xyz/2021/03/11/LeetCode94%E9%A2%98%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/</id>
    <published>2021-03-11T01:28:49.000Z</published>
    <updated>2021-03-15T03:29:21.244Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在做题之前我们先来大概了解下二叉树的遍历方式。</p><a id="more"></a> <h4 id="为什么叫前序、后序、中序？"><a href="#为什么叫前序、后序、中序？" class="headerlink" title="为什么叫前序、后序、中序？"></a>为什么叫前序、后序、中序？</h4><p>一棵二叉树由根结点、左子树和右子树三部分组成，若规定 D、L、R 分别代表遍历根结点、遍历左子树、遍历右子树，则二叉树的遍历方式有 6 种：DLR、DRL、LDR、LRD、RDL、RLD。由于先遍历左子树和先遍历右子树在算法设计上没有本质区别，所以，只讨论三种方式：</p><p>DLR–前序遍历（根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面 ）</p><p>LDR–中序遍历（根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面）</p><p>LRD–后序遍历（根在后，从左往右，一棵树的左子树永远在右子树前面，右子树永远在根前面）</p><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树。</p><p>若二叉树为空则结束返回，否则：</p><ul><li>（1）访问根结点。</li><li>（2）前序遍历左子树。</li><li>（3）前序遍历右子树 。<br>需要注意的是：遍历左右子树时仍然采用前序遍历方法。<br>如图所示二叉树</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7f2f5f26e574de4a848fc86c036cfab~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>前序遍历结果：ABDECF<br>已知后序遍历和中序遍历，就能确定前序遍历。</p><p><a href="https://baike.baidu.com/item/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/757319?fr=aladdin" target="_blank" rel="noopener">前序遍历</a></p><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。若二叉树为空则结束返回，否则：</p><ul><li>（1）中序遍历左子树</li><li>（2）访问根结点</li><li>（3）中序遍历右子树</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc0e8aba7af14c7994ff5baef325a29d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>如图所示二叉树，中序遍历结果：DBEAFC</p><p><a href="https://baike.baidu.com/item/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/757281?fr=aladdin" target="_blank" rel="noopener">中序遍历</a></p><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>后序遍历首先遍历左子树，然后遍历右子树，最后访问根结点，在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后遍历根结点。即：</p><p>若二叉树为空则结束返回，否则：</p><ul><li>（1）后序遍历左子树</li><li>（2）后序遍历右子树</li><li>（3）访问根结点</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/212122ea7bc346fba7e30e4b6b7e0804~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>如图所示二叉树<br>后序遍历结果：DEBFCA<br>已知前序遍历和中序遍历，就能确定后序遍历</p><p><a href="https://baike.baidu.com/item/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/1214806?fr=aladdin" target="_blank" rel="noopener">后序遍历</a></p><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>题目地址: <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></p><p>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p><p>示例 1：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/698410b2376f4b9ba034ce3be4ef40f9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p>示例 4：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e57c64dc19cf4e2ea7af15532489e90f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><p>示例 5：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ce7b4093dcc44d6bf53e124b7aae04e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>树中节点数目在范围 [0, 100] 内</li><li>-100 &lt;= Node.val &lt;= 100</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目要求返回给定二叉树<code>root</code>的中序遍历，根据前言中的关于<code>中序遍历</code>的描述，这道题的解法我们就按照这样的顺序来。</p><p>我们用递归函数<code>inOrder</code>来模拟二叉树遍历的过程。</p><p>根据上文中的定义，我们解题步骤如下：</p><ul><li>递归调用 <code>inOrder(root.left)</code> 来遍历 <code>root</code> 节点的左子树</li><li>然后<code>root</code> 节点的值<code>val</code>加入答案</li><li>再递归调用<code>inOrder(root.right)</code> 来遍历 <code>root</code> 节点的右子树即可。</li></ul><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var inorderTraversal &#x3D; function(root) &#123;</span><br><span class="line">    const res &#x3D; []</span><br><span class="line">    const inOrder &#x3D; (root) &#x3D;&gt; &#123;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        res.push(root.val);</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root);</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="刷题打卡记录"><a href="#刷题打卡记录" class="headerlink" title="刷题打卡记录"></a>刷题打卡记录</h3><p>这里是之前的刷题打卡记录，大家有兴趣的可以看下，如果有什么不同的见解和看法或者觉得有什么错误的，欢迎在评论区留言！🙏🙏🙏</p><p><a href="https://juejin.cn/post/6934563298180333581" target="_blank" rel="noopener">[LeetCode0303题区域和检索 - 数组不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934660944475717646" target="_blank" rel="noopener">[LeetCode1200. 最小绝对差] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934918546619105288" target="_blank" rel="noopener">[LeetCode0304题二维区域和检索 - 矩阵不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935086070560194568" target="_blank" rel="noopener">[LeetCode11题盛最多水的容器] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935249377183137829" target="_blank" rel="noopener">[LeetCode0338题比特位计数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935454523255160863" target="_blank" rel="noopener">[LeetCode209题长度最小的子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935665904986357796" target="_blank" rel="noopener">[LeetCode236题二叉树的最近公共祖先] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935690559067521061" target="_blank" rel="noopener">[LeetCode141题环形链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936070093278871560" target="_blank" rel="noopener">[LeetCode53题最大子序和] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936183050594156551" target="_blank" rel="noopener">[LeetCode48题旋转图像] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936930668551077925" target="_blank" rel="noopener">[LeetCode155题最小栈] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937188252432465933" target="_blank" rel="noopener">[LeetCode1124题表现良好的最长时间段] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937219016452734989" target="_blank" rel="noopener">[LeetCode274题H指数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937290523367440391" target="_blank" rel="noopener">[LeetCode367题有效的完全平方数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937464816500113421" target="_blank" rel="noopener">[LeetCode1047题删除字符串中的所有相邻重复项] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937577608624209956" target="_blank" rel="noopener">[LeetCode160题相交链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937681886776918046" target="_blank" rel="noopener">[LeetCode1438题绝对差不超过限制的最长连续子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937838732502368293" target="_blank" rel="noopener">[LeetCode434题字符串中的单词数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937944127577260062" target="_blank" rel="noopener">[LeetCode75题颜色分类] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6938044913942528037" target="_blank" rel="noopener">[LeetCode513题找树左下角的值] | 刷题打卡</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>加油！hxdm！！！💪💪💪</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在做题之前我们先来大概了解下二叉树的遍历方式。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://brookliu.xyz/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="https://brookliu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://brookliu.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode75题颜色分类] | 刷题打卡</title>
    <link href="https://brookliu.xyz/2021/03/10/LeetCode75%E9%A2%98%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    <id>https://brookliu.xyz/2021/03/10/LeetCode75%E9%A2%98%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/</id>
    <published>2021-03-10T08:27:30.000Z</published>
    <updated>2021-03-15T03:32:50.213Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>这道题是LeetCode<a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a>，难度<code>medium</code>。</p><a id="more"></a> <p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,0,1]</span><br><span class="line">输出：[0,1,2]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>n == nums.length</li><li>1 &lt;= n &lt;= 300</li><li>nums[i] 为 0、1 或 2</li></ul><p>进阶：</p><ul><li>你可以不使用代码库中的排序函数来解决这道题吗？</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据题目的要求，就是将给定数组<code>nums</code>按照<code>0, 1, 2</code>的顺序排序后返回，要仔细审题，注意这里是<code>原地对它们进行排序</code>，所以不要上来就是循环<code>nums</code>，然后将<code>0, 1, 2</code>依次添加到新数组之后返回，这样是不符合要求的。</p><p><code>原地</code>那就是让我们来用指针的方法交换数组了。</p><h4 id="单指针"><a href="#单指针" class="headerlink" title="单指针"></a>单指针</h4><p>设定一个指针<code>ptr = 0</code>，然后先循环<code>nums</code>数组，找到每个<code>0</code>和<code>ptr</code>交换，每交换一次<code>ptr++</code>，循环结束后<code>nums</code>数组的头部都是<code>0</code>。</p><p>然后从<code>ptr</code>开始再次循环<code>nums</code>数组(因为<code>ptr</code>之前的都是<code>0</code>)，找个每个<code>1</code>和<code>ptr</code>交换，没交换一次<code>ptr++</code>，循环结束后的<code>nums</code>数组就是我们想要的结果数组了。</p><p>时间复杂度：O(n)O(n)，其中 nn 是数组 \textit{nums}nums 的长度。</p><p>空间复杂度：O(1)O(1)。</p><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>单指针是用一个指针<code>ptr</code>循环两次，那我们可不可以只循环一次呢？</p><p>当然可以，设定两个指针<code>p0 = 0, p1 = 0</code>，然后循环<code>nums</code>数组，如果遇见<code>0</code>的话我们将<code>i</code>和<code>p0</code>交换，注意这里，因为我们是按照<code>0, 1， 2</code>的顺序来排序的，所以<code>0</code>之后都是<code>1</code>，这里我们可能会把<code>1</code>交换出去，所以这里当<code>p0 &lt; p1</code>的时候，我们还需要将<code>i</code>和<code>p1</code>交换，然后<code>p0++; p1++</code>。</p><p>如果我们遇见<code>1</code>，那么就跟单指针的方法一样，将<code>p1</code>和<code>i</code>进行交换，然后<code>p1</code>++;</p><p>这样最后我们就得到了我们想要的数组。</p><h4 id="左右双指针"><a href="#左右双指针" class="headerlink" title="左右双指针"></a>左右双指针</h4><p>上一步中我们是用双指针<code>从左到右</code>遍历<code>nums</code>数组的，我们也可以<code>从两端开始遍历</code>，设定<code>left = 0</code>和<code>right = nums.length - 1</code>，当<code>从左到右</code>超过了<code>right</code>的时候就可以停止遍历了。</p><p>当遇见<code>0</code>的时候，<code>i</code>和<code>left</code>交换，然后<code>left++</code>。</p><p>当遇见<code>2</code>的时候，<code>i</code>和<code>right</code>交换，然后<code>right--</code>。</p><p><code>1</code>保持不变，遍历结束后的数组<code>nums</code>就是我们需要的结果数组了。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="单指针-1"><a href="#单指针-1" class="headerlink" title="单指针"></a>单指针</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var sortColors &#x3D; function(nums) &#123;</span><br><span class="line">  const n &#x3D; nums.length;</span><br><span class="line">  let ptr &#x3D; 0;</span><br><span class="line">  for (let i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    if (nums[i] &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      [nums[i], nums[ptr]] &#x3D; [nums[ptr], nums[i]];</span><br><span class="line">      ptr++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (let i &#x3D; ptr; i &lt; n; i++) &#123;</span><br><span class="line">    if (nums[i] &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">      [nums[i], nums[ptr]] &#x3D; [nums[ptr], nums[i]];</span><br><span class="line">      ptr++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var sortColors1 &#x3D; function(nums) &#123;</span><br><span class="line">  const n &#x3D; nums.length;</span><br><span class="line">  let p0 &#x3D; 0, p1 &#x3D; 0;</span><br><span class="line">  for (let i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    if (nums[i] &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">      [nums[i], nums[p1]] &#x3D; [nums[p1], nums[i]];</span><br><span class="line">      p1++;</span><br><span class="line">    &#125; else if (nums[i] &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      [nums[i], nums[p0]] &#x3D; [nums[p0], nums[i]];</span><br><span class="line">      if (p0 &lt; p1) &#123;</span><br><span class="line">        [nums[i], nums[p1]] &#x3D; [nums[p1], nums[i]];</span><br><span class="line">      &#125;</span><br><span class="line">      p0++;</span><br><span class="line">      p1++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两端双指针"><a href="#两端双指针" class="headerlink" title="两端双指针"></a>两端双指针</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var sortColors2 &#x3D; function(nums) &#123;</span><br><span class="line">  const n &#x3D; nums.length;</span><br><span class="line">  let left &#x3D; 0, right &#x3D; n - 1;</span><br><span class="line">  let i &#x3D; 0;</span><br><span class="line">  while(i &lt;&#x3D; right) &#123;</span><br><span class="line">    while(i &lt;&#x3D; right &amp;&amp; nums[i] &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">      [nums[i], nums[right]] &#x3D; [nums[right], nums[i]];</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nums[i] &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      [nums[i], nums[left]] &#x3D; [nums[left], nums[i]];</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  return nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="刷题打卡记录"><a href="#刷题打卡记录" class="headerlink" title="刷题打卡记录"></a>刷题打卡记录</h3><p>这里是之前的刷题打卡记录，大家有兴趣的可以看下，如果有什么不同的见解和看法或者觉得有什么错误的，欢迎在评论区留言！🙏🙏🙏</p><p><a href="https://juejin.cn/post/6934563298180333581" target="_blank" rel="noopener">[LeetCode0303题区域和检索 - 数组不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934660944475717646" target="_blank" rel="noopener">[LeetCode1200. 最小绝对差] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934918546619105288" target="_blank" rel="noopener">[LeetCode0304题二维区域和检索 - 矩阵不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935086070560194568" target="_blank" rel="noopener">[LeetCode11题盛最多水的容器] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935249377183137829" target="_blank" rel="noopener">[LeetCode0338题比特位计数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935454523255160863" target="_blank" rel="noopener">[LeetCode209题长度最小的子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935665904986357796" target="_blank" rel="noopener">[LeetCode236题二叉树的最近公共祖先] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935690559067521061" target="_blank" rel="noopener">[LeetCode141题环形链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936070093278871560" target="_blank" rel="noopener">[LeetCode53题最大子序和] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936183050594156551" target="_blank" rel="noopener">[LeetCode48题旋转图像] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936930668551077925" target="_blank" rel="noopener">[LeetCode155题最小栈] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937188252432465933" target="_blank" rel="noopener">[LeetCode1124题表现良好的最长时间段] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937219016452734989" target="_blank" rel="noopener">[LeetCode274题H指数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937290523367440391" target="_blank" rel="noopener">[LeetCode367题有效的完全平方数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937464816500113421" target="_blank" rel="noopener">[LeetCode1047题删除字符串中的所有相邻重复项] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937577608624209956" target="_blank" rel="noopener">[LeetCode160题相交链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937681886776918046" target="_blank" rel="noopener">[LeetCode1438题绝对差不超过限制的最长连续子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937838732502368293" target="_blank" rel="noopener">[LeetCode434题字符串中的单词数] | 刷题打卡</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>加油！hxdm！！！💪💪💪</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h3&gt;&lt;p&gt;这道题是LeetCode&lt;a href=&quot;https://leetcode-cn.com/problems/sort-colors/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;75. 颜色分类&lt;/a&gt;，难度&lt;code&gt;medium&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://brookliu.xyz/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="https://brookliu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://brookliu.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode513题找树左下角的值] | 刷题打卡</title>
    <link href="https://brookliu.xyz/2021/03/10/LeetCode513%E9%A2%98%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    <id>https://brookliu.xyz/2021/03/10/LeetCode513%E9%A2%98%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/</id>
    <published>2021-03-10T06:28:14.000Z</published>
    <updated>2021-03-15T03:28:39.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>题目地址：<a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/" target="_blank" rel="noopener">513. 找树左下角的值</a></p><a id="more"></a> <p>给定一个二叉树，在树的最后一行找到最左边的值。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">        1</span><br><span class="line">       &#x2F; \</span><br><span class="line">      2   3</span><br><span class="line">     &#x2F;   &#x2F; \</span><br><span class="line">    4   5   6</span><br><span class="line">       &#x2F;</span><br><span class="line">      7</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p>注意: 您可以假设树（即给定的根节点）不为 NULL。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目给定一个二叉树<code>root</code>，要求在树的最后一行找到最左边的值。</p><p>看到这种二叉树求某个值的题目，对于我们这些基础比较薄弱的开发来说，不要想着上来就是一步到位，想着怎么能写出大牛们的那种解法。</p><p>我们可以先从最简单易懂的方法做起，先把题给做出来，不要怕写的太简单。所以这道题我们可以用<code>BFS遍历</code>的方法来做。</p><p>我们先大概了解下<code>BFS</code>和<code>DFS</code>。</p><blockquote><p>BFS：Breadth-First-Search，宽度（广度）优先搜索；DFS：Depth-first search，深度优先搜索。<br>二者都是对图或树的一种搜索或遍历方法，只不过搜索的形式不一样。对于一个图来说，搜索就是从某个点开始，不停的搜索与他相连的所有的点，然后以此接连下去，直到所有的点都被搜索到了。</p></blockquote><p>上面只是一个简答的介绍，介绍的比较详细的可以看下这篇文章<a href="https://zhuanlan.zhihu.com/p/127174138" target="_blank" rel="noopener">BFS &amp; DFS</a></p><p>我们正常的遍历是<code>从上往下</code>、<code>从左往右</code>，但是要注意这里题目要求的是<code>左下角</code>的值，所以我们这里要<code>从右往左</code>，这样最后取出的值就是<code>树左下角</code>的值了！</p><p>首先我们定义一个数组<code>queue = []</code>和<code>res = 0</code>用来做记录。</p><p>然后我们将给定的二叉树<code>root</code>添加到<code>queue</code>数组中对它进行遍历。</p><p>每次先取出当前节点的值<code>queue.shift()</code>，然后用<code>res</code>来记录这个值。</p><p>按照上面所说的<code>从右往左</code>的顺序，我们先判断当前节点的<code>right</code>，添加到数组<code>queue</code>中。</p><p>然后判断当前节点的<code>left</code>，添加到数组<code>queue</code>中。</p><p>直到遍历到最后一个，这个元素肯定就是树<code>最左边</code>的值了！</p><p>这个时候有兴趣的就可以继续研究如何优化了！</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var findBottomLeftValue &#x3D; function(root) &#123;</span><br><span class="line">    let queue &#x3D; [];</span><br><span class="line">    let res &#x3D; 0;</span><br><span class="line">    queue.push(root);</span><br><span class="line">    while(queue.length) &#123;</span><br><span class="line">        const node &#x3D; queue.shift();</span><br><span class="line">        res &#x3D; node.val;</span><br><span class="line">        if (node.right) &#123;</span><br><span class="line">            queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.left) &#123;</span><br><span class="line">            queue.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="刷题打卡记录"><a href="#刷题打卡记录" class="headerlink" title="刷题打卡记录"></a>刷题打卡记录</h3><p>这里是之前的刷题打卡记录，大家有兴趣的可以看下，如果有什么不同的见解和看法或者觉得有什么错误的，欢迎在评论区留言！🙏🙏🙏</p><p><a href="https://juejin.cn/post/6934563298180333581" target="_blank" rel="noopener">[LeetCode0303题区域和检索 - 数组不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934660944475717646" target="_blank" rel="noopener">[LeetCode1200. 最小绝对差] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934918546619105288" target="_blank" rel="noopener">[LeetCode0304题二维区域和检索 - 矩阵不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935086070560194568" target="_blank" rel="noopener">[LeetCode11题盛最多水的容器] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935249377183137829" target="_blank" rel="noopener">[LeetCode0338题比特位计数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935454523255160863" target="_blank" rel="noopener">[LeetCode209题长度最小的子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935665904986357796" target="_blank" rel="noopener">[LeetCode236题二叉树的最近公共祖先] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935690559067521061" target="_blank" rel="noopener">[LeetCode141题环形链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936070093278871560" target="_blank" rel="noopener">[LeetCode53题最大子序和] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936183050594156551" target="_blank" rel="noopener">[LeetCode48题旋转图像] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936930668551077925" target="_blank" rel="noopener">[LeetCode155题最小栈] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937188252432465933" target="_blank" rel="noopener">[LeetCode1124题表现良好的最长时间段] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937219016452734989" target="_blank" rel="noopener">[LeetCode274题H指数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937290523367440391" target="_blank" rel="noopener">[LeetCode367题有效的完全平方数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937464816500113421" target="_blank" rel="noopener">[LeetCode1047题删除字符串中的所有相邻重复项] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937577608624209956" target="_blank" rel="noopener">[LeetCode160题相交链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937681886776918046" target="_blank" rel="noopener">[LeetCode1438题绝对差不超过限制的最长连续子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937838732502368293" target="_blank" rel="noopener">[LeetCode434题字符串中的单词数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937944127577260062" target="_blank" rel="noopener">[LeetCode75题颜色分类] | 刷题打卡</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>加油！hxdm！！！💪💪💪</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;题目地址：&lt;a href=&quot;https://leetcode-cn.com/problems/find-bottom-left-tree-value/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;513. 找树左下角的值&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://brookliu.xyz/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="https://brookliu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://brookliu.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode434题字符串中的单词数] | 刷题打卡 </title>
    <link href="https://brookliu.xyz/2021/03/10/LeetCode434%E9%A2%98%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    <id>https://brookliu.xyz/2021/03/10/LeetCode434%E9%A2%98%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/</id>
    <published>2021-03-10T02:26:55.000Z</published>
    <updated>2021-03-15T03:27:19.328Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>本题是<a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/" target="_blank" rel="noopener">434. 字符串中的单词数</a></p><a id="more"></a> <p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</p><p>请注意，你可以假定字符串里不包括任何不可打印的字符。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;Hello, my name is John&quot;</span><br><span class="line">输出: 5</span><br><span class="line">解释: 这里的单词是指连续的不是空格的字符，所以 &quot;Hello,&quot; 算作 1 个单词。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目给定字符串<code>s</code>，要求统计字符串中的单词个数，必须是连续的不是空格的。</p><p>所以我们可以先用<code>split</code>用空格分割字符串为数组。</p><p>然后用<code>filter</code>去过滤数组中为空的元素。</p><p>然后返回剩下的数组长度就是符合我们这道题目要求的长度了。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var countSegments &#x3D; function (s) &#123;</span><br><span class="line">    return s.split(&quot; &quot;).filter((item) &#x3D;&gt; item !&#x3D;&#x3D; &quot;&quot;).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="刷题打卡记录"><a href="#刷题打卡记录" class="headerlink" title="刷题打卡记录"></a>刷题打卡记录</h3><p>这里是之前的刷题打卡记录，大家有兴趣的可以看下，如果有什么不同的见解和看法或者觉得有什么错误的，欢迎在评论区留言！🙏🙏🙏</p><p><a href="https://juejin.cn/post/6934563298180333581" target="_blank" rel="noopener">[LeetCode0303题区域和检索 - 数组不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934660944475717646" target="_blank" rel="noopener">[LeetCode1200. 最小绝对差] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934918546619105288" target="_blank" rel="noopener">[LeetCode0304题二维区域和检索 - 矩阵不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935086070560194568" target="_blank" rel="noopener">[LeetCode11题盛最多水的容器] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935249377183137829" target="_blank" rel="noopener">[LeetCode0338题比特位计数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935454523255160863" target="_blank" rel="noopener">[LeetCode209题长度最小的子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935665904986357796" target="_blank" rel="noopener">[LeetCode236题二叉树的最近公共祖先] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935690559067521061" target="_blank" rel="noopener">[LeetCode141题环形链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936070093278871560" target="_blank" rel="noopener">[LeetCode53题最大子序和] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936183050594156551" target="_blank" rel="noopener">[LeetCode48题旋转图像] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936930668551077925" target="_blank" rel="noopener">[LeetCode155题最小栈] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937188252432465933" target="_blank" rel="noopener">[LeetCode1124题表现良好的最长时间段] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937219016452734989" target="_blank" rel="noopener">[LeetCode274题H指数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937290523367440391" target="_blank" rel="noopener">[LeetCode367题有效的完全平方数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937464816500113421" target="_blank" rel="noopener">[LeetCode1047题删除字符串中的所有相邻重复项] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937577608624209956" target="_blank" rel="noopener">[LeetCode160题相交链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937681886776918046" target="_blank" rel="noopener">[LeetCode1438题绝对差不超过限制的最长连续子数组] | 刷题打卡</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>加油！hxdm！！！💪💪💪</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h3&gt;&lt;p&gt;本题是&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-segments-in-a-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;434. 字符串中的单词数&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://brookliu.xyz/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="https://brookliu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://brookliu.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode1438题绝对差不超过限制的最长连续子数组] | 刷题打卡</title>
    <link href="https://brookliu.xyz/2021/03/09/LeetCode1438%E9%A2%98%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    <id>https://brookliu.xyz/2021/03/09/LeetCode1438%E9%A2%98%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/</id>
    <published>2021-03-09T07:26:04.000Z</published>
    <updated>2021-03-15T03:26:36.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank" rel="noopener">1438. 绝对差不超过限制的最长连续子数组</a></p><a id="more"></a> <p>给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。</p><p>如果不存在满足条件的子数组，则返回 0 。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [8,2,4,7], limit &#x3D; 4</span><br><span class="line">输出：2 </span><br><span class="line">解释：所有子数组如下：</span><br><span class="line">[8] 最大绝对差 |8-8| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[8,2] 最大绝对差 |8-2| &#x3D; 6 &gt; 4. </span><br><span class="line">[8,2,4] 最大绝对差 |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">[8,2,4,7] 最大绝对差 |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">[2] 最大绝对差 |2-2| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[2,4] 最大绝对差 |2-4| &#x3D; 2 &lt;&#x3D; 4.</span><br><span class="line">[2,4,7] 最大绝对差 |2-7| &#x3D; 5 &gt; 4.</span><br><span class="line">[4] 最大绝对差 |4-4| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[4,7] 最大绝对差 |4-7| &#x3D; 3 &lt;&#x3D; 4.</span><br><span class="line">[7] 最大绝对差 |7-7| &#x3D; 0 &lt;&#x3D; 4. </span><br><span class="line">因此，满足题意的最长子数组的长度为 2 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [10,1,2,4,7,2], limit &#x3D; 5</span><br><span class="line">输出：4 </span><br><span class="line">解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| &#x3D; 5 &lt;&#x3D; 5 。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,2,2,2,4,4,2,2], limit &#x3D; 0</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 10^5</li><li>1 &lt;= nums[i] &lt;= 10^9</li><li>0 &lt;= limit &lt;= 10^9</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目给定整数数组<code>nums</code>和整数<code>limit</code>，要返回最长连续子数组的长度，这个最长连续子数组还要满足<code>两个元素之间的绝对差必须小于或者等于 limit</code>。</p><p>所以我们需要统计当前窗口内的最大值与最小值，因此我们也可以分别使用两个单调队列解决这道题。</p><p>因此，我们使用一个单调递增的队列<code>minQ</code> 维护最小值，一个单调递减的队列 <code>maxQ</code> 维护最大值。</p><p>然后我们只需要计算两个队列的队首的差值，即可知道当前窗口是否满足条件。</p><p>然后返回结果即可。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var longestSubArray &#x3D; function(nums, limit) &#123;</span><br><span class="line">  let maxQ &#x3D; [], minQ &#x3D; [], i &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  for (let a of nums) &#123;</span><br><span class="line">    while(maxQ.length &gt; 0 &amp;&amp; a &gt; maxQ[maxQ.length - 1]) &#123;</span><br><span class="line">      maxQ.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    while(minQ.length &gt; 0 &amp;&amp; a &lt; minQ[minQ.length - 1]) &#123;</span><br><span class="line">      minQ.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    maxQ.push(a);</span><br><span class="line">    minQ.push(a);</span><br><span class="line"></span><br><span class="line">    if (maxQ[0] - minQ[0] &gt; limit) &#123;</span><br><span class="line">      if (maxQ[0] &#x3D;&#x3D; nums[i]) &#123;</span><br><span class="line">        maxQ.shift();</span><br><span class="line">      &#125;</span><br><span class="line">      if (minQ[0] &#x3D;&#x3D; nums[i]) &#123;</span><br><span class="line">        minQ.shift();</span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return nums.length - i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="刷题打卡记录"><a href="#刷题打卡记录" class="headerlink" title="刷题打卡记录"></a>刷题打卡记录</h3><p>这里是之前的刷题打卡记录，大家有兴趣的可以看下，如果有什么不同的见解和看法或者觉得有什么错误的，欢迎在评论区留言！🙏🙏🙏</p><p><a href="https://juejin.cn/post/6934563298180333581" target="_blank" rel="noopener">[LeetCode0303题区域和检索 - 数组不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934660944475717646" target="_blank" rel="noopener">[LeetCode1200. 最小绝对差] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934918546619105288" target="_blank" rel="noopener">[LeetCode0304题二维区域和检索 - 矩阵不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935086070560194568" target="_blank" rel="noopener">[LeetCode11题盛最多水的容器] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935249377183137829" target="_blank" rel="noopener">[LeetCode0338题比特位计数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935454523255160863" target="_blank" rel="noopener">[LeetCode209题长度最小的子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935665904986357796" target="_blank" rel="noopener">[LeetCode236题二叉树的最近公共祖先] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935690559067521061" target="_blank" rel="noopener">[LeetCode141题环形链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936070093278871560" target="_blank" rel="noopener">[LeetCode53题最大子序和] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936183050594156551" target="_blank" rel="noopener">[LeetCode48题旋转图像] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936930668551077925" target="_blank" rel="noopener">[LeetCode155题最小栈] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937188252432465933" target="_blank" rel="noopener">[LeetCode1124题表现良好的最长时间段] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937219016452734989" target="_blank" rel="noopener">[LeetCode274题H指数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937290523367440391" target="_blank" rel="noopener">[LeetCode367题有效的完全平方数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937464816500113421" target="_blank" rel="noopener">[LeetCode1047题删除字符串中的所有相邻重复项] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937577608624209956" target="_blank" rel="noopener">[LeetCode160题相交链表] | 刷题打卡</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>加油！hxdm！！！💪💪💪</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1438. 绝对差不超过限制的最长连续子数组&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://brookliu.xyz/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="https://brookliu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://brookliu.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode160题相交链表] | 刷题打卡</title>
    <link href="https://brookliu.xyz/2021/03/09/LeetCode160%E9%A2%98%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    <id>https://brookliu.xyz/2021/03/09/LeetCode160%E9%A2%98%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/</id>
    <published>2021-03-09T02:25:27.000Z</published>
    <updated>2021-03-15T03:25:52.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a></p><a id="more"></a> <p>编写一个程序，找到两个单链表相交的起始节点。</p><p>如下面的两个链表：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b2d0b118f3f4daa866b9233964c440c~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>在节点 c1 开始相交。</p><p>示例 1：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3546d6d0ffe442e19451343c6bb2238b~tplv-k3u1fbpfcp-watermark.image" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f16492e016245c6bb2d55b047a01683~tplv-k3u1fbpfcp-watermark.image" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p>示例 3：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/359ed12cdb204a7386463595e4a0939d~tplv-k3u1fbpfcp-watermark.image" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果两个链表没有交点，返回 null.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>找到两个单链表相交的起始节点，我们可以用以下几种方式来解答这道题：</p><h4 id="标记法"><a href="#标记法" class="headerlink" title="标记法"></a>标记法</h4><p>对两个链表进行两次<code>while</code>遍历，先遍历一个链表，给链表中的每个节点都增加一个标志位<code>flag</code>，然后再去遍历另外一个链表，如果遍历到第一个已被标志过的节点则为两链表相交的起始节点。</p><p>如果遍历完都没有发现已被标志过的节点，则两链表不相交，返回 null。</p><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><p>初始化两个指针pA和pB分别指向headA和headB，每次pA和pB各走一步，当pA触底后变轨到headB，同理，当pB触底后变轨到headA。这样就只需遍历（A的非公共部分+B的非公共部分+AB的公共部分即可)。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="标记法-1"><a href="#标记法-1" class="headerlink" title="标记法"></a>标记法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var getIntersectionNode &#x3D; function(headA, headB) &#123;</span><br><span class="line">    while(headA) &#123;</span><br><span class="line">        headA.flag &#x3D; true</span><br><span class="line">        headA &#x3D; headA.next</span><br><span class="line">    &#125;</span><br><span class="line">    while(headB) &#123;</span><br><span class="line">        if (headB.flag) return headB</span><br><span class="line">        headB &#x3D; headB.next</span><br><span class="line">    &#125;</span><br><span class="line">    return null</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var getIntersectionNode &#x3D; function(headA, headB) &#123;</span><br><span class="line">    var pA &#x3D; headA;</span><br><span class="line">    var pB &#x3D; headB;</span><br><span class="line">    while(pA !&#x3D;&#x3D; pB)&#123;</span><br><span class="line">        pB &#x3D; pB? pB.next: headA;</span><br><span class="line">        pA &#x3D; pA? pA.next: headB;</span><br><span class="line">    &#125;</span><br><span class="line">    return pA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="刷题打卡记录"><a href="#刷题打卡记录" class="headerlink" title="刷题打卡记录"></a>刷题打卡记录</h3><p>这里是之前的刷题打卡记录，大家有兴趣的可以看下，如果有什么不同的见解和看法或者觉得有什么错误的，欢迎在评论区留言！🙏🙏🙏</p><p><a href="https://juejin.cn/post/6934563298180333581" target="_blank" rel="noopener">[LeetCode0303题区域和检索 - 数组不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934660944475717646" target="_blank" rel="noopener">[LeetCode1200. 最小绝对差] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934918546619105288" target="_blank" rel="noopener">[LeetCode0304题二维区域和检索 - 矩阵不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935086070560194568" target="_blank" rel="noopener">[LeetCode11题盛最多水的容器] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935249377183137829" target="_blank" rel="noopener">[LeetCode0338题比特位计数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935454523255160863" target="_blank" rel="noopener">[LeetCode209题长度最小的子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935665904986357796" target="_blank" rel="noopener">[LeetCode236题二叉树的最近公共祖先] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935690559067521061" target="_blank" rel="noopener">[LeetCode141题环形链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936070093278871560" target="_blank" rel="noopener">[LeetCode53题最大子序和] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936183050594156551" target="_blank" rel="noopener">[LeetCode48题旋转图像] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936930668551077925" target="_blank" rel="noopener">[LeetCode155题最小栈] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937188252432465933" target="_blank" rel="noopener">[LeetCode1124题表现良好的最长时间段] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937219016452734989" target="_blank" rel="noopener">[LeetCode274题H指数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937290523367440391" target="_blank" rel="noopener">[LeetCode367题有效的完全平方数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937464816500113421" target="_blank" rel="noopener">[LeetCode1047题删除字符串中的所有相邻重复项] | 刷题打卡</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>加油！hxdm！！！💪💪💪</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;160. 相交链表&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://brookliu.xyz/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="https://brookliu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://brookliu.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode1047题删除字符串中的所有相邻重复项] | 刷题打卡 </title>
    <link href="https://brookliu.xyz/2021/03/09/LeetCode1047%E9%A2%98%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    <id>https://brookliu.xyz/2021/03/09/LeetCode1047%E9%A2%98%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/</id>
    <published>2021-03-09T00:24:40.000Z</published>
    <updated>2021-03-15T03:25:06.190Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>我们今天看的这道题是<a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/" target="_blank" rel="noopener">1047. 删除字符串中的所有相邻重复项</a>，是今天的<code>LeetCode每日一题</code>。</p><a id="more"></a> <p>给出由小写字母组成的字符串 S，<code>重复项删除操作</code>会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abbaca&quot;</span><br><span class="line">输出：&quot;ca&quot;</span><br><span class="line">解释：</span><br><span class="line">例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= S.length &lt;= 20000</li><li>S 仅由小写英文字母组成。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p> 给定字符串<code>S</code>,要返回删除所有重复项之后的结果，所以我们可以利用栈的形式来解答这道题。</p><p> 遍历字符串，依次入栈，入栈时判断与栈头元素是否一致？</p><ul><li><p>如果一致，即这两个元素相同相邻，则需要将栈头元素出栈，并且当前元素也无需入栈。</p></li><li><p>不一致，栈头字符进栈，当前字符进栈</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> var removeDuplicates &#x3D; function(S) &#123;</span><br><span class="line">  let res &#x3D; [];</span><br><span class="line">  for (let c of S) &#123;</span><br><span class="line">    if (res.length &gt; 0 &amp;&amp; c &#x3D;&#x3D; res[res.length - 1]) &#123;</span><br><span class="line">      res.pop()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      res.push(c)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res.join(&#39;&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="刷题打卡记录"><a href="#刷题打卡记录" class="headerlink" title="刷题打卡记录"></a>刷题打卡记录</h3><p>这里是之前的刷题打卡记录，大家有兴趣的可以看下，如果有什么不同的见解和看法或者觉得有什么错误的，欢迎在评论区留言！🙏🙏🙏</p><p><a href="https://juejin.cn/post/6934563298180333581" target="_blank" rel="noopener">[LeetCode0303题区域和检索 - 数组不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934660944475717646" target="_blank" rel="noopener">[LeetCode1200. 最小绝对差] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934918546619105288" target="_blank" rel="noopener">[LeetCode0304题二维区域和检索 - 矩阵不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935086070560194568" target="_blank" rel="noopener">[LeetCode11题盛最多水的容器] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935249377183137829" target="_blank" rel="noopener">[LeetCode0338题比特位计数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935454523255160863" target="_blank" rel="noopener">[LeetCode209题长度最小的子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935665904986357796" target="_blank" rel="noopener">[LeetCode236题二叉树的最近公共祖先] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935690559067521061" target="_blank" rel="noopener">[LeetCode141题环形链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936070093278871560" target="_blank" rel="noopener">[LeetCode53题最大子序和] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936183050594156551" target="_blank" rel="noopener">[LeetCode48题旋转图像] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936930668551077925" target="_blank" rel="noopener">[LeetCode155题最小栈] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937188252432465933" target="_blank" rel="noopener">[LeetCode1124题表现良好的最长时间段] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937219016452734989" target="_blank" rel="noopener">[LeetCode274题H指数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937290523367440391" target="_blank" rel="noopener">[LeetCode367题有效的完全平方数] | 刷题打卡</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>加油！hxdm！！！💪💪💪</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;我们今天看的这道题是&lt;a href=&quot;https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1047. 删除字符串中的所有相邻重复项&lt;/a&gt;，是今天的&lt;code&gt;LeetCode每日一题&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://brookliu.xyz/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="https://brookliu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://brookliu.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode367题有效的完全平方数] | 刷题打卡</title>
    <link href="https://brookliu.xyz/2021/03/08/LeetCode367%E9%A2%98%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    <id>https://brookliu.xyz/2021/03/08/LeetCode367%E9%A2%98%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/</id>
    <published>2021-03-08T09:24:02.000Z</published>
    <updated>2021-03-15T03:24:28.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode-cn.com/problems/valid-perfect-square/" target="_blank" rel="noopener">367. 有效的完全平方数</a></p><a id="more"></a> <p>给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。</p><p>说明：不要使用任何内置的库函数，如  sqrt。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：16</span><br><span class="line">输出：True</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：14</span><br><span class="line">输出：False</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目要求判断给定的正整数<code>num</code>是<code>完全平方数</code>。</p><p>首先我们先来回顾下<code>完全平方数</code>的定义:</p><blockquote><p>完全平方指用一个整数乘以自己例如1<em>1，2</em>2，3*3等，依此类推。若一个数能表示成某个整数的平方的形式，则称这个数为完全平方数。完全平方数是非负数，而一个完全平方数的项有两个。注意不要与完全平方式所混淆。<a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/8025061?fr=aladdin" target="_blank" rel="noopener">完全平方数</a>。</p></blockquote><p>然后我们可以大概想到这道题的集中解法：</p><h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><p>我们直接用<code>for</code>循环，在<code>num</code>一半的范围内以此类推判断是否满足条件，满足则返回<code>true</code>，反之则返回<code>false</code>。</p><h4 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h4><p>用<code>left = 1, right = num</code>来表示左右两端点，然后取<code>left</code>和<code>right</code>的中间值<code>mid=parseInt((left+right)/2)</code>，用<code>temp = mid * mid</code>来和<code>num</code>做比较，<code>temp &gt; num</code>的话，表示超出范围，则<code>mid--</code>，反之则<code>mid++</code>，<code>temp == num</code>的话则返回<code>true</code>，以此类推。</p><h4 id="数理法"><a href="#数理法" class="headerlink" title="数理法"></a>数理法</h4><blockquote><p>任意一个平方数都可以表示出下面的奇数序列和:</p><blockquote><p>1+3+5+7+…+(2N−1)=N^2</p></blockquote></blockquote><p>依据数理规律即可。</p><h4 id="牛顿迭代"><a href="#牛顿迭代" class="headerlink" title="牛顿迭代"></a>牛顿迭代</h4><p>依据下列公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x&#x3D; (x+tmp_x&#x2F;x)&#x2F;2</span><br></pre></td></tr></table></figure><p><a href="https://baike.baidu.com/item/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/10887580?fr=aladdin" target="_blank" rel="noopener">牛顿迭代法</a></p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var isPerfectSquare &#x3D; function(num) &#123;</span><br><span class="line">    if(num &#x3D;&#x3D; 1) return true;</span><br><span class="line">    const mid &#x3D; num &#x2F; 2;</span><br><span class="line">    for(let i &#x3D; 1; i &lt;&#x3D; mid; i++)&#123;</span><br><span class="line">        if(i*i &#x3D;&#x3D; num)&#123;</span><br><span class="line">           return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二分法-1"><a href="#二分法-1" class="headerlink" title="二分法"></a>二分法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var isPerfectSquare &#x3D; function(num) &#123;</span><br><span class="line">    if(num &#x3D;&#x3D; 1) return true;</span><br><span class="line">    let left &#x3D; 1,right &#x3D; num;</span><br><span class="line">    while(left &lt;&#x3D; right)&#123;</span><br><span class="line">        let mid &#x3D; parseInt((left+right)&#x2F;2);</span><br><span class="line">        let temp &#x3D; mid*mid;</span><br><span class="line">        if(temp &#x3D;&#x3D; num)&#123;</span><br><span class="line">             return true;</span><br><span class="line">        &#125;else if(temp &gt; num)&#123;</span><br><span class="line">             right &#x3D; mid-1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            left &#x3D; mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数理法-1"><a href="#数理法-1" class="headerlink" title="数理法"></a>数理法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var isPerfectSquare &#x3D; function(num) &#123;</span><br><span class="line">        let i &#x3D; 1;</span><br><span class="line">        while(num &gt; 0) &#123;</span><br><span class="line">            num -&#x3D; i;</span><br><span class="line">            i +&#x3D; 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return num &#x3D;&#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var isPerfectSquare &#x3D; function(num) &#123;</span><br><span class="line">    if(num &#x3D;&#x3D; 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    var tmp &#x3D; num;</span><br><span class="line">    while(num*num &gt; tmp)&#123;</span><br><span class="line">        num &#x3D; (num+tmp&#x2F;num)&#x2F;2 | 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return num*num &#x3D;&#x3D; tmp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="刷题打卡记录"><a href="#刷题打卡记录" class="headerlink" title="刷题打卡记录"></a>刷题打卡记录</h3><p>这里是之前的刷题打卡记录，大家有兴趣的可以看下，如果有什么不同的见解和看法或者觉得有什么错误的，欢迎在评论区留言！🙏🙏🙏</p><p><a href="https://juejin.cn/post/6934563298180333581" target="_blank" rel="noopener">[LeetCode0303题区域和检索 - 数组不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934660944475717646" target="_blank" rel="noopener">[LeetCode1200. 最小绝对差] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934918546619105288" target="_blank" rel="noopener">[LeetCode0304题二维区域和检索 - 矩阵不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935086070560194568" target="_blank" rel="noopener">[LeetCode11题盛最多水的容器] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935249377183137829" target="_blank" rel="noopener">[LeetCode0338题比特位计数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935454523255160863" target="_blank" rel="noopener">[LeetCode209题长度最小的子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935665904986357796" target="_blank" rel="noopener">[LeetCode236题二叉树的最近公共祖先] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935690559067521061" target="_blank" rel="noopener">[LeetCode141题环形链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936070093278871560" target="_blank" rel="noopener">[LeetCode53题最大子序和] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936183050594156551" target="_blank" rel="noopener">[LeetCode48题旋转图像] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936930668551077925" target="_blank" rel="noopener">[LeetCode155题最小栈] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937188252432465933" target="_blank" rel="noopener">[LeetCode1124题表现良好的最长时间段] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937219016452734989" target="_blank" rel="noopener">[LeetCode274题H指数] | 刷题打卡</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>加油！hxdm！！！💪💪💪</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-perfect-square/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;367. 有效的完全平方数&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://brookliu.xyz/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="https://brookliu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://brookliu.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode274题H指数] | 刷题打卡</title>
    <link href="https://brookliu.xyz/2021/03/08/LeetCode274%E9%A2%98H%E6%8C%87%E6%95%B0-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    <id>https://brookliu.xyz/2021/03/08/LeetCode274%E9%A2%98H%E6%8C%87%E6%95%B0-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/</id>
    <published>2021-03-08T05:53:15.000Z</published>
    <updated>2021-03-15T03:23:50.810Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>这道题是<a href="https://leetcode-cn.com/problems/h-index/" target="_blank" rel="noopener">LeetCode274. H 指数</a>，难度medium。</p><a id="more"></a> <p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。</p><p>h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 N - h 篇论文每篇被引用次数 不超过 h 次。</p><p>例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：citations &#x3D; [3,0,6,1,5]</span><br><span class="line">输出：3 </span><br><span class="line">解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。</span><br><span class="line">     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。</span><br></pre></td></tr></table></figure><p>提示：如果 h 有多种可能的值，h 指数是其中最大的那个。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目给定了一个数组<code>citations</code>，要求<code>h</code>。</p><p>我们先将数组<code>citations</code>升序排序，然后循环数组，用数组中的每一个元素和数组剩余长度做比较，然后再取较大值，即可得出结果。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var hIndex &#x3D; function(citations) &#123;</span><br><span class="line">  citations.sort((a, b) &#x3D;&gt; a - b);</span><br><span class="line">  let maxH &#x3D; 0;</span><br><span class="line">  for (let i &#x3D; 0; i &lt; citations.length; i++) &#123;</span><br><span class="line">    let temp &#x3D; 0;</span><br><span class="line">    if (citations[i] &lt;&#x3D; citations.length - i) &#123;</span><br><span class="line">      temp &#x3D; citations[i]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      temp &#x3D; citations.length - i</span><br><span class="line">    &#125;</span><br><span class="line">    maxH &#x3D; Math.max(maxH, temp)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="刷题打卡记录"><a href="#刷题打卡记录" class="headerlink" title="刷题打卡记录"></a>刷题打卡记录</h3><p>这里是之前的刷题打卡记录，大家有兴趣的可以看下，如果有什么不同的见解和看法或者觉得有什么错误的，欢迎在评论区留言！🙏🙏🙏</p><p><a href="https://juejin.cn/post/6934563298180333581" target="_blank" rel="noopener">[LeetCode0303题区域和检索 - 数组不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934660944475717646" target="_blank" rel="noopener">[LeetCode1200. 最小绝对差] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934918546619105288" target="_blank" rel="noopener">[LeetCode0304题二维区域和检索 - 矩阵不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935086070560194568" target="_blank" rel="noopener">[LeetCode11题盛最多水的容器] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935249377183137829" target="_blank" rel="noopener">[LeetCode0338题比特位计数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935454523255160863" target="_blank" rel="noopener">[LeetCode209题长度最小的子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935665904986357796" target="_blank" rel="noopener">[LeetCode236题二叉树的最近公共祖先] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935690559067521061" target="_blank" rel="noopener">[LeetCode141题环形链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936070093278871560" target="_blank" rel="noopener">[LeetCode53题最大子序和] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936183050594156551" target="_blank" rel="noopener">[LeetCode48题旋转图像] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936930668551077925" target="_blank" rel="noopener">[LeetCode155题最小栈] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6937188252432465933" target="_blank" rel="noopener">[LeetCode1124题表现良好的最长时间段] | 刷题打卡</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>多写写题解还是很有必要的，不要怕写的不好，写的过程就是回顾的过程，更容易加深自己的理解。</p><p>加油！hxdm！！！💪💪💪</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;这道题是&lt;a href=&quot;https://leetcode-cn.com/problems/h-index/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode274. H 指数&lt;/a&gt;，难度medium。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://brookliu.xyz/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="https://brookliu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://brookliu.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode1124题表现良好的最长时间段] | 刷题打卡</title>
    <link href="https://brookliu.xyz/2021/03/08/LeetCode1124%E9%A2%98%E8%A1%A8%E7%8E%B0%E8%89%AF%E5%A5%BD%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%AE%B5-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    <id>https://brookliu.xyz/2021/03/08/LeetCode1124%E9%A2%98%E8%A1%A8%E7%8E%B0%E8%89%AF%E5%A5%BD%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%AE%B5-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/</id>
    <published>2021-03-08T03:22:38.000Z</published>
    <updated>2021-03-15T03:23:04.407Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。</p><a id="more"></a> <p>我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。</p><p>所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。</p><p>请你返回「表现良好时间段」的最大长度。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：hours &#x3D; [9,9,6,0,6,6,9]</span><br><span class="line">输出：3</span><br><span class="line">解释：最长的表现良好时间段是 [9,9,6]。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= hours.length &lt;= 10000</li><li>0 &lt;= hours[i] &lt;= 16</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>给定一个数组<code>hours</code>，求数组内符合条件的最大长度子数组，是不是跟之前写的几篇题解差不多了，那我们就用之前已经练过的前缀和来解决这道题吧！</p><p>既然是用前缀和来解答，那么先定义一个给定数组<code>hours</code>的长度<code>+1</code>的前缀和数组<code>pre_sum</code>，这里长度<code>+1</code>是为了和前一天做比较，然后<code>pre_sum</code>的每一项预先填充为<code>0</code>。</p><p>循环<code>hours</code>数组，判断数组中的每一项和<code>8</code>的大小，<code>&gt;8</code>就等于前缀和数组中前一项<code>+1</code>，反之则<code>-1</code>。</p><p>得到前缀和数组<code>pre_sum</code>，要先满足<code>表示良好时间段</code>，即<code>pre_sum</code>数组中两个元素的差<code>&gt;0</code>。</p><p>要求最大长度，即满足<code>pre_sum</code>数组中两个元素差<code>&gt;0</code>的最大值即可。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; hours</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var longestWPI &#x3D; function(hours) &#123;</span><br><span class="line">    const n &#x3D; hours.length;</span><br><span class="line">    let pre_sum &#x3D; new Array(n + 1).fill(0)</span><br><span class="line">    for (let i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        if (hours[i-1] &gt; 8) &#123;</span><br><span class="line">            pre_sum[i] &#x3D; pre_sum[i - 1] + 1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pre_sum[i] &#x3D; pre_sum[i - 1] - 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let res &#x3D; 0</span><br><span class="line">    const m &#x3D; pre_sum.length;</span><br><span class="line">    for (let i &#x3D; 0; i&lt; m-1; i++)&#123;</span><br><span class="line">        for (let j &#x3D;i+1; j&lt; m; j++)&#123;</span><br><span class="line">            if (pre_sum[j] - pre_sum[i] &gt;0)&#123;</span><br><span class="line">                res &#x3D; Math.max(res, j-i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="刷题打卡记录"><a href="#刷题打卡记录" class="headerlink" title="刷题打卡记录"></a>刷题打卡记录</h3><p>这里是之前的刷题打卡记录，大家有兴趣的可以看下，如果有什么不同的见解和看法或者觉得有什么错误的，欢迎在评论区留言！🙏🙏🙏</p><p><a href="https://juejin.cn/post/6934563298180333581" target="_blank" rel="noopener">[LeetCode0303题区域和检索 - 数组不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934660944475717646" target="_blank" rel="noopener">[LeetCode1200. 最小绝对差] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934918546619105288" target="_blank" rel="noopener">[LeetCode0304题二维区域和检索 - 矩阵不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935086070560194568" target="_blank" rel="noopener">[LeetCode11题盛最多水的容器] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935249377183137829" target="_blank" rel="noopener">[LeetCode0338题比特位计数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935454523255160863" target="_blank" rel="noopener">[LeetCode209题长度最小的子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935665904986357796" target="_blank" rel="noopener">[LeetCode236题二叉树的最近公共祖先] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935690559067521061" target="_blank" rel="noopener">[LeetCode141题环形链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936070093278871560" target="_blank" rel="noopener">[LeetCode53题最大子序和] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936183050594156551" target="_blank" rel="noopener">[LeetCode48题旋转图像] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936930668551077925" target="_blank" rel="noopener">[LeetCode155题最小栈] | 刷题打卡</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>多写写题解还是很有必要的，不要怕写的不好，写的过程就是回顾的过程，更容易加深自己的理解。</p><p>加油！hxdm！！！💪💪💪</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://brookliu.xyz/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="https://brookliu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://brookliu.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode155题最小栈] | 刷题打卡</title>
    <link href="https://brookliu.xyz/2021/03/07/LeetCode155%E9%A2%98%E6%9C%80%E5%B0%8F%E6%A0%88-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    <id>https://brookliu.xyz/2021/03/07/LeetCode155%E9%A2%98%E6%9C%80%E5%B0%8F%E6%A0%88-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/</id>
    <published>2021-03-07T03:21:52.000Z</published>
    <updated>2021-03-15T03:22:26.740Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><a id="more"></a> <ul><li>push(x) —— 将元素 x 推入栈中。</li><li>pop() —— 删除栈顶的元素。</li><li>top() —— 获取栈顶元素。</li><li>getMin() —— 检索栈中的最小元素。</li></ul><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>pop、top 和 getMin 操作总是在 非空栈 上调用。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>看完题目，其实应该明白这道题的解法了，特别是对前端来说，看见题目中描述的<code>push</code>、<code>pop</code>这两个方法就想到数组的方法。用数组<code>stack</code>来描述栈。</p><p>对于<code>push</code>、<code>pop</code>方法我们可以直接用数组的<code>push</code>和<code>pop</code>来做，但是我们要注意到题目中要求的<code>检索最小元素</code>，所以我们这里要把这个要求给考虑进来，用<code>min_val</code>来表示最小元素，初始值设为<code>正无穷大</code>。</p><p><code>push</code>的时候用元素<code>x</code>和<code>min_val</code>来做比较，<code>min_val</code>取两者的最小值。</p><p><code>pop</code>的时候判断数组末尾元素是否和<code>min_val</code>相等来更新<code>min_val</code>的值。</p><p><code>top</code>的时候直接取数组的末尾元素就行了。</p><p><code>getMin</code>的时候直接返回<code>min_val</code>就可以了。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * initialize your data structure here.</span><br><span class="line"> *&#x2F;</span><br><span class="line"> var MinStack &#x3D; function() &#123;</span><br><span class="line">  this.stack &#x3D; []</span><br><span class="line">  this.min_val &#x3D; Infinity</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> * @param &#123;number&#125; x</span><br><span class="line"> * @return &#123;void&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">MinStack.prototype.push &#x3D; function(x) &#123;</span><br><span class="line">  if (x &lt;&#x3D; this.min_val) &#123;</span><br><span class="line">    this.stack.push(this.min_val)</span><br><span class="line">    this.min_val &#x3D; x</span><br><span class="line">  &#125;</span><br><span class="line">  this.stack.push(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @return &#123;void&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">MinStack.prototype.pop &#x3D; function() &#123;</span><br><span class="line">  if (this.stack[this.stack.length - 1] &#x3D;&#x3D;&#x3D; this.min_val) &#123;</span><br><span class="line">    this.stack.pop()</span><br><span class="line">    this.min_val &#x3D; this.stack[this.stack.length - 1]</span><br><span class="line">    this.stack.pop()</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    this.stack.pop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">MinStack.prototype.top &#x3D; function() &#123;</span><br><span class="line">  return this.stack[this.stack.length - 1]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">MinStack.prototype.getMin &#x3D; function() &#123;</span><br><span class="line">  return this.min_val</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="刷题打卡记录"><a href="#刷题打卡记录" class="headerlink" title="刷题打卡记录"></a>刷题打卡记录</h3><p>这里是之前的刷题打卡记录，大家有兴趣的可以看下，如果有什么不同的见解和看法或者觉得有什么错误的，欢迎在评论区留言！🙏🙏🙏</p><p><a href="https://juejin.cn/post/6934563298180333581" target="_blank" rel="noopener">[LeetCode0303题区域和检索 - 数组不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934660944475717646" target="_blank" rel="noopener">[LeetCode1200. 最小绝对差] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934918546619105288" target="_blank" rel="noopener">[LeetCode0304题二维区域和检索 - 矩阵不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935086070560194568" target="_blank" rel="noopener">[LeetCode11题盛最多水的容器] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935249377183137829" target="_blank" rel="noopener">[LeetCode0338题比特位计数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935454523255160863" target="_blank" rel="noopener">[LeetCode209题长度最小的子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935665904986357796" target="_blank" rel="noopener">[LeetCode236题二叉树的最近公共祖先] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935690559067521061" target="_blank" rel="noopener">[LeetCode141题环形链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936070093278871560" target="_blank" rel="noopener">[LeetCode53题最大子序和] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936183050594156551" target="_blank" rel="noopener">[LeetCode48题旋转图像] | 刷题打卡</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>多写写题解还是很有必要的，不要怕写的不好，写的过程就是回顾的过程，更容易加深自己的理解。</p><p>加油！hxdm！！！💪💪💪</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://brookliu.xyz/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="https://brookliu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://brookliu.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode48题旋转图像] | 刷题打卡</title>
    <link href="https://brookliu.xyz/2021/03/05/LeetCode48%E9%A2%98%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    <id>https://brookliu.xyz/2021/03/05/LeetCode48%E9%A2%98%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/</id>
    <published>2021-03-05T03:21:09.000Z</published>
    <updated>2021-03-15T03:21:36.862Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">48.旋转图像</a></p><a id="more"></a> <p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p>示例 1：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f55b53d900e644eeb10fca9fb52727ab~tplv-k3u1fbpfcp-watermark.image" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab1f91a831174f8498d7ed8cabf28dd6~tplv-k3u1fbpfcp-watermark.image" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1]]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2],[3,4]]</span><br><span class="line">输出：[[3,1],[4,2]]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>matrix.length == n</li><li>matrix[i].length == n</li><li>1 &lt;= n &lt;= 20</li><li>-1000 &lt;= matrix[i][j] &lt;= 1000</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚看到题目的时候我没有思路，就是看完之后就感觉<code>哦</code>，然后就没有然后了，没有思路怎么办呢？</p><p>拿出小本本，用例题来找方法，找思路，就是各种乱试，其实我是不推荐这样的，主要是我是在是没有思路，就越看越困，所以就用这种方法。哪怕是错的，好歹能让我注意力集中上来。</p><p>第一步，如何能让<code>1</code>和<code>7</code>交换呢？翻转下数组。</p><p>这个时候<code>matrix</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[7, 8, 9],</span><br><span class="line">    [4, 5, 6],</span><br><span class="line">    [1, 2, 3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>嗯，完成了第一步想要的结果，然后呢？<code>4和8</code>、<code>1和9</code>怎么交换呢？</p><p>尝试下位置交换，然后结果就出来了。。。</p><p>点击提交。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96adaed0ed0d4452a5ddba5db48c05a0~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var rotate &#x3D; function(matrix) &#123;</span><br><span class="line">    matrix.reverse();</span><br><span class="line">    for (let i &#x3D; 0; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        for (let j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">            [matrix[i][j], matrix[j][i]] &#x3D; [matrix[j][i], matrix[i][j]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return matrix;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="刷题打卡记录"><a href="#刷题打卡记录" class="headerlink" title="刷题打卡记录"></a>刷题打卡记录</h3><p>这里是之前的刷题打卡记录，大家有兴趣的可以看下，如果有什么不同的见解和看法或者觉得有什么错误的，欢迎在评论区留言！🙏🙏🙏</p><p><a href="https://juejin.cn/post/6934563298180333581" target="_blank" rel="noopener">[LeetCode0303题区域和检索 - 数组不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934660944475717646" target="_blank" rel="noopener">[LeetCode1200. 最小绝对差] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934918546619105288" target="_blank" rel="noopener">[LeetCode0304题二维区域和检索 - 矩阵不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935086070560194568" target="_blank" rel="noopener">[LeetCode11题盛最多水的容器] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935249377183137829" target="_blank" rel="noopener">[LeetCode0338题比特位计数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935454523255160863" target="_blank" rel="noopener">[LeetCode209题长度最小的子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935665904986357796" target="_blank" rel="noopener">[LeetCode236题二叉树的最近公共祖先] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935690559067521061" target="_blank" rel="noopener">[LeetCode141题环形链表] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6936070093278871560" target="_blank" rel="noopener">[LeetCode53题最大子序和] | 刷题打卡</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>多写写题解还是很有必要的，不要怕写的不好，写的过程就是回顾的过程，更容易加深自己的理解。</p><p>加油！hxdm！！！💪💪💪</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/rotate-image/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;48.旋转图像&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://brookliu.xyz/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="https://brookliu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://brookliu.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode53题最大子序和] | 刷题打卡</title>
    <link href="https://brookliu.xyz/2021/03/05/LeetCode53%E9%A2%98%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    <id>https://brookliu.xyz/2021/03/05/LeetCode53%E9%A2%98%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/</id>
    <published>2021-03-05T00:20:29.000Z</published>
    <updated>2021-03-15T03:20:56.362Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a>.</p><a id="more"></a> <p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-1]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p>示例 5：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-100000]</span><br><span class="line">输出：-100000</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 3 * 10^4</li><li>-10^5 &lt;= nums[i] &lt;= 10^5</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>看到题目求最大子序和，很简单，我直接上来就是一个<code>for</code>循环，从<code>1</code>开始，和前一项做比较，如果前一项<code>&gt;0</code>,那么就用当前项加上前一项，为什么要用前一项<code>&gt;0</code>来作为条件呢？题目要求是<code>最大子序和</code>嘛，如果是<code>&lt;0</code>，那么就跳过从下一项开始，最后原数组就变成了一个计算后的结果数组，然后求结果数组的最大值就行了。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var maxSubArray &#x3D; function(nums) &#123;</span><br><span class="line">  const n &#x3D; nums.length;</span><br><span class="line">  for (let i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">    if (nums[i-1] &gt; 0) &#123;</span><br><span class="line">      nums[i] +&#x3D; nums[i-1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return Math.max.apply(this, nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="刷题打卡记录"><a href="#刷题打卡记录" class="headerlink" title="刷题打卡记录"></a>刷题打卡记录</h3><p>这里是之前的刷题打卡记录，大家有兴趣的可以看下，如果有什么不同的见解和看法或者觉得有什么错误的，欢迎在评论区留言！🙏🙏🙏</p><p><a href="https://juejin.cn/post/6934563298180333581" target="_blank" rel="noopener">[LeetCode0303题区域和检索 - 数组不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934660944475717646" target="_blank" rel="noopener">[LeetCode1200. 最小绝对差] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6934918546619105288" target="_blank" rel="noopener">[LeetCode0304题二维区域和检索 - 矩阵不可变] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935086070560194568" target="_blank" rel="noopener">[LeetCode11题盛最多水的容器] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935249377183137829" target="_blank" rel="noopener">[LeetCode0338题比特位计数] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935454523255160863" target="_blank" rel="noopener">[LeetCode209题长度最小的子数组] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935665904986357796" target="_blank" rel="noopener">[LeetCode236题二叉树的最近公共祖先] | 刷题打卡</a></p><p><a href="https://juejin.cn/post/6935690559067521061" target="_blank" rel="noopener">[LeetCode141题环形链表] | 刷题打卡</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>多写写题解还是很有必要的，不要怕写的不好，写的过程就是回顾的过程，更容易加深自己的理解。</p><p>加油！hxdm！！！💪💪💪</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;53. 最大子序和&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://brookliu.xyz/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="https://brookliu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://brookliu.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode141题环形链表] | 刷题打卡</title>
    <link href="https://brookliu.xyz/2021/03/04/LeetCode141%E9%A2%98%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    <id>https://brookliu.xyz/2021/03/04/LeetCode141%E9%A2%98%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/</id>
    <published>2021-03-04T03:19:03.000Z</published>
    <updated>2021-03-15T03:20:08.217Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表，判断链表中是否有环。</p><a id="more"></a> <p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p>进阶：</p><p>你能用 O(1)（即，常量）内存解决此问题吗？</p><p>示例 1：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0eedaece8694a83b9c30dd0e8767b73~tplv-k3u1fbpfcp-watermark.image" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b91600a042049b1af2294e0a71e4c6f~tplv-k3u1fbpfcp-watermark.image" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p>示例 3：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee7e2f73daa14acbbb0e0b947f960df9~tplv-k3u1fbpfcp-watermark.image" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>链表中节点的数目范围是 [0, 10^4]</li><li>-10^5 &lt;= Node.val &lt;= 10^5</li><li>pos 为 -1 或者链表中的一个 有效索引 。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p> 给定一个链表，判断链表中是否有环。这不就是链表中快慢指针的经典用法嘛！</p><p> 把链表比作一条跑道，链表中有环，那么这条跑道就是一条圆环跑道，在一条圆环跑道中，两个人有速度差，那么迟早两个人会相遇，只要相遇那么就说明有环。</p><p> 我们设定<code>fast、slow</code>两个指针跑进了环<code>head</code>里，那么因为存在速度差，他们之间的距离总会由远及近，然后相遇，在远离。像极了我们人世间某些人在你生命中匆匆而过的感觉。</p><blockquote><p>快慢指针中，因为每一次移动后，快指针都会比慢指针多走一个节点，所以他们之间在进入环状链表后，不论相隔多少个节点，慢指针总会被快指针赶上并且重合，此时就可以判断必定有环。</p></blockquote><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.next &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;ListNode&#125; head</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var hasCycle &#x3D; function(head) &#123;</span><br><span class="line">    let fast &#x3D; head</span><br><span class="line">    let slow &#x3D; head</span><br><span class="line">    while(fast) &#123;</span><br><span class="line">        if (fast.next &#x3D;&#x3D; null) return false</span><br><span class="line">        slow &#x3D; slow.next</span><br><span class="line">        fast &#x3D; fast.next.next</span><br><span class="line">        if (slow &#x3D;&#x3D; fast) return true</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 我在这道题的题解板块看到一个我觉得<code>巧用js</code>的解法，分享给大家看下:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> var hasCycle &#x3D; function(head) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        JSON.stringify(head)</span><br><span class="line">        return false</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这个解法就是利用了</p><blockquote><p>JSON.stringify当在循环引用时会抛出异常TypeError (“cyclic object value”)（循环对象值）</p></blockquote><p>我怎么就没想到呢！！！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>多写写题解还是很有必要的，不要怕写的不好，敢写就已经很不错了，写的过程就是回顾的过程，更容易加深自己的理解。</p><p>加油！hxdm！！！💪💪💪</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个链表，判断链表中是否有环。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://brookliu.xyz/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="https://brookliu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://brookliu.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode236题二叉树的最近公共祖先] | 刷题打卡</title>
    <link href="https://brookliu.xyz/2021/03/04/LeetCode236%E9%A2%98%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/"/>
    <id>https://brookliu.xyz/2021/03/04/LeetCode236%E9%A2%98%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1/</id>
    <published>2021-03-04T02:18:20.000Z</published>
    <updated>2021-03-15T03:20:04.676Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><a id="more"></a> <p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin" target="_blank" rel="noopener">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>示例 1：<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba5b45ce6e7745c4a1950b21cec8705f~tplv-k3u1fbpfcp-watermark.image" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4812aeca5ce4bdaa9c6ac220a362b8a~tplv-k3u1fbpfcp-watermark.image" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>树中节点数目在范围 [2, 10^5] 内。</li><li>-10^9 &lt;= Node.val &lt;= 10^9</li><li>所有 Node.val 互不相同 。</li><li>p != q</li><li>p 和 q 均存在于给定的二叉树中。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p> 给定一个二叉树<code>root</code>，找出<code>root</code>中指定节点<code>p</code>和<code>q</code>的最近公共祖先，对于公共祖先的定义上面也给了很清晰的解释。</p><p> 第一步，如果<code>root</code>为<code>null</code>，或者<code>root == p</code> 或者<code>root == q</code>即<code>p</code>和<code>q</code>在<code>root</code>的左右子树，这个时候可以直接返回<code>root</code>本身。</p><p> 第二步，<code>p</code>和<code>q</code>在<code>root</code>的同一子树，则传入<code>root</code>的左右子树和<code>p、q</code>节点递归搜索。</p><p> 如果左子树递归结果为<code>null</code>说明不在左子树中，则返回右子树。</p><p> 如果右子树递归结果为<code>null</code>说明不在右子树中，则返回左子树。</p><p> 如果左右子树的递归结果都为<code>null</code>，说明<code>p</code>和<code>q</code>不在<code>root</code>的左右子树中，返回<code>root</code>。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.left &#x3D; this.right &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @param &#123;TreeNode&#125; p</span><br><span class="line"> * @param &#123;TreeNode&#125; q</span><br><span class="line"> * @return &#123;TreeNode&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var lowestCommonAncestor &#x3D; function(root, p, q) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D;&#x3D; null || root &#x3D;&#x3D;&#x3D; p || root &#x3D;&#x3D;&#x3D; q) return root</span><br><span class="line">    const left &#x3D; lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    const right &#x3D; lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    if (left &#x3D;&#x3D;&#x3D; null) return right</span><br><span class="line">    if (right &#x3D;&#x3D;&#x3D; null) return left</span><br><span class="line">    return root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>多写写题解还是很有必要的，不要怕写的不好，敢写就已经很不错了，写的过程就是回顾的过程，更容易加深自己的理解。</p><p>加油！hxdm！！！💪💪💪</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://brookliu.xyz/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="https://brookliu.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://brookliu.xyz/tags/LeetCode/"/>
    
  </entry>
  
</feed>
