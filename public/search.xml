<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker简单上手01</title>
      <link href="/2020/10/07/Docker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B01/"/>
      <url>/2020/10/07/Docker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B01/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前也有听说过docker但是因为没有具体的业务接触所以并没有具体的去了解过，最近手头的工作也暂时没有那么急所以趁着时间来看下。</p><a id="more"></a> <h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>系统：CentOS 7.6 64位</p><h4 id="查看Linux核心版本，3-10版本及以上才可以安装docker"><a href="#查看Linux核心版本，3-10版本及以上才可以安装docker" class="headerlink" title="查看Linux核心版本，3.10版本及以上才可以安装docker"></a>查看Linux核心版本，3.10版本及以上才可以安装docker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><h4 id="更新yum包"><a href="#更新yum包" class="headerlink" title="更新yum包"></a>更新yum包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><h4 id="查看docker是否曾经安装过"><a href="#查看docker是否曾经安装过" class="headerlink" title="查看docker是否曾经安装过"></a>查看docker是否曾经安装过</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">whereis docker</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果安装过，则删除之前的版本</span><br><span class="line">yum remove docker docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure><h4 id="安装需要的软件包"><a href="#安装需要的软件包" class="headerlink" title="安装需要的软件包"></a>安装需要的软件包</h4><p>yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><h4 id="设置yum源"><a href="#设置yum源" class="headerlink" title="设置yum源"></a>设置yum源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>默认安装最新版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure><p>安装某特定版本需增加版本号（如18.06.3.ce-3.el7）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce-18.06.3.ce</span><br></pre></td></tr></table></figure><h4 id="配置用户"><a href="#配置用户" class="headerlink" title="配置用户"></a>配置用户</h4><p>将 docker 的权限移交给非 root 用户，这样使用 docker 就不需要每次都 sudo 了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>注销用户或者重启之后就会生效。然后通过 systemd 服务配置 Docker 开机启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><h4 id="验证安装是否成功"><a href="#验证安装是否成功" class="headerlink" title="验证安装是否成功"></a>验证安装是否成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><p>如果存在Client和Server则成功<br><img src="https://tothers.top1buyer.com/docker-1-2.png" alt="安装成功"></p><h4 id="下载并安装-docker-compose"><a href="#下载并安装-docker-compose" class="headerlink" title="下载并安装 docker-compose"></a>下载并安装 docker-compose</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L &quot;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.27.4&#x2F;docker-compose-$(uname -s)-$(uname -m)&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><h4 id="配置并测试docker-compose"><a href="#配置并测试docker-compose" class="headerlink" title="配置并测试docker-compose"></a>配置并测试docker-compose</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br><span class="line"></span><br><span class="line">docker-compose version</span><br></pre></td></tr></table></figure><p><img src="https://tothers.top1buyer.com/WeChatf12c620346c9dac34e1fb7e84c0bb781.png" alt="成功图"></p><h4 id="配置镜像仓库"><a href="#配置镜像仓库" class="headerlink" title="配置镜像仓库"></a>配置镜像仓库</h4><p>默认的镜像仓库 Docker Hub 在国外，国内拉取速度比较感人。建议参考<a href="https://yeasy.gitbook.io/docker_practice/install/mirror" target="_blank" rel="noopener">这篇文章</a>配置镜像加速</p><p>到这里前期的准备和环境安装工作就完成了，下面就开始上手实践吧！</p><h3 id="上手实验"><a href="#上手实验" class="headerlink" title="上手实验"></a>上手实验</h3><h4 id="实例一：Hello-World"><a href="#实例一：Hello-World" class="headerlink" title="实例一：Hello World!"></a>实例一：Hello World!</h4><p>按照惯例，我们运行胰腺癌来自Docker的Hello World：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p><img src="https://tothers.top1buyer.com/docker-1-3.png" alt="运行图"></p><p>这个过程中Docker做了以下事情：</p><ul><li>检查本地是否有指定的 hello-world:latest 镜像（latest 是镜像标签，后面会细讲），如果没有，执行第 2 步，否则直接执行第 3 步。</li><li>本地没有指定镜像（Unable to find xxx locally），从 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 下载到本地。</li><li>根据本地的 hello-world:latest 镜像创建一个新的容器并运行其中的程序。</li><li>运行完毕后，容器退出，控制权返回给用户。</li></ul><h4 id="实例二：运行一个Nginx服务器"><a href="#实例二：运行一个Nginx服务器" class="headerlink" title="实例二：运行一个Nginx服务器"></a>实例二：运行一个Nginx服务器</h4><p>运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:80 nginx</span><br></pre></td></tr></table></figure><p><img src="https://tothers.top1buyer.com/docker-1-4.png" alt="Nginx运行图"></p><p>运行之后，你会发现一直卡住，也没有任何输出，但放心你的电脑并没有死机。让我们打开浏览器访问localhost:8080(如果像我一样用的服务器可以打开服务器域名:8080来查看)</p><p>打开链接会看到Welecome to nginx！我们可以继续访问一些不存在的路由，比如localhost:8080/index，同样会提示404。这个时候我们运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>可以看到Docker容器的输出，就有内容了。<br>总结下刚才Docker做的事情：</p><ul><li>检查本地是否有指定的 nginx:latest 镜像（关于 latest 标签，后面会细讲），如果没有，执行第 2 步，否则直接执行第 3 步。</li><li>本地没有指定镜像（Unable to find xxx locally），从 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 下载到本地。</li><li>根据本地的 nginx:latest 镜像创建一个新的容器，并通过 <code>**-p（--publish**）</code>参数建立本机的 8080 端口与容器的 80 端口之间的映射，然后运行其中的程序。</li><li>Nginx 服务器程序保持运行，容器也不会退出。</li></ul><h4 id="实例三：后台运行Nginx"><a href="#实例三：后台运行Nginx" class="headerlink" title="实例三：后台运行Nginx"></a>实例三：后台运行Nginx</h4><p>看上去很酷，不过像 Nginx 服务器这样的进程我们更希望把它抛到后台一直运行。按 Ctrl + C 退出当前的容器，然后再次运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:80 --name my-nginx -d nginx</span><br></pre></td></tr></table></figure><p>注意到与之前不同的是，我们：</p><ul><li>加了一个参数 –name，用于指定容器名称为 my-nginx。</li><li>加了一个选项 -d（–detach），表示 “后台运行”。</li></ul><blockquote><p>容器的名称必须是唯一的，如果已经存在同一名称的容器（即使已经不再运行）就会创建失败。如果遇到这种情况，可以删除之前不需要的容器（后面会讲解怎么删除）。</p></blockquote><p>Docker 会输出一串长长的 64 位容器 ID，然后把终端的控制权返回给了我们。我们试着访问 localhost:8080(服务器域名:8080)，还能看到那一串熟悉的 Welcome to nginx!，说明服务器真的在后台运行起来了。</p><p>那我们怎么管理这个服务器呢？就像熟悉的 UNIX ps 命令一样，docker ps 命令可以让我们查看当前容器的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>输出结果是这样的:<br><img src="https://tothers.top1buyer.com/docker-1-5.png" alt="ps输出"></p><p>从这张表中，就可以清晰地看到了我们在后台运行的 Nginx 服务器容器的一些信息：</p><ul><li>容器 ID（Container ID）为 f104751ca7db（你机器上的可能不一样）。</li><li>所用镜像（Image）为 nginx。</li><li>运行命令 / 程序（Command）为 nginx -g ‘daemon of…，这个是 Nginx 镜像自带的运行命令，暂时不用关心。</li><li>创建时间（Created）为 an hour ago（一小时之前）。</li><li>当前状态（Status）为 Up About an hout（已运行 超过一小时）。</li><li>端口（Ports）为 0.0.0.0:8080-&gt;80/tcp，意思是访问本机的 0.0.0.0:8080 的所有请求会被转发到该容器的 TCP 80 端口。</li><li>名称（Names）为刚才指定的 my-nginx。</li></ul><p>如果我们要让容器停下来，通过 docker stop 命令指定容器名称或 ID 进行操作即可，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop my-nginx</span><br></pre></td></tr></table></figure><h4 id="实例四：交互式运行"><a href="#实例四：交互式运行" class="headerlink" title="实例四：交互式运行"></a>实例四：交互式运行</h4><p>运行以下命令，让我们进入到一个 Ubuntu 镜像中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name dreamland ubuntu</span><br></pre></td></tr></table></figure><p>可以看到我们加了 -it 选项，等于是同时指定 -i（–interactive，交互式模式）和 -t（–tty，分配一个模拟终端） 两个选项。以上命令的输出如下：<br><img src="https://tothers.top1buyer.com/docker-1-6.png" alt="ubuntu输出图"></p><p>这时我们已经在这个Ubuntu镜像中了，可以运行一些命令来看一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br><span class="line"></span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>按 Ctrl + D （或者输入 exit 命令）即可退出。你可以在 docker ps 的终端再次检查容器是否已经被关闭了。</p><h4 id="销毁容器"><a href="#销毁容器" class="headerlink" title="销毁容器"></a>销毁容器</h4><p>我们刚才创建的 Docker 容器也只是用于初步探索，后续不会再用到。由于 Docker 容器是直接存储在我们本地硬盘上的，及时清理容器也能够让我们的硬盘压力小一些。我们可以通过以下命令查看所有容器（包括已经停止的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>类似 Shell 中的 rm 命令，我们可以通过 docker rm 命令销毁容器，例如删除我们之前创建的 dreamland 容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm dreamland</span><br><span class="line"># 或者指定容器 ID，记得替换成自己机器上的</span><br><span class="line"># docker rm f104751ca7db（你机器上的可能不一样）。</span><br></pre></td></tr></table></figure><p>但如果我们想要销毁所有容器怎么办？一次次输入 docker rm 删除显然不方便，可以通过以下命令轻松删除所有容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>docker ps -aq 会输出所有容器的 ID，然后作为参数传给 docker rm 命令，就可以根据 ID 删除所有容器啦。</p><p>删除运行中的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f dreamland</span><br></pre></td></tr></table></figure><p>同样的，我们可以删除所有容器，无论处于什么状态:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -aq)</span><br></pre></td></tr></table></figure><h3 id="容器化第一个应用：开启筑梦之旅"><a href="#容器化第一个应用：开启筑梦之旅" class="headerlink" title="容器化第一个应用：开启筑梦之旅"></a>容器化第一个应用：开启筑梦之旅</h3><p>在之前的步骤中，我们体验了别人为我们提前准备好的镜像（例如 hello-world、nginx 和 ubuntu），这些镜像都可以在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 镜像仓库中找到。在这一步，我们将开始筑梦之旅：学习如何容器化（Containerization）你的应用。</p><p>运行以下命令来获取代码，然后进入项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone -b start-point https:&#x2F;&#x2F;github.com&#x2F;tuture-dev&#x2F;docker-dream.git</span><br><span class="line">cd docker-dream</span><br></pre></td></tr></table></figure><p>如果没有安装git，可以运行 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><p>来安装，也可以到<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">GIT官网</a>来查看如何安装你所对应的平台。</p><p>在这一步中，我们将容器化这个用 React 编写的前端应用，用 Nginx 来提供前端页面的访问。</p><h4 id="什么是容器化"><a href="#什么是容器化" class="headerlink" title="什么是容器化"></a>什么是容器化</h4><p>什么是容器化:</p><ul><li>编写代码：我们已经提供了写好的代码。</li><li>构建镜像。</li><li>创建和运行容器：通过容器的方式运行我们的应用。</li></ul><h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><p>构建 Docker 镜像主要包括两种方式：</p><ul><li>手动：根据现有的镜像创建并运行一个容器，进入其中进行修改，然后运行 docker commit 命令根据修改后的容器创建新的镜像。</li><li>自动：创建 Dockerfile 文件，指定构建镜像的命令，然后通过 docker build 命令直接创建镜像。</li></ul><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>我们先把前端项目 client 构建成一个静态页面。确保你的机器上已经安装 Node 和 npm（点击<a href="https://nodejs.org/en/" target="_blank" rel="noopener">这里</a>下载，或使用 <a href="https://github.com/nvm-sh/nvm">nvm</a>），然后进入到 client 目录下，安装所有依赖，并构建项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd client</span><br><span class="line">npm install</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>如果安装node和npm出现问题的可以看下我之前的这篇文章<a href="https://brookliu.xyz/2019/12/27/Linux%E4%B8%8B%E5%AE%89%E8%A3%85node/#more" target="_blank" rel="noopener">Linux安装Node</a>。</p><p>等待一阵子后，你应该可以看到 client/build 目录，存放了我们要展示的前端静态页面。</p><p>创建 Nginx 配置文件 client/config/nginx.conf，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    root &#x2F;www;</span><br><span class="line">    index index.html;</span><br><span class="line">    sendfile on;</span><br><span class="line">    sendfile_max_chunk 1M;</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">    gzip_static on;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        try_files $uri $uri&#x2F; &#x2F;index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置大致意思是：监听 80 端口，网页根目录在 /www，首页文件是 index.html，如果访问 / 则提供文件 index.html。</p><h4 id="创建-Dockerfile"><a href="#创建-Dockerfile" class="headerlink" title="创建 Dockerfile"></a>创建 Dockerfile</h4><p>然后就是这一步骤中最重要的代码：Dockerfile！创建 client/Dockerfile 文件，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx:1.13</span><br><span class="line"></span><br><span class="line"># 删除 Nginx 的默认配置</span><br><span class="line">RUN rm &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf</span><br><span class="line"></span><br><span class="line"># 添加自定义 Nginx 配置</span><br><span class="line">COPY config&#x2F;nginx.conf &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;</span><br><span class="line"></span><br><span class="line"># 将前端静态文件拷贝到容器的 &#x2F;www 目录下</span><br><span class="line">COPY build &#x2F;www</span><br></pre></td></tr></table></figure><p>可以看到我们用了 Dockerfile 中的三个指令：</p><ul><li>FROM 用于指定基础镜像，这里我们基于 nginx:1.13 镜像作为构建的起点。</li><li>RUN 命令用于在容器内运行任何命令（当然前提是命令必须存在）。</li><li>COPY 命令用于从 Dockerfile 所在的目录拷贝文件到容器指定的路径。</li></ul><p>现在可以来构建我们的镜像了，运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 如果你已经在 client 目录中</span><br><span class="line">#（注意最后面有个点，代表当前目录）</span><br><span class="line">docker build -t dream-client .</span><br><span class="line"></span><br><span class="line"># 如果你回到了项目根目录</span><br><span class="line">docker build -t dream-client client</span><br></pre></td></tr></table></figure><p>可以看到我们指定了 -t（–tag，容器标签）为 dream-client，最后指定了构建容器的上下文目录（也就是 当前目录 . 或 client）。</p><p>运行以上的命令之后，你会发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon  289.4MB</span><br></pre></td></tr></table></figure><p>接着运行了一系列的 Step（4 个），然后提示镜像构建成功。</p><p>为什么这个构建上下文（Build Context）这么大？因为我们把比 “黑洞” 还 “重” 的 node_modules 也加进去了！（忍不住想起了下面这张图）<br><img src="https://tothers.top1buyer.com/docker-1-7.png" alt="构建"></p><p>Docker 提供了类似 .gitignore 的机制，让我们可以在构建镜像时忽略特定的文件或目录。创建 client/.dockerignore 文件（注意 dockerignore 前面有一个点）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br></pre></td></tr></table></figure><p>再次运行构建命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t dream-client .</span><br></pre></td></tr></table></figure><p><img src="https://tothers.top1buyer.com/docker-1-7.png" alt="再次构建构建"><br>可以看到这次只有1.217MB，而且速度也明显快了很多.</p><h4 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h4><p>终于到了容器化的最后一步 —— 创建并运行我们的容器！通过以下命令运行刚才创建的 dream-client 镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:80 --name client -d dream-client</span><br></pre></td></tr></table></figure><p>与之前类似，我们还是设定端口映射规则为 8080:80，容器名称为 client，并且通过 -d 设置为后台运行。然后访问 localhost:8080(老样子–服务器域名:8080)：<br><img src="https://tothers.top1buyer.com/docker-1-7.png" alt="运行容器"><br>可以看到如图所示的页面，表示容器运行成功.</p><h4 id="关于镜像标签"><a href="#关于镜像标签" class="headerlink" title="关于镜像标签"></a>关于镜像标签</h4><p>在刚才的实战中，你也许已经注意到在拉取和构建镜像时，Docker 总是会为我们加上一个 :latest 标签，这个 :latest 的含义便是 “最新” 的意思。和软件的版本机制一样，镜像也可以通过标签实现 “版本化”。</p><p>实际上，我们完全可以在拉取或构建镜像时指定标签（通常被认为是一种好的做法）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:1.13</span><br><span class="line">docker build -t dream-client:1.0.0</span><br></pre></td></tr></table></figure><p>还可以给现有的镜像打上标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 把默认的 latest 镜像打上一个 newest 标签</span><br><span class="line">docker tag dream-client dream-client:newest</span><br><span class="line"># 甚至可以同时修改镜像的名称和标签</span><br><span class="line">docker tag dream-client:1.0.0 dream-client2:latest</span><br></pre></td></tr></table></figure><p>可以看到，标签未必一定是版本，还可以是任何字符串（当然最好要有意义，否则过了一阵子你也不记得这个打了这个标签的容器有什么作用了）。</p><h4 id="关于-Dockerfile"><a href="#关于-Dockerfile" class="headerlink" title="关于 Dockerfile"></a>关于 Dockerfile</h4><p>Dockerfile 实际上是默认名称，我们当然可以取一个别的名字，例如 myDockerfile，然后在构建镜像时指定 -f（–file）参数即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f myDockerfile -t dream-client .</span><br></pre></td></tr></table></figure><p>这里举两个经典的使用场景：</p><ul><li>例如在 Web 开发时，分别创建 Dockerfile.dev 用于构建开发镜像，创建 Dockerfile.prod 构建生产环境下的镜像；</li><li>在训练 AI 模型时，创建 Dockerfile.cpu 用于构建用 CPU 训练的镜像，创建 Dockerfile.gpu 构建用 GPU 训练的镜像。</li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这篇文章是我跟着图灵社区的流程走了一遍所记录的过程，<a href="https://tuture.co/2020/01/01/442cc8d/" target="_blank" rel="noopener">点击这里查看图灵社区</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack上传腾讯云</title>
      <link href="/2020/09/18/Webpack%E4%B8%8A%E4%BC%A0%E8%85%BE%E8%AE%AF%E4%BA%91/"/>
      <url>/2020/09/18/Webpack%E4%B8%8A%E4%BC%A0%E8%85%BE%E8%AE%AF%E4%BA%91/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>我们公司之前的项目一直都是打包之后上传七牛，但是最近一段时间总是出现打包文件找不到的情况，中间过程就省略了，最后决定把项目文件放到腾讯云上。</p><a id="more"></a><h3 id="腾讯云准备工作"><a href="#腾讯云准备工作" class="headerlink" title="腾讯云准备工作"></a>腾讯云准备工作</h3><ul><li>进入腾讯云控制台。</li><li>打开对象存储。</li><li>点击存储桶列表-创建存储桶。</li><li>在存储桶列表里点击刚创建的桶-点击右侧权限管理-存储桶访问权限-公有读私有写。<br>如果有CDN加速需求的话。<ul><li>点击右侧域名与传输管理-自定义CDN加速域名-添加域名(这一步看你是想要采用默认CDN加速域名还是自定义的)。</li><li>如果是自定义加速域名的话除了域名的HTTPS配置，在腾讯云上还要进行配置:<ul><li>控制台-点击内容分发网络-左侧证书管理-配置对应的证书。(我开始不知道要做这一步，文件上传到腾讯云之后一直无法访问，后来提了工单才知道，耽误了几个小时)。</li></ul></li></ul></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i tencent-cloud-webpack-plugin</span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>支持的配置项:</p><ul><li><code>secretId</code> COS SecretId</li><li><code>secretKey</code> COS SecretKey</li><li><code>bucket</code> COS 存储对象名称，格式为对象名称加应用 ID，如：<code>bucket-1250000000</code></li><li><code>region</code> COS 存储地域，参见<a href="https://cloud.tencent.com/document/product/436/6224" target="_blank" rel="noopener">官方文档</a></li><li><code>path</code> 存储路径， 默认为 <code>[hash]</code>，也可以指定 hash 长度，如: <code>[hash:8]</code></li><li><code>exclude</code> 可选，排除特定文件，正则表达式，如: <code>/index\.html$/</code></li><li><code>include</code> 可选，指定要上传的文件，正则表达式，如: <code>/app\.js$/</code></li><li><code>batch</code> 可选，批量上传文件并发数，默认 20</li></ul><p><strong><em>注: Webpack 的 <code>output.publicPath</code> 要指向 COS（或自定义的）域名地址</em></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">const</span> CosPlugin = <span class="built_in">require</span>(<span class="string">'cos-webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里用项目名加上时间戳用来在腾讯云中区分标识</span></span><br><span class="line"><span class="keyword">const</span> fileName = <span class="string">'projectName/'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 Plugin</span></span><br><span class="line"><span class="keyword">const</span> cosPlugin = <span class="keyword">new</span> CosPlugin(&#123;</span><br><span class="line">    secretId: defaultSettings.tencent.secretId,</span><br><span class="line">    secretKey: defaultSettings.tencent.secretKey,</span><br><span class="line">    bucket: defaultSettings.tencent.bucket,</span><br><span class="line">    region: defaultSettings.tencent.region,</span><br><span class="line">    path: fileName</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Webpack 的配置</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> output: &#123;</span><br><span class="line">    publicPath: IS_PROD ? defaultSettings.tencent.publicPath + fileName + <span class="string">'/dist'</span> : <span class="string">'/'</span>,</span><br><span class="line">    outputDir: <span class="string">'dist'</span>,</span><br><span class="line">    assetsDir: <span class="string">'static'</span>,</span><br><span class="line"> &#125;,</span><br><span class="line"> plugins: [</span><br><span class="line">   cosPlugin</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"> ]</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><a href="https://github.com/liubrook/tencent-cloud-webpack">示例项目</a></p>]]></content>
      
      
      <categories>
          
          <category> Webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器输入URL后发生了什么？</title>
      <link href="/2020/01/15/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2020/01/15/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>浏览器输入URL之后大体上可以分为六步:<br>合成URL-DNS域名解析-建立TCP连接-发送请求，返回结果-关闭TCP连接-浏览器渲染</p><a id="more"></a>  <h3 id="合成URL"><a href="#合成URL" class="headerlink" title="合成URL"></a>合成URL</h3><p>用户输入URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL。</p><h3 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h3><p>在网络世界，记住网站的名称很容易，但是记住网站的IP地址却很难。这时候我们就需要一个地址簿，就是DNS服务器。DNS服务器是高可用、高并发和分布式的，它是树状结构，如图：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/1.png" alt="DNS图"></p><ul><li>根DNS服务器：返回顶级域DNS服务器的IP地址.</li><li>顶级域DNS服务器：返回权威DNS服务器的IP地址.</li><li>权威DNS服务器：返回相应主机的IP地址.</li></ul><p>DNS的域名查找，在客户端和浏览器、本地DNS之间的查询方式是递归查询；在本地DNS服务器与根域及其子域之间的查询方式迭代查询；<br>递归过程：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/2.png" alt="DNS查询图"></p><p>在客户端输入URL之后，会有一个递归查找的过程，从浏览器缓存中查找-&gt;本地的hosts文件查找-&gt;在本地DNS解析器缓存查找-&gt;本地DNS服务器查找，这个过程中任何一步找到了都会结束查找流程。</p><p>如果本地DNS服务器无法查询到，则根据本地DNS服务器设置的转发器进行查询。若未用转发模式，则迭代查找过程如下图：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/2.png" alt="迭代查找图"></p><p>结合起来的过程，可以用一个图表示：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/4.png" alt="DNS图"></p><p>在查找过程中，有以下优化点：</p><ul><li><p>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种：浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存。</p></li><li><p>在域名和IP的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均很，也可以根据地址和运营商做全局的负载均衡。</p><h3 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h3><p>首先，判断是不是HTTPS，如果是的话则HTTPS其实是HTTP+SSL/TLS两部分组成，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户短的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。</p></li></ul><p>进行三次握手，建立TCP连接：</p><ul><li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后客户端今日SYN_SEND状态，等待服务器的确认。</li><li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段)中，一并发送给客户端，此时服务器进入SYN_RECV状态。</li><li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</li></ul><p>SSL握手过程：</p><ul><li>第一阶段：建立安全能力，包括协议版本、会话Id、密码构件、压缩方法、初始随机数。</li><li>第二阶段：服务器发送证书、密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号。</li><li>第三阶段：如果有证书请求客户端发送此证书，之后客户端发送密钥交换数据，也可以发送证书验证消息。</li><li>第四阶段：变更密码构件和结束握手协议。</li></ul><p>完成了之后，客户端和服务器端就可以开始传送数据。</p><p><font color="blue">备注：</font></p><p>ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0。TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1。</p><p>SYN(SYNchronization)：在连接建立时用来同步序号。当SYN=1而ACK=0时，表示这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1.因此，SYN置为1就表示这是一个连接请求或连接接受报文。</p><p>FIN(finis)：用来释放一个连接。当FIN=1时，表示此报文段的发送方的数据已经发送完毕，并要求释放连接。</p><h3 id="发送HTTP请求，服务器处理请求，返回响应结果"><a href="#发送HTTP请求，服务器处理请求，返回响应结果" class="headerlink" title="发送HTTP请求，服务器处理请求，返回响应结果"></a>发送HTTP请求，服务器处理请求，返回响应结果</h3><p>TCP连接建立后，浏览器就可以利用HTTP/HTTPS协议向服务器发送请求了。服务器接收到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200。</p><h3 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h3><ul><li>第一次分手：主机1(可以是客户端，也可以是服务器端)，设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了。</li><li>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1返回一个ACK报文段，ACKnowledgment Number为Sequence Number + 1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我同意你的关闭请求。</li><li>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2今日LAST_ACK状态。</li><li>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1今日TIME_WAIT状态，主机2收到主机1的ACK报文段以后就关闭连接。此时，主机1等到2MSL后仍然没有收到回复，则证明主机2已正常关闭，主机1也可以关闭连接了。</li></ul><h3 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h3><p>按照渲染的时间顺序，流水线可分为如下几个子阶段：构建DOM树、样式计算、布局阶段、分层、栅格化、限时。如图：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/5.png" alt="渲染图"></p><ul><li>渲染进程将HTML内容转换为能够读懂DOM树结构。</li><li>渲染引擎将CSS样式表转换为浏览器可以理解的styleSheets，计算出DOM节点的样式。</li><li>创建布局树，并计算元素的布局信息。</li><li>对布局树进行分层，并生成分层树。</li><li>为每个图层生成绘制列表，并将其提交到合成线程，合成线程将图层分图块，并栅格化将图块转换成位图。</li><li>合成线程发送绘制图块命令给浏览器进程，浏览器进程根据指令生成页面，并显示到显示器上。</li></ul><h4 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h4><p>浏览器从网络或硬盘中获得HTML字节数据后会经过一个流程将字节解析为DOM树，先讲HTML的原始字节数据转换为文件指定编码的自负，然后浏览器会根据HTML规范来讲字符串转换成各种令牌标签，如html、body等。最终解析成一个树状的对象模型，就是dom树。<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/6.png" alt="DOM"></p><p>具体步骤：</p><ul><li>转码(Bytes-&gt;Characters)–读取接收到的HTML二进制数据，按照指定编码格式将字节转换为HTML字符串。</li><li>Tokens转化(Characters-&gt;Tokens)–解析HTML，将HTML字符串转换为结构清晰的Tokens，每个Token都有特殊的含义同时有自己的一套规则。</li><li>构建Node(Tokens-&gt;Nodes)–每个Node都添加特定的属性(或属性访问器)，通过指针能够确定Node的父子兄弟关系和所属treeScope。</li><li>构建DOM树(Nodes-&gt;DOM Tree)–最重要的工作是建立起每个节点的父子兄弟关系。</li></ul><h4 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h4><p>渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。</p><p>CSS样式来源主要有3种，分别是通过link引用的外部CSS文件、style标签内的CSS、元素的style属性内嵌的CSS，其样式计算过程主要为：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/7.png" alt="CSS"></p><p>可以看到上面的CSS文本中有很多属性值，如2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化，处理完成后再处理样式的继承和层叠， 有些文章将这个过程成为CSSOM的构建过程。</p><h4 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h4><p>布局过程，即排除<code>&lt;script&gt;、&lt;meta&gt;</code>等功能化、非视觉节点，排除display:none的节点，计算元素的位置信息，确定元素的位置，构建一颗只包含可见元素布局树，如图：<br><img src="https://brookliu.xyz/2020/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/8.png" alt="布局图"></p><p>这个过程需要注意的是回流和重绘。</p><h4 id="生成分层树"><a href="#生成分层树" class="headerlink" title="生成分层树"></a>生成分层树</h4><p>页面中有很多复杂的效果，如一些复杂的3D变化、页面滚动，或者使用z-indexing做z轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成占用的图层，并生成一颗对应的图层树(LayerTree)。</p><p>如果你熟悉PS，相信你会很容易理解图层的概念，正是这些图层添加在一起构成了最终的页面图像，在浏览器中，你可以打开Chrome的‘开发者工具’，选择‘layers’标签。渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。</p><p>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。</p><h4 id="栅格化"><a href="#栅格化" class="headerlink" title="栅格化"></a>栅格化</h4><p>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。</p><p>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口(viewport)。在有些情况下，有的图层可以很大比如有的页面你使用滚动条要滚动到好久才能到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p><h4 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h4><p>最后，合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上，渲染过程完成。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript数组去重</title>
      <link href="/2020/01/05/Javascript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
      <url>/2020/01/05/Javascript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<p>常见的Javascript数组去重的12种方法</p><a id="more"></a>  <h4 id="利用ES6-Set去重-ES6中最常用"><a href="#利用ES6-Set去重-ES6中最常用" class="headerlink" title="利用ES6 Set去重(ES6中最常用)"></a>利用ES6 Set去重(ES6中最常用)</h4><p>不考虑兼容性，这种去重的方法代码最少。这种方法无法去掉“{}”空对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    return Array.from(new Set(arr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用for嵌套for，然后splice去重-ES5中最常用"><a href="#利用for嵌套for，然后splice去重-ES5中最常用" class="headerlink" title="利用for嵌套for，然后splice去重(ES5中最常用)"></a>利用for嵌套for，然后splice去重(ES5中最常用)</h4><p>双重循环，外层循环元素，内层循环时比较值。值相同时，则删除这个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        for (var j &#x3D; i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">            if (arr[i] &#x3D;&#x3D; arr[j]) &#123;</span><br><span class="line">                &#x2F;&#x2F; 第一个等同于第二个，splice方法删除第二个</span><br><span class="line">                arr.splice(j, 1);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用indexOf去重"><a href="#利用indexOf去重" class="headerlink" title="利用indexOf去重"></a>利用indexOf去重</h4><p>新建一个空的结果数组，for循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进结果数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#39;type error!&#39;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var array &#x3D; [];</span><br><span class="line">    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (array.indexOf(arr[i]) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">            array.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用sort"><a href="#利用sort" class="headerlink" title="利用sort()"></a>利用sort()</h4><p>利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&quot;type error!&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    arr &#x3D; arr.sort()</span><br><span class="line">    var array &#x3D; [arr[0]];</span><br><span class="line">    for (var i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i] !&#x3D;&#x3D; arr[i - 1]) &#123;</span><br><span class="line">            array.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用对象的属性不能相同的特点进行去重-这种数组去重的方法有问题，不建议用，有待改进"><a href="#利用对象的属性不能相同的特点进行去重-这种数组去重的方法有问题，不建议用，有待改进" class="headerlink" title="利用对象的属性不能相同的特点进行去重(这种数组去重的方法有问题，不建议用，有待改进)"></a>利用对象的属性不能相同的特点进行去重(这种数组去重的方法有问题，不建议用，有待改进)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#39;type error!&#39;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var array &#x3D; [];</span><br><span class="line">    var obj &#x3D; &#123;&#125;;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (!obj[arr[i]]) &#123;</span><br><span class="line">            array.push(arr[i])</span><br><span class="line">            obj[arr[i]] &#x3D; 1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            obj[arr[i]]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用includes"><a href="#利用includes" class="headerlink" title="利用includes"></a>利用includes</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#39;type error!&#39;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var array &#x3D; [];</span><br><span class="line">    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (!array.includes(arr[i])) &#123;</span><br><span class="line">            array.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用hasOwnProperty判断是否存在对象属性"><a href="#利用hasOwnProperty判断是否存在对象属性" class="headerlink" title="利用hasOwnProperty判断是否存在对象属性"></a>利用hasOwnProperty判断是否存在对象属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    var obj &#x3D; &#123;&#125;;</span><br><span class="line">    return arr.filter(function(item, index, arr) &#123;</span><br><span class="line">        return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] &#x3D; true)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用filter"><a href="#利用filter" class="headerlink" title="利用filter"></a>利用filter</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    return arr.filter(function(item, index, arr) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当前元素，在原始数组中的第一个索引&#x3D;&#x3D;当前索引值，否则返回当前元素</span><br><span class="line">        return arr.indexOf(item, 0) &#x3D;&#x3D;&#x3D; index;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用递归去重"><a href="#利用递归去重" class="headerlink" title="利用递归去重"></a>利用递归去重</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    var array &#x3D; arr;</span><br><span class="line">    var len &#x3D; array.length;</span><br><span class="line">    arr.sort((a, b) &#x3D;&gt; a - b)</span><br><span class="line">    function loop(index) &#123;</span><br><span class="line">        if (index &gt;&#x3D; 1) &#123;</span><br><span class="line">            if (array[index] &#x3D;&#x3D;&#x3D; array[index - 1]) &#123;</span><br><span class="line">                array.splice(index, 1)</span><br><span class="line">            &#125;</span><br><span class="line">            loop(index - 1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    loop(len - 1);</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用Map数据结构去重"><a href="#利用Map数据结构去重" class="headerlink" title="利用Map数据结构去重"></a>利用Map数据结构去重</h4><p>创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function arraynonRepeatfy(arr) &#123;</span><br><span class="line">    let map &#x3D; new Map();</span><br><span class="line">    let array &#x3D; new Array();</span><br><span class="line">    for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (map.has(arr[i])) &#123;</span><br><span class="line">            map.set(arr[i], true)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.set(arr[i], false)</span><br><span class="line">            array.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用reduce-includes"><a href="#利用reduce-includes" class="headerlink" title="利用reduce+includes"></a>利用reduce+includes</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    return arr.reduce((prev, cur) &#x3D;&gt; prev.includes(cur) ? prev : [...prev, cur], [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="…new-Set-arr"><a href="#…new-Set-arr" class="headerlink" title="[…new Set(arr)]"></a>[…new Set(arr)]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...new Set(arr)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常见面试题-1</title>
      <link href="/2020/01/02/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-1/"/>
      <url>/2020/01/02/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-1/</url>
      
        <content type="html"><![CDATA[<h3 id="1，http的状态码中，499是什么？如何出现499？如何排查解决？"><a href="#1，http的状态码中，499是什么？如何出现499？如何排查解决？" class="headerlink" title="1，http的状态码中，499是什么？如何出现499？如何排查解决？"></a>1，http的状态码中，499是什么？如何出现499？如何排查解决？</h3><p>499对应的是“client has closed connection”，客户端请求等待连接已经关闭，这很有可能是因为服务器端处理的时间过长，客户端等的‘不耐烦了’。还可能是因为两次提交post请求过快就会出现499。<br>解决方法:</p><ul><li>前端将timeout最大等待时间设置大一些。</li><li>nginx上配置proxt_ignore_client_abort on;<a id="more"></a>  <h3 id="2，如何遍历一个dom树"><a href="#2，如何遍历一个dom树" class="headerlink" title="2，如何遍历一个dom树"></a>2，如何遍历一个dom树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function traversal(node) &#123;</span><br><span class="line">    &#x2F;&#x2F; 对node的处理</span><br><span class="line">    if (node &amp;&amp; node.nodeType &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">        console.log(node.tagName);</span><br><span class="line">    &#125;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; node.childNodes.length; i++) &#123;</span><br><span class="line">        const item &#x3D; node.childNodes[i];</span><br><span class="line">        if (item.nodeType &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; 递归先序遍历子节点</span><br><span class="line">            traversal(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3，new操作符都做了什么？"><a href="#3，new操作符都做了什么？" class="headerlink" title="3，new操作符都做了什么？"></a>3，new操作符都做了什么？</h3><p>四大步骤：</p><ul><li>创建一个空对象，并且this变量引用该对象。</li><li>继承了函数的原型。</li><li>属性和方法被加入到this引用的对象中，并且执行了该函数func。</li><li>新创建的对象由this所引用，并且最后隐式的返回this。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function new(func) &#123;</span><br><span class="line">    let target &#x3D; &#123;&#125;;</span><br><span class="line">    target.__proto__ &#x3D; func.prototype;</span><br><span class="line">    let res - func.call(target);</span><br><span class="line">    if (typeof(res) &#x3D;&#x3D; &#39;object&#39; &#125;&#125; typeof(res) &#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4，简单实现call"><a href="#4，简单实现call" class="headerlink" title="4，简单实现call"></a>4，简单实现call</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; es3</span><br><span class="line">Function.prototype.call2 &#x3D; function (context) &#123;</span><br><span class="line">    var context &#x3D; context || window; &#x2F;&#x2F; 因为传进来的context有可能是null</span><br><span class="line">    context.fn &#x3D; this;</span><br><span class="line">    var args &#x3D; [];</span><br><span class="line">    for (var i &#x3D; 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">        args.push(&quot;arguments[&quot; + i + &quot;]&quot;); &#x2F;&#x2F;不这么做的话 字符串的引号会被自动去掉 变成了变量 导致报错</span><br><span class="line">    &#125;</span><br><span class="line">    args &#x3D; args.join(&quot;,&quot;);</span><br><span class="line">    var result &#x3D; eval(&quot;context.fn(&quot; + args + &quot;)&quot;); &#x2F;&#x2F;相当于执行了context.fn(arguments[1], arguments[2]);</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result; &#x2F;&#x2F; 因为有可能this函数会有返回值return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; es6</span><br><span class="line">Function.prototype.call2 &#x3D; function (context) &#123;</span><br><span class="line">    context &#x3D; context ? Object(context) : window;</span><br><span class="line">    context.fn &#x3D; this;</span><br><span class="line">    let args &#x3D; [...arguments].slice(1)</span><br><span class="line">    let result &#x3D; context.fn(...args);</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5，简单实现apply"><a href="#5，简单实现apply" class="headerlink" title="5，简单实现apply"></a>5，简单实现apply</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; es3</span><br><span class="line">Function.prototype.apply2 &#x3D; function(context, arr) &#123;</span><br><span class="line">    context &#x3D; context ? Object(context) : window;</span><br><span class="line">    context.fn &#x3D; this;</span><br><span class="line">    var result;</span><br><span class="line">    &#x2F;&#x2F; 判断是否存在第二个参数</span><br><span class="line">    if (!arr) &#123;</span><br><span class="line">        result &#x3D; context.fn();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var args &#x3D; [];</span><br><span class="line">        for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            args.push(&quot;arr[&quot; + i + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        result &#x3D; eval(&quot;context.fn(&quot; + args + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; es6</span><br><span class="line">Function.prototype.apply2 &#x3D; function(context, arr) &#123;</span><br><span class="line">    context &#x3D; context ? Object(context) : window;</span><br><span class="line">    context.fn &#x3D; this;</span><br><span class="line">    let result;</span><br><span class="line">    if (!arr) &#123;</span><br><span class="line">        result &#x3D; context.fn();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        result &#x3D; context.fn(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6，简单实现bind"><a href="#6，简单实现bind" class="headerlink" title="6，简单实现bind"></a>6，简单实现bind</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line">    var _this &#x3D; this;</span><br><span class="line">    var argsParent &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var args &#x3D; argsParent.contact(Array.prototype.slice.call(arguments));</span><br><span class="line">        _this.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7，https对称加密和非对称加密"><a href="#7，https对称加密和非对称加密" class="headerlink" title="7，https对称加密和非对称加密"></a>7，https对称加密和非对称加密</h3><p>对称加密：发送方和接收方需要持有同一把密钥，发送消息和接收消息均使用该密钥。相对于非加密对称，加密对称具有更高的加解密速度，但双方都需要实现知道密钥，密钥在传输过程中可能会被窃取，因此安全性没有非对称加密高。</p><p>非对称加密；接收方在发送消息前需要事先生成公钥和私钥，然后将公钥发送给发送方，发送方收到公钥后，将待发送数据用公钥加密，发送给接收方。接收方收到数据后，用私钥解密。在这个过程中，公钥负责加密，私钥负责解密，数据在传输过程中即使被截获，攻击者由于没有私钥也无法破解数据。非对称加密算法的加解密速度低于对称加密算法，但是安全性更高。</p><h3 id="8，简单实现promise"><a href="#8，简单实现promise" class="headerlink" title="8，简单实现promise"></a>8，简单实现promise</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 简易版本的promise</span><br><span class="line">&#x2F;&#x2F; 第一步：列出三大块 this.then resolve&#x2F;reject fn(resolve, reject)</span><br><span class="line">&#x2F;&#x2F; 第二步：this.then负责注册所有的函数 resolve&#x2F;reject负责执行所有函数</span><br><span class="line">&#x2F;&#x2F; 第三步：在resolve&#x2F;reject里面要加上setTimeout，防止还没尽兴then注册，就直接执行resolve了</span><br><span class="line">&#x2F;&#x2F; 第四步：resolve&#x2F;reject里面要返回this，这样就可以链式调用了</span><br><span class="line">&#x2F;&#x2F; 第五步：三个状态的管理 pending fulfilled rejected</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  *****promise的链式调用，在then里面return一个promise这样才能then里面加上异步函数</span><br><span class="line">&#x2F;&#x2F; 加上了catch</span><br><span class="line">function PromiseM(fn) &#123;</span><br><span class="line">    var value &#x3D; null;</span><br><span class="line">    var callbacks &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F; 加入状态，为了解决在Promise异步操作成功之后调用的then注册的回调不会执行的问题</span><br><span class="line">    var state &#x3D; &#39;pending&#39;;</span><br><span class="line">    var _this &#x3D; this;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 注册所有的回调函数</span><br><span class="line">    this.then &#x3D; function (fulfilled, rejected) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果想链式promise，那就要在这边return一个new Promise</span><br><span class="line">        return new PromiseM(function (resolve, reject) &#123;</span><br><span class="line">            &#x2F;&#x2F; 异常处理</span><br><span class="line">            try &#123;</span><br><span class="line">                if (state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                    callbacks.push(fulfilled);</span><br><span class="line">                    &#x2F;&#x2F; 实现链式调用</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;) &#123;</span><br><span class="line">                    var data &#x3D; fulfilled(value);</span><br><span class="line">                    &#x2F;&#x2F; 为了能够让两个promise连接起来</span><br><span class="line">                    resolve(data);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (state &#x3D;&#x3D;&#x3D; &#39;rejected&#39;) &#123;</span><br><span class="line">                    var data &#x3D; rejected(data);</span><br><span class="line">                    &#x2F;&#x2F; 为了能让两个promise连接起来</span><br><span class="line">                    resolve(data);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">                _this.catch(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 执行所有的回调函数</span><br><span class="line">    function resolve(valueNew) &#123;</span><br><span class="line">        value &#x3D; valueNew;</span><br><span class="line">        state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">        execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 执行所有的回调函数</span><br><span class="line">    function reject(valueNew) &#123;</span><br><span class="line">        value &#x3D; valueNew;</span><br><span class="line">        state &#x3D; &#39;rejected&#39;;</span><br><span class="line">        execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function execute() &#123;</span><br><span class="line">        &#x2F;&#x2F; 加入延时机制，防止promise里面有同步函数导致resolve先执行，then还没注册上函数</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            callbacks.forEach(function(cb) &#123;</span><br><span class="line">                value &#x3D; cb(value);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.catch &#x3D; function (e) &#123;</span><br><span class="line">        console.log(JSON.stringify(e));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 经典 实现异步回调</span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS计算精度丢失问题</title>
      <link href="/2019/12/28/JS%E8%AE%A1%E7%AE%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/"/>
      <url>/2019/12/28/JS%E8%AE%A1%E7%AE%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>JS运算中经常会遇到精度丢失的问题，对于这种情况可以采用以下方法来编写公共方法。</p><a id="more"></a>  <h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jQuery.add &#x3D; function(arg1, arg2) &#123;</span><br><span class="line"></span><br><span class="line">    var r1, r2, m;</span><br><span class="line">    </span><br><span class="line">    try &#123; r1 &#x3D; arg1.toString().split(&quot;.&quot;)[1].length &#125; catch (e) &#123; r1 &#x3D; 0 &#125;</span><br><span class="line">   </span><br><span class="line">    try &#123; r2 &#x3D; arg2.toString().split(&quot;.&quot;)[1].length &#125; catch (e) &#123; r2 &#x3D; 0 &#125;</span><br><span class="line">    </span><br><span class="line">    m &#x3D; Math.pow(10, Math.max(r1, r2))</span><br><span class="line">    </span><br><span class="line">    return (arg1 * m + arg2 * m) &#x2F; m</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">jQuery.cut &#x3D; function(arg1, arg2) &#123;</span><br><span class="line"> </span><br><span class="line">   var r1, r2, m, n;</span><br><span class="line"> </span><br><span class="line">   try &#123; r1 &#x3D; arg1.toString().split(&quot;.&quot;)[1].length &#125; catch (e) &#123; r1 &#x3D; 0 &#125;</span><br><span class="line"></span><br><span class="line">   try &#123; r2 &#x3D; arg2.toString().split(&quot;.&quot;)[1].length &#125; catch (e) &#123; r2 &#x3D; 0 &#125;</span><br><span class="line"></span><br><span class="line">   m &#x3D; Math.pow(10, Math.max(r1, r2));</span><br><span class="line">    &#x2F;&#x2F;last modify by deeka</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;动态控制精度长度</span><br><span class="line"></span><br><span class="line">    n &#x3D; (r1 &gt;&#x3D; r2) ? r1 : r2;</span><br><span class="line"></span><br><span class="line">    return ((arg1 * m - arg2 * m) &#x2F; m).toFixed(n);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.mul &#x3D; function(arg1, arg2) &#123;</span><br><span class="line"></span><br><span class="line">    var m &#x3D; 0, s1 &#x3D; arg1.toString(), s2 &#x3D; arg2.toString();</span><br><span class="line"></span><br><span class="line">    try &#123; m +&#x3D; s1.split(&quot;.&quot;)[1].length &#125; catch (e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    try &#123; m +&#x3D; s2.split(&quot;.&quot;)[1].length &#125; catch (e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    return Number(s1.replace(&quot;.&quot;, &quot;&quot;)) * Number(s2.replace(&quot;.&quot;, &quot;&quot;)) &#x2F; Math.pow(10, m)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">jQuery.div &#x3D; function(arg1, arg2) &#123;</span><br><span class="line"></span><br><span class="line">    var t1 &#x3D; 0, t2 &#x3D; 0, r1, r2;</span><br><span class="line"></span><br><span class="line">    try &#123; t1 &#x3D; arg1.toString().split(&quot;.&quot;)[1].length &#125; catch (e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    try &#123; t2 &#x3D; arg2.toString().split(&quot;.&quot;)[1].length &#125; catch (e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    with (Math) &#123;</span><br><span class="line"></span><br><span class="line">        r1 &#x3D; Number(arg1.toString().replace(&quot;.&quot;, &quot;&quot;))</span><br><span class="line"></span><br><span class="line">        r2 &#x3D; Number(arg2.toString().replace(&quot;.&quot;, &quot;&quot;))</span><br><span class="line"></span><br><span class="line">        return (r1 &#x2F; r2) * pow(10, t2 - t1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下安装node</title>
      <link href="/2019/12/27/Linux%E4%B8%8B%E5%AE%89%E8%A3%85node/"/>
      <url>/2019/12/27/Linux%E4%B8%8B%E5%AE%89%E8%A3%85node/</url>
      
        <content type="html"><![CDATA[<p>今天在学习docker方面的知识，需要在服务器上安装node和npm，安装过程中碰到了一些问题，做一下记录。</p><a id="more"></a>  <h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>服务器系统：CentOS 7.6 64位</p><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><ul><li>打开node下载地址<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">Node下载</a>。</li><li>选择长期支持版-Linux二进制文件(x64)-(64-bit).(这个根据自己的系统来选择)。</li><li>右键复制链接地址。</li><li>打开服务器- cd /usr/local (这个看你习惯把这些工具安装到哪里)。</li><li>wget <a href="https://nodejs.org/dist/v12.18.4/node-v12.18.4-linux-x64.tar.xz(这里是你刚才复制的链接地址)。" target="_blank" rel="noopener">https://nodejs.org/dist/v12.18.4/node-v12.18.4-linux-x64.tar.xz(这里是你刚才复制的链接地址)。</a></li><li>下载完成后 tar xf node-v12.18.4-linux-x64.tar.xz(解压)</li><li>解压后把Node的路径链接到环境里</li><li>export NODE_HOME=/usr/local/node-v12.18.4-linux-x64/bin(注意这里是你安装的版本，不要搞错了)</li><li>export PATH=$NODE_HOME:$PATH</li></ul><p>这个时候你用node -v或者npm -v就可以查看了。</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序常见问题(1)</title>
      <link href="/2019/12/24/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-1/"/>
      <url>/2019/12/24/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-1/</url>
      
        <content type="html"><![CDATA[<p>以下是在做小程序开发过程中碰到的一些常见问题.</p><a id="more"></a>  <p>1、如果你在微信开发者工具中发现并没有换行，不要惊讶，利用真机预览一下，就可以看到效果了。<br>接下来看看代码，其实很简单，代码中使用了大家熟知的\r\n</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wx.showModal(&#123;</span><br><span class="line">    title: &#39;提示&#39;,</span><br><span class="line">    content: &#39;第一行内容\r\n第二行内容\r\n第三行内容\r\n第四行内容&#39;,</span><br><span class="line">    success: function (res) &#123; </span><br><span class="line">    if (res.confirm) &#123;</span><br><span class="line">            console.log(&#39;用户点击确定&#39;)</span><br><span class="line">        &#125; else if (res.cancel) &#123;</span><br><span class="line">            console.log(&#39;用户点击取消&#39;)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2、使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button::after&#123; border: none; &#125;</span><br></pre></td></tr></table></figure><p>来去除边框</p><p>3、text自动换行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word-break: keep-all;</span><br><span class="line">word-wrap: break-word</span><br></pre></td></tr></table></figure><p>4、弹出框禁止底层页面滚动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catchtouchmove&#x3D;&quot;true&quot;</span><br></pre></td></tr></table></figure><p>开发者工具上测试无效，真机有效</p><p>5、微信小程序隐藏scroll-view滚动条的简单实现就是在wxss里加入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">::-webkit-scrollbar&#123;</span><br><span class="line">  width: 0;</span><br><span class="line">  height: 0;</span><br><span class="line">  color: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-15-DOM-4</title>
      <link href="/2019/12/20/Javascript-15-DOM-4/"/>
      <url>/2019/12/20/Javascript-15-DOM-4/</url>
      
        <content type="html"><![CDATA[<h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>为了让开发人员更方便地控制页面，“DOM2级遍历和范围”模块定义了“范围”(range)接口。通过范围可以选择文档中的一个区域，而不必考虑修改节点的界限。</p><a id="more"></a>  <h4 id="DOM中的范围"><a href="#DOM中的范围" class="headerlink" title="DOM中的范围"></a>DOM中的范围</h4><p>DOM2级在Document类型中定义了createRange()方法。在兼容DOM的浏览器中，这个方法属于document对象。使用hasFeature()或者直接检测该方法，都可以确定浏览器是否支持范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var supportsRange &#x3D; document.implementation.hasFeature(&quot;Range&quot;, &quot;2.0&quot;);</span><br><span class="line">var alsoSupportsRange &#x3D; (typeof document.createRange &#x3D;&#x3D; &quot;function&quot;);</span><br><span class="line">&#x2F;&#x2F; 如果浏览器支持，那么就可以使用createRange()来创建DOM范围。</span><br><span class="line">var range &#x3D; document.createRange();</span><br></pre></td></tr></table></figure><p>新创建的范围也直接与创建它的文档关联在一起，不能用于其他文档。创建了范围之后，接下来就可以使用它在后台选择文档中的特定部分。而创建范围并设置了其位置之后，还可以针对范围的内容执行很多种操作，从而实现对底层DOM树的更精细的控制。</p><p>每个范围由一个Range类型的实例表示，这个实例拥有很多属性和方法。</p><ul><li>startContainer:包含范围起点的节点(即选区中第一个节点的父节点)。</li><li>startOffset：范围在startContainer中起点的偏移量。如果startContainer是文本姐弟哪、注释节点或CDATA节点，那么startOffset就是范围起点之前跳过的字符数量。否则。startOffset就是范围中第一子节点的索引。</li><li>endContainer：包含范围终点的节点(即选区中最后一个节点的父节点)。</li><li>endOffset：范围在endContainer中终点的偏移量(与startOffset遵循相同的取值规则)。</li><li>commonAncestorContainer: startContainer和endContainer共同的祖先节点在文档树中位置最深的那个。<br>在把防伪放到文档中特定的位置时，这些属性都会被赋值。    </li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-15-DOM-3</title>
      <link href="/2019/12/15/Javascript-15-DOM-3/"/>
      <url>/2019/12/15/Javascript-15-DOM-3/</url>
      
        <content type="html"><![CDATA[<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>“DOM2级遍历和范围”模块定义了两个用于辅助完成顺序遍历DOM结构的类型：NodeIterator和TreeWalker。这两个类型能够基于给定的起点对DOM结构执行深度优先(depth-first)的遍历操作。在于DOM兼容的浏览器中都可以访问到这些类型的对象。IE不支持DOM遍历。使用下列代码可以检测浏览器对DOM2级遍历能力的支持情况。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var supportsTraversals &#x3D; document.implementation.hasFeature(&quot;Traversal&quot;, &quot;2.0&quot;);</span><br><span class="line">var supportsNodeIterator &#x3D; (typeof document.createNodeIterator &#x3D;&#x3D; &quot;function&quot;);</span><br><span class="line">var supportsTreeWalker &#x3D; (typeof document.createTreeWalker &#x3D;&#x3D; &quot;function&quot;);</span><br></pre></td></tr></table></figure><p>如前所述，DOM遍历是深度优先的DOM结构遍历，也就是说，移动的方向至少有两个(取决于使用的遍历类型)。遍历以给定节点为根，不可能向上超出DOM树的根节点。</p><h4 id="NodeIterator"><a href="#NodeIterator" class="headerlink" title="NodeIterator"></a>NodeIterator</h4><p>可以使用document.createNodeIterator()方法创建它的新实例。接受以下4个参数。</p><ul><li>root：想要作为搜索起点的树中的节点。</li><li>whatToShow：表示想要访问哪些节点的数字代码。</li><li>filter：是一个NodeFilter对象，或者一个表示应该接受还是拒绝某种特定节点的函数。</li><li>entityReferenceExpansion：布尔值，表示是否要拓展实体引用。这个参数在HTML中没有用，因为其中的实体引用不能拓展。</li></ul><p>whatToShow参数是一个位掩码，通过应用一或多个过滤器(filter)来确定要访问哪些节点。这个参数的值以常量的形式在NodeFilter类型中定义，如下所示：</p><ul><li><p>NodeFilter.SHOW_ALL：显示所有类型的节点。</p></li><li><p>NodeFilter.SHOW_ELEMENT：显示元素节点。</p></li><li><p>NodeFilter.SHOW_ATTRIBUTE：显示特性节点。由于DOM结构原因，实际上不能使用这个值。</p></li><li><p>NodeFilter.SHOW_TEXT：显示文本节点。</p></li><li><p>NodeFilter.SHOW_CDATA_SECTION：显示CDATA节点。对HTML页面没用。</p></li><li><p>NodeFilter.SHOW_ENTITY_REFERENCE：显示实体引用节点。对HTML页面没用。</p></li><li><p>NodeFilter.SHOW_ENTITYE：显示实体节点。对HTML页面没用。</p></li><li><p>NodeFilter.SHOW_PROCESSING_INSTRUCTION：显示处理指令节点。对HTML页面没用。</p></li><li><p>NodeFilter.SHOW_COMMENT：显示注释节点。</p></li><li><p>NodeFilter.SHOW_DOCUEMNT：显示文档节点。</p></li><li><p>NodeFilter.SHOW_DOCUMENT_TYPE：显示文档类型节点。</p></li><li><p>NodeFilter.SHOW_DOCUMENT_FRAGMENT：显示文档片段节点。对HTML页面没用。</p></li><li><p>NodeFilter.SHOW_NOTATION：显示符号节点。对HTML页面没用。</p><p>除了NodeFilter.SHOW_ALL之外，可以使用按位或操作符来组合多个选项。</p><p>可以通过createNodeIterator()方法的filter参数来指定自定义的NodeFilter对象，或者指定一个功能类似节点过滤器(node filter)的函数，每个NOdeFilter对象只有一个方法，即acceptNode()；如果应该访问给定的节点，该方法返回NodeFilter.FILTER_ACCEPT，如果不应该访问给定的节点，该方法返回NodeFilter.FILTER_SKIP。由于NodeFilter是一个抽象的类型，因此不能直接创建它的实例。在必要时，只要创建一个包含acceptNode()方法的对象，然后将这个对象传入createNodeIterator()中即可。</p><p>NodeIterator类型的两个主要方法是nextNode()和previousNode()。顾名思义，在深度优先的DOM子树遍历中，nextNode()方法主要用于向前前进一步，而previousNode()用于向后后退一步。在刚刚创建的NodeIterator对象中，有一个内部指针指向根节点，因此第一次调用nextNode()会返回根节点。当遍历到DOM子树的最后一个节点时，nextNode()返回null。previousNode()方法的工作机制类似。当遍历到DOM子树的最后一个节点，且previousNode()返回根节点之后，再次调用它就会返回null。</p><p>由于nextNode()和previousNode()方法都基于NodeIterator在DOM结构中的内部指针工作，所以DOM结构的变化会反映在遍历的结果中。</p><h4 id="TreeWalker"><a href="#TreeWalker" class="headerlink" title="TreeWalker"></a>TreeWalker</h4><p>TreeWalker是NodeIterator的一个更高级的版本。除了包括nextNode()和previousNode()在内的相同的功能之外，这个类型还提供了下列用于在不同方向上遍历DOM结构的方法。</p><ul><li>parentNode()：遍历到当前节点的父节点。</li><li>firstChild()：遍历到当前节点的第一个子节点。</li><li>lastChild()：遍历到当前节点的最后一个子节点。</li><li>nextSibing()：遍历到当前节点的下一个同辈节点。</li><li>previousSibing()：遍历到当前节点的上一个同辈节点。</li></ul></li></ul><p>创建TreeWalker对象要使用document.createTreeWalker()方法，这个方法接受的4个参数与document.createNodeIterator()方法相同：作为遍历起点的根节点、要显示的节点类型、过滤器、一个表示是否拓展实体引用的布尔值。</p><p>TreeWalker真正强大的地方在于能够在DOM结构中沿任何方向移动。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-15-DOM-2</title>
      <link href="/2019/12/05/Javascript-15-DOM-2/"/>
      <url>/2019/12/05/Javascript-15-DOM-2/</url>
      
        <content type="html"><![CDATA[<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p>在HTML中定义样式的方式有3种：</p><ul><li>通过<code>&lt;link/&gt;</code>元素包含外部样式表文件。</li><li>使用<code>&lt;style/&gt;</code>元素定义嵌入式样式。</li><li>使用style特性定义针对特定元素的样式。<a id="more"></a><h4 id="访问元素的样式"><a href="#访问元素的样式" class="headerlink" title="访问元素的样式"></a>访问元素的样式</h4></li></ul><p>任何支持style特性的HTML元素在Javascript中都有一个对应的style属性。这个style对象是CSSStyleDeclaration的实例，包含着通过HTML的style特性指定的所有样式信息，但不包含与外部样式表或嵌入样式表经层叠而来的样式。在style特性中指定的任何CSS属性都将表现为这个style对象的相应属性。对于使用短划线(分割不同词汇，例如background-image)的CSS属性名，必须将其转换成驼峰大小写形式，才能通过Javascript来访问。</p><p>多数情况下，都可以通过简单地转换属性名的格式来实现转换。其中一个不能直接转换的CSS属性就是float。由于float是JavaScript的保留字，因此不能用作属性名。</p><h5 id="DOM样式属性和方法"><a href="#DOM样式属性和方法" class="headerlink" title="DOM样式属性和方法"></a>DOM样式属性和方法</h5><ul><li>cssText：如前所述，通过它能够访问到style特性中的CSS代码。</li><li>length：应用给元素的CSS属性的数量。</li><li>parentRule：表示CSS信息的CSSRule对象。</li><li>getPropertyCSSValue(propertyName)：返回包含给定属性值的CSSValue类型。</li><li>getPropertyPriority(propertyName)：如果给定的属性使用了！important设置，则返回“important”；否则，则返回空字符串。</li><li>getPropertyValue(propertyName)：返回给定属性的字符串值。</li><li>item(index)：返回给定位置的CSS属性的名称。</li><li>removeProperty(propertyName)：从样式中删除给定属性。</li><li>setProperty(propertyName, value, priority)：将给定属性设置为相应的值，并加上优先权标志(“important”或者一个空字符串)。</li></ul><p>通过cssText属性可以访问style特性中的CSS代码。在读取模式下，cssText的值会重写整个styl特性的值；也就是说，以前通过style特性指定的样式信息都将丢失。</p><h5 id="计算的样式"><a href="#计算的样式" class="headerlink" title="计算的样式"></a>计算的样式</h5><p>getComputedStyle()方法接受两个参数：要取得计算样式的元素和一个伪元素字符串。如果不需要伪元素信息，第二个参数可以是null。该方法返回一个CSSStyleDeclaration对象(与style属性的类型相同)，其中包含当前元素的所有计算的样式。</p><p>无论在哪个浏览器中，最重要的一条是要记住所有计算的样式都是只读的；不能修改计算后样式对象中的CSS属性。此外，计算后的样式也包含属于浏览器内部样式表的样式信息，因此任何具有默认值的CSS属性都会表现在计算后的样式中。</p><h4 id="操作样式表"><a href="#操作样式表" class="headerlink" title="操作样式表"></a>操作样式表</h4><p>CSSStyleSheet类型表示的是样式表，包括通过<code>&lt;link&gt;</code>元素包含的样式表和在<code>&lt;style&gt;</code>元素中定义的样式表。它只表示样式表，而不管这些样式表在HTML中是如何定义的。</p><p>CSSStyleSheet继承自StyleSheet，后者可以作为一个基础接口来定义非CSS样式表。从StyleSheet接口继承而来的属性如下：</p><ul><li>disabled：表示样式表是否被禁用的布尔值。这个属性是可读/写的，将这个值设置为true可以禁用样式表。</li><li>href：如果样式表是通过<code>&lt;link&gt;</code>包含的，则是样式表的URL，否则是null；</li><li>media：当前样式表支持的所有媒体类型的集合。与所有DOM集合一样，这个集合也有一个length属性和一个item()方法。也可以使用方括号语法取得集合中特定的项。如果集合是空列表，表示样式表适用于所有媒体。</li><li>ownerNode：指向拥有当前样式表的节点的指针，样式表可能是在HTML中通过<code>&lt;link&gt;</code>或<code>&lt;style&gt;</code>引入的(在XML中可能使用过处理指令引入的)。如果当前样式表是其他样式表通过@import导入的，则这个属性为null。IE不支持这个属性。</li><li>parentStyleSheet：在当前样式表是通过@import导入的情况下，这个属性是一个指向导入它的样式表的指针。</li><li>title：ownerNode中title属性的值。</li><li>type：表示样式表类型的字符串。对CSS样式表而言，这个字符串是“type/css”。<br>除了disabled属性之外，其他属性都是只读的。在支持以上所有这些属性的基础上，CSSStyleSheet类型还支持下列属性和方法：</li><li>cssRules：样式表中包含的样式规则的集合。IE不支持这个属性，但有一个类似的rules属性。</li><li>ownerRule：如果样式表是通过@import导入的，这个属性就是一个指针，指向表示导入的规则，否则，值为null。IE不支持这个属性。</li><li>deleteRule(index)：删除cssRules集合中指定位置的规则。IE不支持这个方法，但支持一个类似的removeRule()方法。</li><li>insertRule(rule，index)：向cssRules中指定的位置插入rule字符串。IE不支持这个方法，但支持一个类似的addRule()方法。</li></ul><p>应用与文档的所有样式表是通过document.styleSheets集合来表示的。通过这个集合的length属性可以获知文档中样式表的数量，而通过方括号语法或item()方法可以访问每一个样式表。</p><h4 id="元素大小"><a href="#元素大小" class="headerlink" title="元素大小"></a>元素大小</h4><h5 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h5><p>偏移量(offset dimension)，包括元素在屏幕上占用的所有可见的空间。元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条、边框大小(不包括外边距)。通过下列4个属性可以取得元素的偏移量：</p><ul><li>offsetHeight：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、(可见的)水瓶滚动条的高度、上边框高度和下边框高度。</li><li>offsetWidth：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、(可见的)垂直滚动条的宽度、左边框宽度和右边框宽度。</li><li>offsetLeft：元素的左外边框至包含元素的左内边框之间的像素距离。</li><li>offsetTop：元素的上外边框至包含元素的上内边框之间的像素距离。</li></ul><h5 id="客户区大小"><a href="#客户区大小" class="headerlink" title="客户区大小"></a>客户区大小</h5><p>元素的客户区大小(client dimension)指的是元素内容及其内边距所占据的空间大小。</p><ul><li>clientWidth：元素内容区宽度加上左右内边距宽度。</li><li>clientHeight：元素内容区高度加上上下内边距高度。</li></ul><h5 id="滚动大小"><a href="#滚动大小" class="headerlink" title="滚动大小"></a>滚动大小</h5><p>滚动大小(scroll dimension)，指的是包含滚动内容的元素的大小。以下4个与滚动大小相关的属性：</p><ul><li>scrollHeight：在没有滚动条的情况下，元素内容的总高度。</li><li>scrollWidth：在没有滚动条的情况下，元素内容的总宽度。</li><li>scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。</li><li>scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。</li></ul><h5 id="确定元素大小"><a href="#确定元素大小" class="headerlink" title="确定元素大小"></a>确定元素大小</h5><p>getBoundingClientRect()方法，该方法返回一个矩形对象，包含4个属性：left、top、right、bottom。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-15-DOM-1</title>
      <link href="/2019/12/04/Javascript-15-DOM-1/"/>
      <url>/2019/12/04/Javascript-15-DOM-1/</url>
      
        <content type="html"><![CDATA[<p>DOM1级主要定义的是HTML和XML文档的底层结构。DOM2和DOM3级则在这个结构的基础上引入了更多的交互能力，也支持了更高级的XML特性。为此，DOM2和DOM3级分为许多模块(模块之间具有某种关联)，分别描述了DOM的某个非常具体的子集。这些模块如下：</p><ul><li>DOM2级核心：在1级核心基础上构建，为节点添加了更多的方法和属性。</li><li>DOM2级视图：为文档定义了基于样式信息的不同视图。</li><li>DOM2级事件：说明了如何使用事件与DOM文档交互。</li><li>DOM2级样式：定义了如何以编程方式来访问和改变CSS样式信息。</li><li>DOM2级遍历和范围：引入了遍历DOM文档和选择其特定部分的新接口。</li><li>DOM2级HTML：在1级HTML基础上构建，添加了更多属性、方法、新接口。<a id="more"></a><h3 id="DOM变化"><a href="#DOM变化" class="headerlink" title="DOM变化"></a>DOM变化</h3></li></ul><p>DOM2级和3级的目的在于扩展DOM API，以满足操作XML的所有需求，同时提供更好的错误处理及特性检测能力。从某种意义上讲，实现这一目的很大程度意味着对命名空间的支持。“DOM2级核心”没有引入新类型，它只是在DOM1级的基础上通过增加新方法和新属性来增加了既有类型。“DOM3级核心”同样增强了既有类型，但也引入了一些新类型，</p><p>类似地，“DOM2 级视图”和“DOM2 级HTML”模块也增强了DOM 接口，提供了新的属性和方法。由于这两个模块很小，因此我们将把它们与“DOM2 级核心”放在一起，讨论基本JavaScript 对象的变化。可以通过下列代码来确定浏览器是否支持这些DOM 模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var supportsDOM2Core &#x3D; document.implementation.hasFeature(&quot;Core&quot;, &quot;2.0&quot;);</span><br><span class="line">var supportsDOM3Core &#x3D; document.implementation.hasFeature(&quot;Core&quot;, &quot;3.0&quot;);</span><br><span class="line">var supportsDOM2HTML &#x3D; document.implementation.hasFeature(&quot;HTML&quot;, &quot;2.0&quot;);</span><br><span class="line">var supportsDOM2Views &#x3D; document.implementation.hasFeature(&quot;Views&quot;, &quot;2.0&quot;);</span><br><span class="line">var supportsDOM2XML &#x3D; document.implementation.hasFeature(&quot;XML&quot;, &quot;2.0&quot;);</span><br></pre></td></tr></table></figure><h4 id="针对XML命名空间的变化"><a href="#针对XML命名空间的变化" class="headerlink" title="针对XML命名空间的变化"></a>针对XML命名空间的变化</h4><p>有了XML命名空间，不同XML文档的元素就可以混合在一起，共同构成格式良好的文档，而不必担心发生命名冲突。从技术上说，HTML不支持XML命名空间，但XHTML支持XML命名空间。</p><p>XHTML的命名空间是<a href="http://www.w3.org/1999/xhtml，在任何格式良好XHTML页面中，都应该将其包含在`" target="_blank" rel="noopener">http://www.w3.org/1999/xhtml，在任何格式良好XHTML页面中，都应该将其包含在`</a><html>`元素中，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;Example XHTML page&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        Hello world!</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h5 id="Node类型的变化"><a href="#Node类型的变化" class="headerlink" title="Node类型的变化"></a>Node类型的变化</h5><p>在DOM2级中，Node类型包含下列特定于命名空间的属性。</p><ul><li>localName：不带命名空间前缀的节点名称。</li><li>namespaceURI：命名空间URI或者(在未指定的情况下是)null.</li><li>prefix：命名空间前缀或者(在未指定的情况下是)null。</li></ul><p>DOM3级在此基础上更进一步，又引入了下列与命名空间有关的方法。</p><ul><li>isDefaultNamespace(namespaceURI)：在指定的namespaceURI是当前节点的默认命名空间的情况下返回true。</li><li>lookupNamespaceURI(prefix)：返回给定prefix的命名空间。</li><li>lookupPrefix(namespaceURI)：返回给定namespaceURI的前缀。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">alert(document.body.isDefaultNamespace(&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;); &#x2F;&#x2F;true</span><br><span class="line">&#x2F;&#x2F;假设svg 中包含着对&lt;s:svg&gt;的引用</span><br><span class="line">alert(svg.lookupPrefix(&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot;)); &#x2F;&#x2F;&quot;s&quot;</span><br><span class="line">alert(svg.lookupNamespaceURI(&quot;s&quot;)); &#x2F;&#x2F;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Document类型的变化"><a href="#Document类型的变化" class="headerlink" title="Document类型的变化"></a>Document类型的变化</h5><p>DOM2级中的Document类型也发生了变化，包含下列与命名空间有关的方法。</p><ul><li>createElementNS(namespaceURI, tagName)：使用给定的tagName创建一个属于命名空间namespaceURI的新元素。</li><li>createAttributeNS(namespaceURI, attributeName)：使用给定的attributeName创建一个属于命名空间namespaceURI的新特性。</li><li>getElementsBytagNameNS(namespaceURI, tagName)：返回属于命名空间namespaceURI的tagName元素的NodeList。</li></ul><p>使用这些方法时需要传入表示命名空间的URI(而不是命名空间前缀)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建一个新的SVG 元素</span><br><span class="line">var svg &#x3D; document.createElementNS(&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot;,&quot;svg&quot;);</span><br><span class="line">&#x2F;&#x2F;创建一个属于某个命名空间的新特性</span><br><span class="line">var att &#x3D; document.createAttributeNS(&quot;http:&#x2F;&#x2F;www.somewhere.com&quot;, &quot;random&quot;);</span><br><span class="line">&#x2F;&#x2F;取得所有XHTML 元素</span><br><span class="line">var elems &#x3D; document.getElementsByTagNameNS(&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;, &quot;*&quot;);tps:&#x2F;&#x2F;blog.csdn.net&#x2F;Jane617_min&#x2F;article&#x2F;details&#x2F;49683873</span><br></pre></td></tr></table></figure><h5 id="Element类型的变化"><a href="#Element类型的变化" class="headerlink" title="Element类型的变化"></a>Element类型的变化</h5><ul><li>getAttributeNS(namespaceURI,localName)：取得属于命名空间namespaceURI 且名为localName 的特性。</li><li>getAttributeNodeNS(namespaceURI,localName)：取得属于命名空间namespaceURI 且名为localName 的特性节点。</li><li>getElementsByTagNameNS(namespaceURI, tagName)：返回属于命名空间namespaceURI的tagName 元素的NodeList。</li><li>hasAttributeNS(namespaceURI,localName)：确定当前元素是否有一个名为localName的特性，而且该特性的命名空间是namespaceURI。注“DOM2 级核心”也增加了一个hasAttribute()方法，用于不考虑命名空间的情况。</li><li>removeAttriubteNS(namespaceURI,localName)：删除属于命名空间namespaceURI 且名为localName 的特性。</li><li>setAttributeNS(namespaceURI,qualifiedName,value)：设置属于命名空间namespaceURI 且名为qualifiedName 的特性的值为value。</li><li>setAttributeNodeNS(attNode)：设置属于命名空间namespaceURI 的特性节点。<br>除了第一个参数之外，这些方法与DOM1 级中相关方法的作用相同；第一个参数始终都是一个命名空间URI。</li></ul><h5 id="NameNodeMap类型的变化"><a href="#NameNodeMap类型的变化" class="headerlink" title="NameNodeMap类型的变化"></a>NameNodeMap类型的变化</h5><p>NamedNodeMap 类型也新增了下列与命名空间有关的方法。由于特性是通过NamedNodeMap 表示的，因此这些方法多数情况下只针对特性使用。</p><ul><li>getNamedItemNS(namespaceURI,localName)：取得属于命名空间namespaceURI 且名为localName 的项。</li><li>removeNamedItemNS(namespaceURI,localName)：移除属于命名空间namespaceURI 且名为localName 的项。</li><li>setNamedItemNS(node)：添加node，这个节点已经事先指定了命名空间信息。<br>由于一般都是通过元素访问特性，所以这些方法很少使用。</li></ul><h4 id="其他方面的变化"><a href="#其他方面的变化" class="headerlink" title="其他方面的变化"></a>其他方面的变化</h4><h5 id="DocumentType类型的变化"><a href="#DocumentType类型的变化" class="headerlink" title="DocumentType类型的变化"></a>DocumentType类型的变化</h5><p>DOcumentType类型新增了3个属性：publicId、systemId、internalSubset。其中，前两个属性表示的是文档类型声明中的两个信息段，这两个信息段在DOM1级中是没有办法访问到的。</p><h5 id="Document类型的变化-1"><a href="#Document类型的变化-1" class="headerlink" title="Document类型的变化"></a>Document类型的变化</h5><p>Document类型的变化中唯一与命名空间无关的方法是importNode()。这个方法的用途是从一个文档中取得一个节点，然后将其导入另一个文档，使其成为这个文档结构的一部分。需要注意的是，每个节点都有一个ownerDocument属性，表示所属文档。如果调用appendChild()时传入的节点属于不同的文档(ownerDocument属性的值不一样)，则会导致错误。但在调用importNode()时传入不同文档的节点则会返回一个新节点，这个新节点的所有权归当前文档所有。</p><p>importNode()方法与Element的cloneNode()方法非常相似，它接受两个参数：要复制的节点和一个表示是否复制子节点的布尔值。返回的结果是原来节点的副本，但能够在当前文档中使用。</p><p>createDocumenttype()方法用于创建一个新的Documenttype节点，接受三个参数：文档类型名称、publicId、systemId。由于既有文档的文档类型不能改变，因此createDocumentType()只在创建新文档时有用；创建新文档需要用到createDocument()方法。这个方法接受3个参数：针对文档中元素的namespaceURI、文档元素的标签名、新文档的文档类型。</p><p>createHTML-Document()方法用来创建一个完整的HTML文档，包括<code>&lt;html&gt;、&lt;head&gt;、&lt;title&gt;、&lt;body&gt;</code>元素。这个方法只接受一个参数，即新创建文档的标题(放在<code>&lt;title&gt;</code>元素中的字符串)，返回新的HTML文档。</p><h5 id="Node类型的变化-1"><a href="#Node类型的变化-1" class="headerlink" title="Node类型的变化"></a>Node类型的变化</h5><p>Node类型中唯一与命名空间无关的变化，就是添加了isSupported()方法。与DOM1级为document.implementation引入的hasFeature()方法类似，isSupported()方法用于确定当前节点具有什么能力。这个方法接受两个参数：特性名和版本号。如果浏览器实现了相应特性，而且能够基于给定节点执行该特性，isSupported()就返回true。由于不同实现在决定对什么特性返回true或false时并不一致，这个方法同样也村子啊与hasFeature()方法相同的问题。为此，建议在确定某个特性是否可用时，最好还是使用能力检测。</p><p>DOM3级引入了两个辅助比较节点的方法：isSameNode()和isEuqalNode()。这两个方法都接受一个节点参数，并在传入节点与引用的节点相同或相等时返回true。所谓相同，值得时两个节点引用的时同一个对象。所谓相等，指的是两个节点是相同的类型，具有相等的属性(nodeName、nodeValue等)，而且它们的attributes和childNodes属性也相等(相同位置包含相同的值)。</p><p>setUserData()方法会将数据指定给节点，它接受三个参数：要设置的键、实际的数据和处理函数。</p><h5 id="框架的变化"><a href="#框架的变化" class="headerlink" title="框架的变化"></a>框架的变化</h5><p>框架和内嵌框架分别用HTMLFrameElement和HTMLIFrameElement表示，它们在DOM2级中都有了一个新属性-contentDocument。这个属性包含一个指针，指向表示框架内容的文档对象。在此之前，无法直接通过元素取得这个文档对象</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-14-DOM-4</title>
      <link href="/2019/11/28/Javascript-14-DOM-4/"/>
      <url>/2019/11/28/Javascript-14-DOM-4/</url>
      
        <content type="html"><![CDATA[<h3 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h3><p>注释在DOM中是通过Comment类型来表示的。Comment节点具有下列特征：</p><a id="more"></a><ul><li>nodeType的值为8；</li><li>nodeName的值为“#comment”；</li><li>nodeValue的值是注释的内容；</li><li>parentNode可能是Document或Element；</li><li>不支持(没有)子节点；</li></ul><p>Comment类型与Text类型继承自相同的基类，因此它拥有除了splitText()之外所有字符串操作方法。与Text类型相似，也可以通过nodeValue或data属性来取得注释的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注释节点可以通过其父节点来访问，以下面的代码为例</span><br><span class="line">&lt;div id&#x3D;&quot;myDiv&quot;&gt;&lt;!-- A comment --&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#x2F;&#x2F; 在此，注释节点是&lt;div&gt;元素的一个子节点，因此可以通过下面的代码来访问它</span><br><span class="line">var div &#x3D; document.getElementById(&#39;myDiv&#39;);</span><br><span class="line">var comment &#x3D; div.firstChild;</span><br><span class="line">alert(comment.data); &#x2F;&#x2F; &quot;A comment&quot;</span><br></pre></td></tr></table></figure><p>使用document.createComment()并为其传递注释文本也可以创注释节点，如下面的例子所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var comment &#x3D; document.createComment(&quot;A comment&quot;);</span><br></pre></td></tr></table></figure><h3 id="CDATASection类型"><a href="#CDATASection类型" class="headerlink" title="CDATASection类型"></a>CDATASection类型</h3><p>CDATASection类型只针对基于XML的文档，表示的是CDATA区域。与Comment类似，继承自Text类型，因此拥有除了splitText()之外的所有字符串操作方法。具有以下特征：</p><ul><li>nodeType的值为4；</li><li>nodeName的值为“#cdata-section”；</li><li>nodeValue的值是CDATA区域中的内容；</li><li>parentNode可能是Document或Element；</li><li>不支持(没有)子节点；</li></ul><p>在真正的XML文档中，可以使用document.createCDATASection()来创建CDATA区域，只需为其传入节点的内容即可。</p><h3 id="DucumentType类型"><a href="#DucumentType类型" class="headerlink" title="DucumentType类型"></a>DucumentType类型</h3><p>该类型在Web浏览器中并不常用，仅有Firefox、Safari、Opera支持。DocumentType包含着与文档的doctype有关的所有信息，它具有下列特征：</p><ul><li>nodeType的值为10;</li><li>nodeName的值为doctype的名称；</li><li>nodeValue的值为null；</li><li>parentNode是Document；</li><li>不支持(没有)子节点；</li></ul><h3 id="DocumentFragment类型"><a href="#DocumentFragment类型" class="headerlink" title="DocumentFragment类型"></a>DocumentFragment类型</h3><p>在所有节点类型中，只有DocumentFragment在文档中没有对应的标记。Dom规定文档片段(document fragment)是一种“轻量级”的文档，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。DocumentFragment节点具有下列特征：</p><ul><li>nodeType的值为11;</li><li>nodeName的值为“#document-fragment”;</li><li>nodeValue的值为null；</li><li>parentNode的值为null；</li><li>子节点可以是Element、ProcessingInstruction、Comment、Text、CDATASection或EntityReference。</li></ul><h3 id="Attr类型"><a href="#Attr类型" class="headerlink" title="Attr类型"></a>Attr类型</h3><p>元素的特性在DOM中以Attr类型来表示。在所有浏览器中(包括IE8)，都可以访问Attr类型的构造函数和原型。从技术角度讲，特性就是存在于元素的attributes属性中的节点。特性节点具有下列特征：</p><ul><li>nodeType的值为2；</li><li>nodeName的值是特性的名称；</li><li>nodeValue的值是特性的值；</li><li>parentNode的值为null；</li><li>在HTML中不支持(没有)子节点；</li><li>在XML中子节点可以是Text或EntityReference。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-14-DOM-3</title>
      <link href="/2019/11/24/Javascript-14-DOM-3/"/>
      <url>/2019/11/24/Javascript-14-DOM-3/</url>
      
        <content type="html"><![CDATA[<h3 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h3><p>Element类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。具有以下特征：</p><a id="more"></a><ul><li>nodeType的值为1；</li><li>nodeName的值为元素的标签名；</li><li>nodeValue的值为null；</li><li>parentNode可能是Document或Element；</li><li>其子节点可能是Element、Text、Comment、ProcessingInstruction、CDATASection或EnttyReference。</li></ul><p>要访问元素的标签名，可以使用nodeName属性，也可以使用tagName属性；这两个属性会返回相同的值。</p><h4 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h4><p>所有HTML元素都由HTMLElement类型表示，不是直接通过这个类型，也是通过它的子类型来表示。HTMLElement类型直接继承自Element并添加了一些属性。添加的这些属性分别对应于每个HTML元素中都存在的下列标准特性：</p><ul><li>id，元素在文档中的唯一标识符。</li><li>title，有关元素的附加说明信息，一版通过工具提示条显示出来。</li><li>lang，元素内容的语言代码，很少使用。</li><li>dir，语言的方向，值为“ltr”(left-to-right，从左至右)或“rtl”(right-to-left，从右至左)，也很少使用。</li><li>className，与元素的class特性对应，即为元素指定的CSS类。没有讲这个属性命名为class，是因为class是JS的保留字。</li></ul><h4 id="取得特性"><a href="#取得特性" class="headerlink" title="取得特性"></a>取得特性</h4><p>每个元素都有一或多个特性，这些特性的用途是给出相应元素或其内容的附加信息，操作特性的DOM方法主要有三个，分别是getAttribute()、serAttribute()、removeAttribute()。这三个方法可以针对任何特性使用，包括那些以HTMLElement类型属性定义的特性。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var div &#x3D; document.getElementById(&#39;myDiv&#39;);</span><br><span class="line">alert(div.getAttribute(&#39;id&#39;)); &#x2F;&#x2F; &quot;myDiv&quot;</span><br><span class="line">alert(div.getAttribute(&#39;class&#39;)); &#x2F;&#x2F; &quot;bd&quot;</span><br><span class="line">alert(div.getAttribute(&#39;title&#39;)); &#x2F;&#x2F; &quot;Body text&quot;</span><br><span class="line">alert(div.getAttribute(&#39;lang&#39;)); &#x2F;&#x2F; &quot;en&quot;</span><br><span class="line">alert(div.getAttribute(&#39;dir&#39;)); &#x2F;&#x2F; &quot;ltr&quot;</span><br></pre></td></tr></table></figure><p>注意，传递给getAttribute()的特性名与实际的特性名相同。因此想要得到class特性值，应该传入“class”而不是“className”，后者只有在通过对象属性访问特性时采用。如果给定名称的特性不存在，则返回null。</p><p>特性的名称是不区分大小写的，即“ID”和‘id’代表的是同一个特性。另外也要注意，根据HTML5规范，自定义特性应该加上data-前缀以便验证。</p><p>有两类特殊的特性，它们虽然有对应的属性名，但属性的值与通过getAttribute()返回的值并不相同。第一类特性就是style，用于通过CSS为元素指定样式。在通过getAttribute()访问时，返回的style特性值中包含的是CSS文本，而通过属性来访问它则会返回一个对象，由于style属性是用于以编程方式访问元素样式的，因此并没有直接映射到style特性。</p><p>第二类与众不同的特性是onclick这样的事件处理程序。当在元素上使用时，onclick特性中包含的是JS代码，如果通过getAttribute()访问，则会返回相应代码的字符串。而在访问onclick属性时，则会返回一个JS函数(如果未在元素中指定相应特性，则返回null)。这是因为onclick及其他事件处理程序本身就应该被赋予函数值。</p><h4 id="设置特性"><a href="#设置特性" class="headerlink" title="设置特性"></a>设置特性</h4><p>setAttribute()，这个方法接受两个参数：要设置的特性名和值。如果特性已经存在，会以指定的值替换现有的值；如果特性不存在，则会创建该属性并设置相应的值。</p><p>removeAttribute()，用于彻底删除元素的特性，调用这个方法不仅会清楚特性的值，而且也会从元素中完全删除特性。</p><h4 id="attributes属性"><a href="#attributes属性" class="headerlink" title="attributes属性"></a>attributes属性</h4><p>Element类型是使用attributes属性的唯一一个DOM节点类型。attributes属性中包含一个NameNodeMap，与nodeList类似，也是一个“动态”集合。元素的每一个特性都由一个Attr节点表示，每个节点都保存在NameNodeMap对象中。NameNodeMap对象拥有下列方法。</p><ul><li>getNamedItem(name)：返回nodeName属性等于name的节点。</li><li>removeNamedItem(name)：从列表中移除nodeName属性等于name的节点。</li><li>setNamedItem(node)：向列表中添加节点，以节点的nodeName属性为索引。</li><li>item(pos)：返回位于数字pos位置处的节点，</li></ul><h4 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h4><p>使用document.createElement()方法可以创建新元素，这恶搞方法只接受一个参数，即要创建元素的标签名。这个标签名在HTML文档中不区分大小写，而在XML(包括XHTML)文档中，则是区分大小写的。</p><p>在使用createElement()方法创建新元素的同时，也为新元素设置了ownerDocument属性。此外，还可以操作元素的特性，为它添加更多的子节点，以及执行其他操作。在新元素上设置这些特性只是给它们赋予了相应的信息。由于新元素尚未被添加到文档树中，因此设置这些特性不会影响浏览器的显示。要把新元素添加到文档树，可以使用appendChild()、insertBefore()、replaceChild()方法。</p><p>一旦将元素添加到文档树中，浏览器就会立即呈现该元素。此后，对这个元素所作的任何修改都会实时反映在浏览器中。</p><h4 id="元素的子节点"><a href="#元素的子节点" class="headerlink" title="元素的子节点"></a>元素的子节点</h4><p>元素可以有任意数目的子节点和后代节点，因为元素可以是其他元素的子节点。元素的childNodes属性中包含了它的所有子节点，这些子节点可能是元素、文本节点、注释、处理指令。</p><h3 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h3><p>文本节点由Text类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的HTML字符，但不能包含HTML代码。Text节点具有以下特征：</p><ul><li>nodeType的值为3；</li><li>nodeName的值为“#text”；</li><li>nodeValue的值为节点所包含的文本；</li><li>parentNode是一个Element；</li><li>不支持子节点</li></ul><p>可以通过nodeValue属性或data属性访问Text节点中包含的文本，这两个属性中包含的值相同。对nodeValue的修改也会通过data反映出来，反之亦然。使用下列方法可以操作节点中的文本。</p><ul><li>appendData(text): 将text添加到节点的末尾。</li><li>deleteData(offset, count)：从offset指定的位置开始嘶喊出count个字符。</li><li>insertData(offset, text)：在offset指定的位置插入text。</li><li>replaceData(offset, count, text)：用text替换从offset指定的位置开始到offset+count为止处的文本。</li><li>splitText(offset)：从offset指定的位置将当前文本节点分成两个文本节点。</li><li>substringData(offset, count)：提取从offset指定的位置开始到offset+count为止处的字符串。</li></ul><h4 id="创建文本节点"><a href="#创建文本节点" class="headerlink" title="创建文本节点"></a>创建文本节点</h4><p>document.createTextNode()创建新文本节点，这个方法接受一个参数–要插入节点中的文本。与设置已有文本节点的值一样，作为参数的文本也将按照HTML或XML的格式进行编码。</p><h4 id="规范化文本节点"><a href="#规范化文本节点" class="headerlink" title="规范化文本节点"></a>规范化文本节点</h4><p>DOM文档中存在相邻的同胞文本节点很容易导致混乱，因为分不清哪个文本节点表示哪个字符串。另外，DOM文档中出现相邻文本节点的情况也不在少数，于是就催生了一个能够将相邻文本节点合并的方法。这个方法是由Node类型定义的(因而在所有节点类型中都存在)，名叫normalize()。如果在一个包含两个或多个文本节点的父元素上调用normalize()方法，则会将所有文本节点合并成一个节点，结果节点的nodeValue等于将合并前每个文本节点的nodevalue值拼接起来的值。</p><p>浏览器在解析文档时永远不会创建相邻的文本节点。这种情况只会作为执行DOM操作的结果出现。</p><h4 id="分割文本节点"><a href="#分割文本节点" class="headerlink" title="分割文本节点"></a>分割文本节点</h4><p>splitText()：将一个文本节点分成两个文本节点，即按照执行的位置分割nodeValue值。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点与愿节点的parentNode相同。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-14-DOM-2</title>
      <link href="/2019/11/18/Javascript-14-DOM-2/"/>
      <url>/2019/11/18/Javascript-14-DOM-2/</url>
      
        <content type="html"><![CDATA[<h3 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h3><p>JS通过Document类型表示文档。在浏览器中，document对象是HTMLDocument(继承自Document类型)的一个实例，表示整个HTML页面。其中，document对象是window对象的一个属性，因此可以将其作为全局对象来访问，Document节点具有以下特征：</p><a id="more"></a><ul><li>nodeType的值为9；</li><li>nodeName的值为“#document”；</li><li>nodeValue的值为null；</li><li>parentNode的值为null；</li><li>ownerDocument的值为null；</li><li>其子节点可能是一个DocumentType(最多一个)、Element(最多一个)、ProcessingInstruction或Comment。</li></ul><p>Document类型可以表示HTML页面或者其他基于XML的文档。不过，最常见的应用还是作为HTMLDocument实例的document对象。通过这个文档对象，不仅可以取得与页面有关的信息，而且还能操作页面的外观及其底层结构。</p><h4 id="文档的子节点"><a href="#文档的子节点" class="headerlink" title="文档的子节点"></a>文档的子节点</h4><p>虽然DOM标准规定Document节点的子节点可以是DocumentType、Element、ProcessingInstruction或Comment，但还有两个内置的访问其子节点的快捷方式。第一个就是DocumentElement属性，该属性始终指向HTML页面中的<code>&lt;html&gt;</code>元素。另一个就是通过ChildNodes列表访问文档元素。</p><p>作为HTMLDocument的实例，document对象还有一个body属性，直接指向<code>&lt;body&gt;</code>元素。</p><p>所有浏览器都支持document.documentElement和document.body属性。</p><h4 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h4><p>作为HTMLDocument的一个实例，document对象还有一些标准的Document对象所没有的属性。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 取得文档标题</span><br><span class="line">var originalTitle &#x3D; document.title;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置文档标题</span><br><span class="line">document.title &#x3D; &quot;New page title&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取得完整的URL</span><br><span class="line">var url &#x3D; document.URL;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取得域名</span><br><span class="line">var domain &#x3D; document.domain;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取得来源页面的URL</span><br><span class="line">var referrer &#x3D; document.referrer;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 假设页面来自p2p.wrox.com域</span><br><span class="line">document.domain &#x3D; &quot;wrox.com&quot;; &#x2F;&#x2F; 成功</span><br><span class="line"></span><br><span class="line">document.domain &#x3D; &quot;nczonline.net&quot;; &#x2F;&#x2F; 出错</span><br></pre></td></tr></table></figure><h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><p>Document类型提供了两个方法。</p><p>1，getElementById()，接收一个参数：要取得元素的ID，找到则返回该元素，不存在则返回null。注意，这里的ID必须与页面中元素的id严格匹配，包括大小写。</p><p>2，getElementsByTagName()，接收一个参数：要取得元素的标签名，而返回的是包含零或多个元素的NodeList。</p><p>只有HTMLDocument类型才有的方法：getElementsByName()，返回带有给定name特性的所有元素。</p><h4 id="特殊集合"><a href="#特殊集合" class="headerlink" title="特殊集合"></a>特殊集合</h4><ul><li>document.anchors，包含文档中所有带name特性的<code>&lt;a&gt;</code>元素。</li><li>document.applets，包含文档中所有的<code>&lt;applet&gt;</code>元素，因为不再推荐使用<code>&lt;applet&gt;</code>元素，所以这个集合已经不建议使用了。</li><li>document.forms，包含文档中所有的<code>&lt;form&gt;</code>元素，与document.getElementsByTagName(‘form’)得到的结果相同。</li><li>document.images，包含文档中所有的<code>&lt;img&gt;</code>元素，与document.getElementsByTagName(‘img’)得到的结果相同。</li><li>document.links，包含文档中所有带href特性的<code>&lt;a&gt;</code>元素。</li></ul><h4 id="DOM一致性检测"><a href="#DOM一致性检测" class="headerlink" title="DOM一致性检测"></a>DOM一致性检测</h4><p>由于DOM分为多个级别，也包含多个部分，因此检测浏览器实现了DOM的哪些部分就十分必要。document.implementation属性就是这些提供相应信息和功能的对象。与浏览器对DOM的实现直接对应。、DOM1级只为document.implementation规定了一个方法，即hasFeature()。这个方法接受两个参数:要检测的DOM功能的名称及版本号。如果浏览器支持给定名称和版本的功能，则该方法返回true。</p><p>下表列出了可以检测的不同的值及版本号：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZS1zdGF0aWMuc2VnbWVudGZhdWx0LmNvbS8yODgvNjgyLzI4ODY4MjY2My01N2NmNmZlNTEwY2QyX2FydGljbGV4?x-oss-process=image/format,png" alt=""></p><h4 id="文档写入"><a href="#文档写入" class="headerlink" title="文档写入"></a>文档写入</h4><ul><li><p>write();</p></li><li><p>writeIn();</p></li><li><p>open();</p></li><li><p>close();</p><p>write()和writeIn()接受一个字符串参数，既要写入到输出流的文本。write()会原样写入，而writeIn()则会在字符串的末尾添加一个换行符(\n)。</p><p>open()和close()分别用于打开和关闭网页的输出流。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-14-DOM-1</title>
      <link href="/2019/11/07/Javascript-14-DOM-1/"/>
      <url>/2019/11/07/Javascript-14-DOM-1/</url>
      
        <content type="html"><![CDATA[<p>DOM(文档对象模型)是针对HTML和XML文档的一个API。DOM描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。DOM脱胎于DHTML(动态HTML)，但现在它已经成为表现和操作页面标记的真正的跨平台、语言中立的方式。</p><p><font color=red>注意：IE中的所有DOM对象都是以COM对象的形式实现的，这意味折IE中的DOM对象与原生JS对象的行为或活动特点并不一致。</font></p><a id="more"></a><h3 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h3><p>DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。节点分为几种不同的类型，每种类型分别表示文档中不同的信息及标记。每个节点都拥有各自的特点、数据和方法，另外也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的属性结构。</p><p>文档节点是每个文档的根节点。文档节点的子节点称之为文档元素。文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。<font color=red>每个文档只能有一个文档元素。在HTML页面中，文档元素始终都是<code>&lt;hmtl&gt;</code>元素。在XML中，没有预定义的元素，因此任何元素都可能成为文档元素。</font></p><p>每一段标记都可以通过树中的一个节点来表示：HTML元素通过元素节点表示，特性通过特性节点表示，文档类型通过文档类型节点表示，而注释通过注释节点表示。总共有12中节点类型，这些类型都继承自一个基类型。</p><h4 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h4><p>DOM1级定义了一个Node接口，该接口将由DOM中的所有节点实现。这个Node接口在JS中是作为Node类型实现的；除了IE之外，在其他所有浏览器中都可以访问到这个类型。JS中的所有节点类型都继承自Node类型，因此所有节点类型都共享者相同的基本属性和方法。</p><p>每个节点都有一个nodeType类型，用于表明节点的类型。节点类型由在Node类型中定义的下列12个数值常量来表示，任何节点类型必居其一：</p><ul><li>Node.ELEMENT_NODE(1);</li><li>Node.ATTRIBUTE_NODE(2);</li><li>Node.TEXT_NODE(3);</li><li>Node.CDATA_SECTION_NODE(4);</li><li>Node.ENTITY_REFERENCE_NODE(5);</li><li>Node.ENTITY_NODE(6);</li><li>Node.PROCESSING_INSTRUCTION_NODE(7);</li><li>Node.COMMENT_NODE(8);</li><li>Node.DOCUMENT_NODE(9);</li><li>Node.DOCUMENT_TYPE_NODE(10);</li><li>Node.DOCUMENT_FRAGMENT_NODE(11);</li><li>Node.NOTATION_NODE(12);</li></ul><h5 id="nodeName和nodeValue属性"><a href="#nodeName和nodeValue属性" class="headerlink" title="nodeName和nodeValue属性"></a>nodeName和nodeValue属性</h5><p>要了解节点的具体信息，可以使用nodeName和nodeValue这两个属性。这两个属性的值完全取决于节点的类型。在使用之前要先检测一下节点的类型。</p><h5 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h5><p>节点间的关系可以用传统的家族关系来描述，相当于把文档树比喻成家谱。</p><p>每个节点都有一个childNodes属性，其中保存着一个NodeList对象。NodeList是一种累数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。NodeList对象的独特之处在于，它实际上是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映在NodeList对象中，</p><p>每个节点都有一个parentNode属性，该属性指向文档树中的父节点。包含在childNodes列表中的所有节点都具有相同的父节点，因此它们的parentNode属性都指向同一个节点。此外，包含在childNodes列表中的每个节点相互之间都是同胞节点。通过使用列表中每个节点的previousSibling和nextSibling属性，可以访问同一列表中的其他节点。列表中第一个节点的previousSibling属性和最后一个节点的nextSibling属性为null。</p><p>父节点的firstChild和lastChild属性分别指向其childNodes列表中的第一个和最后一个节点，</p><p>hasChildNodes()在节点包含一个或多个子节点的情况下返回true。所有节点都有的最后一个属性是ownerDocument，该属性指向表示整个文档的文档节点。这种关系表示的是任何节点都属于它所在的文档，任何节点都不能同时存在于两个或更多个文档中。通过这个属性可以直接访问文档节点。</p><h5 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h5><p>appendChild()用于向childNodes列表的末尾添加一个节点。添加完成后appendChild()返回新增的节点，</p><p>insertBefore()插入节点，接受两个参数：要插入的节点和作为参照的节点。</p><p>replaceChild()替换节点，接受两个参数：要插入的节点和要替换的节点。</p><p>removeChild()移除节点。</p><p>cloneNode()用于创建调用这个方法的节点的一个完全相同的副本，接受一个布尔值参数表示是否执行深复制。true复制节点及其整个子节点树；false只复制节点本身，、。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-13-客户端检测</title>
      <link href="/2019/11/03/Javascript-13-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B/"/>
      <url>/2019/11/03/Javascript-13-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<p>浏览器提供商虽然在实现公共接口方面投入了很多精力，但结果仍然是每一种浏览器都有各自的长处，也都有各自的缺点。即使是那些跨平台的浏览器，虽然从技术上看版本相同，也照样存在不一致性问题。因此客户端检测是一种补救措施，不到万不得已就不要使用客户端检测。</p><a id="more"></a><h3 id="能力检测"><a href="#能力检测" class="headerlink" title="能力检测"></a>能力检测</h3><p>能力检测的目的不是检测浏览器类型，而是检测浏览器是否有该功能。举例来说IE5.0之前的版本不支持document.getElementById()这个DOM方法，但是可以用document.all属性去实现这个功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function getElement(id) &#123;</span><br><span class="line">       if (document.getElementById) &#123;</span><br><span class="line">           return document.getElementById(id);</span><br><span class="line">       &#125; else if (document.all) &#123;</span><br><span class="line">           return document.all[id];</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           throw new Error(&quot;No way to retrieve element!&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>使用能力检测有两点要注意：1.把更通用的，性能更佳的方法写在前面。2.必须测试实际用到的特性。不能以为有document.all就认为它是IE而去使用IE拥有的特征。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getWindowWidth() &#123;</span><br><span class="line">       if (document.all) &#123; &#x2F;&#x2F;假设是IE</span><br><span class="line">           return document.documentElement.clientWidth;&#x2F;&#x2F;错误的用法</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return window.innerWidth;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="更可靠的能力检测"><a href="#更可靠的能力检测" class="headerlink" title="更可靠的能力检测"></a>更可靠的能力检测</h4><p>使用typeof操作符的确能让检测更加可靠，但是也有例外。在IE8及以前的版本中DOM对象的方法的类型是object而不是function。这是因为DOM对象是宿主对象，IE的早期版本中宿主对象是通过COM而非JScript实现的。因此像document.createElement()函数在IE早期的确是一个COM对象而非function。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;IE8及以前不行</span><br><span class="line">  function hasCreateElement() &#123;</span><br><span class="line">      return typeof document.createElement &#x3D;&#x3D; &quot;function&quot;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>仅IE支持的ActiveX对象与其他对象的差异也很大。例如，不适用typeof检测某个属性会导致错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new ActiveXObject(&quot;Microsoft.XMLHttp&quot;);</span><br><span class="line">    if (xhr.open) &#123; &#x2F;&#x2F;书上说这里会出错，但IE9 xhr.open为undefined</span><br><span class="line">        &#x2F;&#x2F;执行操作</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">function isHostMethod(object, property) &#123;</span><br><span class="line">        var t &#x3D; typeof object[property];</span><br><span class="line">        return t &#x3D;&#x3D; &quot;function&quot; || t &#x3D;&#x3D; &quot;unknown&quot; &#x2F;&#x2F;IE对typeof xhr.open 会返回&quot;unknown&quot;</span><br><span class="line">            || !!(t &#x3D;&#x3D; &quot;object&quot; &amp;&amp; object[property]);&#x2F;&#x2F;是COM对象 且不为null</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="能力检测，不是浏览器检测"><a href="#能力检测，不是浏览器检测" class="headerlink" title="能力检测，不是浏览器检测"></a>能力检测，不是浏览器检测</h4><p>在实际开发中，应该将能力检测作为确定下一步解决方案的依据，而不是用它来判断用户使用的是什么浏览器。下面是两个典型误用和两个正确用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;错误！还不够具体。且后期Safari也实现了相同的属性。</span><br><span class="line">    var isFirefox &#x3D; !!(navigator.vendor &amp;&amp; navigator.vendorSub);</span><br><span class="line">    &#x2F;&#x2F;错误！假设过头了。假设了IE将来版本也会实现这两个属性，且其他浏览器不会实现。</span><br><span class="line">    var isIE &#x3D; !!(document.all &amp;&amp; document.uniqueID);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;确认浏览器是否支持Netscape风格插件</span><br><span class="line">    var hasNSPlugins &#x3D; !!(navigator.plugins &amp;&amp; navigator.plugins.length);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;确定浏览器是否具有DOM1级规定的能力</span><br><span class="line">    var hasDOM1 &#x3D; !!(document.getElementById &amp;&amp; document.createElement &amp;&amp; document.getElementsByTagName);</span><br></pre></td></tr></table></figure><h3 id="怪癖检测"><a href="#怪癖检测" class="headerlink" title="怪癖检测"></a>怪癖检测</h3><p>怪癖检测的目标是识别浏览器的特殊行为。耽于能力检测确认浏览器支持什么能力不同，怪癖检测是想要知道浏览器存在什么缺陷（即bug）。通常要尝试运行一段代码，以确定某一特性不能正常工作。例如在IE8及其早期版本中，如果某个实例属性和原来标记为不可枚举的属性同名，那么该属性就不会出现在for-in循环中。还有Safari3以前版本中会枚举被隐藏的属性。可以通过下面的例子来检测怪癖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var hasDontEnumQuirk &#x3D; function()&#123;</span><br><span class="line">       var o &#x3D; &#123; toString : function()&#123;&#125; &#125;;</span><br><span class="line">       for (var prop in o)&#123;</span><br><span class="line">           if (prop &#x3D;&#x3D; &quot;toString&quot;)&#123;</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;();&#x2F;&#x2F;匿名函数直接执行</span><br><span class="line">   var hasEnumShadowsQuirk &#x3D; function()&#123;</span><br><span class="line">       var o &#x3D; &#123; toString : function()&#123;&#125; &#125;;</span><br><span class="line">       var count &#x3D; 0;</span><br><span class="line">       for (var prop in o)&#123;</span><br><span class="line">           if (prop &#x3D;&#x3D; &quot;toString&quot;)&#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return (count &gt; 1);</span><br><span class="line">   &#125;();&#x2F;&#x2F;匿名函数直接执行</span><br><span class="line">   alert(hasDontEnumQuirk);</span><br><span class="line">   alert(hasEnumShadowsQuirk);</span><br></pre></td></tr></table></figure><h3 id="用户代理检测"><a href="#用户代理检测" class="headerlink" title="用户代理检测"></a>用户代理检测</h3><p>以下是完整的用户代理字符串检测脚本，包括检测呈现引擎、平台、Windows 操作系统、移动设备和游戏系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">var client &#x3D; function()&#123;</span><br><span class="line">&#x2F;&#x2F;呈现引擎</span><br><span class="line">var engine &#x3D; &#123;</span><br><span class="line">ie: 0,</span><br><span class="line">gecko: 0,</span><br><span class="line">webkit: 0,</span><br><span class="line">khtml: 0,</span><br><span class="line">opera: 0,</span><br><span class="line">&#x2F;&#x2F;完整的版本号</span><br><span class="line">ver: null</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;浏览器</span><br><span class="line">var browser &#x3D; &#123;</span><br><span class="line">&#x2F;&#x2F;主要浏览器</span><br><span class="line">ie: 0,</span><br><span class="line">firefox: 0,</span><br><span class="line">safari: 0,</span><br><span class="line">konq: 0,</span><br><span class="line">opera: 0,</span><br><span class="line">chrome: 0,</span><br><span class="line">&#x2F;&#x2F;具体的版本号</span><br><span class="line">ver: null</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;平台、设备和操作系统</span><br><span class="line">var system &#x3D; &#123;</span><br><span class="line">win: false,</span><br><span class="line">mac: false,</span><br><span class="line">x11: false,</span><br><span class="line">&#x2F;&#x2F;移动设备</span><br><span class="line">iphone: false,</span><br><span class="line">ipod: false,</span><br><span class="line">ipad: false,</span><br><span class="line">ios: false,</span><br><span class="line">android: false,</span><br><span class="line">nokiaN: false,</span><br><span class="line">winMobile: false,</span><br><span class="line">&#x2F;&#x2F;游戏系统</span><br><span class="line">wii: false,</span><br><span class="line">ps: false</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;检测呈现引擎和浏览器</span><br><span class="line">var ua &#x3D; navigator.userAgent;</span><br><span class="line">if (window.opera)&#123;</span><br><span class="line">engine.ver &#x3D; browser.ver &#x3D; window.opera.version();</span><br><span class="line">engine.opera &#x3D; browser.opera &#x3D; parseFloat(engine.ver);</span><br><span class="line">&#125; else if (&#x2F;AppleWebKit\&#x2F;(\S+)&#x2F;.test(ua))&#123;</span><br><span class="line">engine.ver &#x3D; RegExp[&quot;$1&quot;];</span><br><span class="line">engine.webkit &#x3D; parseFloat(engine.ver);</span><br><span class="line">&#x2F;&#x2F;确定是Chrome 还是Safari</span><br><span class="line">if (&#x2F;Chrome\&#x2F;(\S+)&#x2F;.test(ua))&#123;</span><br><span class="line">browser.ver &#x3D; RegExp[&quot;$1&quot;];</span><br><span class="line">browser.chrome &#x3D; parseFloat(browser.ver);</span><br><span class="line">&#125; else if (&#x2F;Version\&#x2F;(\S+)&#x2F;.test(ua))&#123;</span><br><span class="line">browser.ver &#x3D; RegExp[&quot;$1&quot;];</span><br><span class="line">browser.safari &#x3D; parseFloat(browser.ver);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;近似地确定版本号</span><br><span class="line">var safariVersion &#x3D; 1;</span><br><span class="line">if (engine.webkit &lt; 100)&#123;</span><br><span class="line">safariVersion &#x3D; 1;</span><br><span class="line">&#125; else if (engine.webkit &lt; 312)&#123;</span><br><span class="line">safariVersion &#x3D; 1.2;</span><br><span class="line">&#125; else if (engine.webkit &lt; 412)&#123;</span><br><span class="line">safariVersion &#x3D; 1.3;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">safariVersion &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line">browser.safari &#x3D; browser.ver &#x3D; safariVersion;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (&#x2F;KHTML\&#x2F;(\S+)&#x2F;.test(ua) || &#x2F;Konqueror\&#x2F;([^;]+)&#x2F;.test(ua))&#123;</span><br><span class="line">engine.ver &#x3D; browser.ver &#x3D; RegExp[&quot;$1&quot;];</span><br><span class="line">engine.khtml &#x3D; browser.konq &#x3D; parseFloat(engine.ver);</span><br><span class="line">&#125; else if (&#x2F;rv:([^\)]+)\) Gecko\&#x2F;\d&#123;8&#125;&#x2F;.test(ua))&#123;</span><br><span class="line">engine.ver &#x3D; RegExp[&quot;$1&quot;];</span><br><span class="line">engine.gecko &#x3D; parseFloat(engine.ver);</span><br><span class="line">&#x2F;&#x2F;确定是不是Firefox</span><br><span class="line">if (&#x2F;Firefox\&#x2F;(\S+)&#x2F;.test(ua))&#123;</span><br><span class="line">browser.ver &#x3D; RegExp[&quot;$1&quot;];</span><br><span class="line">browser.firefox &#x3D; parseFloat(browser.ver);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (&#x2F;MSIE ([^;]+)&#x2F;.test(ua))&#123;</span><br><span class="line">engine.ver &#x3D; browser.ver &#x3D; RegExp[&quot;$1&quot;];</span><br><span class="line">engine.ie &#x3D; browser.ie &#x3D; parseFloat(engine.ver);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;检测浏览器</span><br><span class="line">browser.ie &#x3D; engine.ie;</span><br><span class="line">browser.opera &#x3D; engine.opera;</span><br><span class="line">&#x2F;&#x2F;检测平台</span><br><span class="line">var p &#x3D; navigator.platform;</span><br><span class="line">system.win &#x3D; p.indexOf(&quot;Win&quot;) &#x3D;&#x3D; 0;</span><br><span class="line">system.mac &#x3D; p.indexOf(&quot;Mac&quot;) &#x3D;&#x3D; 0;</span><br><span class="line">system.x11 &#x3D; (p &#x3D;&#x3D; &quot;X11&quot;) || (p.indexOf(&quot;Linux&quot;) &#x3D;&#x3D; 0);</span><br><span class="line">&#x2F;&#x2F;检测Windows 操作系统</span><br><span class="line">if (system.win)&#123;</span><br><span class="line">if (&#x2F;Win(?:dows )?([^do]&#123;2&#125;)\s?(\d+\.\d+)?&#x2F;.test(ua))&#123;</span><br><span class="line">if (RegExp[&quot;$1&quot;] &#x3D;&#x3D; &quot;NT&quot;)&#123;</span><br><span class="line">switch(RegExp[&quot;$2&quot;])&#123;</span><br><span class="line">case &quot;5.0&quot;:</span><br><span class="line">system.win &#x3D; &quot;2000&quot;;</span><br><span class="line">break;</span><br><span class="line">case &quot;5.1&quot;:</span><br><span class="line">system.win &#x3D; &quot;XP&quot;;</span><br><span class="line">break;</span><br><span class="line">case &quot;6.0&quot;:</span><br><span class="line">system.win &#x3D; &quot;Vista&quot;;</span><br><span class="line">break;</span><br><span class="line">case &quot;6.1&quot;:</span><br><span class="line">system.win &#x3D; &quot;7&quot;;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">system.win &#x3D; &quot;NT&quot;;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (RegExp[&quot;$1&quot;] &#x3D;&#x3D; &quot;9x&quot;)&#123;</span><br><span class="line">system.win &#x3D; &quot;ME&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">system.win &#x3D; RegExp[&quot;$1&quot;];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;移动设备</span><br><span class="line">system.iphone &#x3D; ua.indexOf(&quot;iPhone&quot;) &gt; -1;</span><br><span class="line">system.ipod &#x3D; ua.indexOf(&quot;iPod&quot;) &gt; -1;</span><br><span class="line">system.ipad &#x3D; ua.indexOf(&quot;iPad&quot;) &gt; -1;</span><br><span class="line">system.nokiaN &#x3D; ua.indexOf(&quot;NokiaN&quot;) &gt; -1;</span><br><span class="line">&#x2F;&#x2F;windows mobile</span><br><span class="line">if (system.win &#x3D;&#x3D; &quot;CE&quot;)&#123;</span><br><span class="line">system.winMobile &#x3D; system.win;</span><br><span class="line">&#125; else if (system.win &#x3D;&#x3D; &quot;Ph&quot;)&#123;</span><br><span class="line">if(&#x2F;Windows Phone OS (\d+.\d+)&#x2F;.test(ua))&#123;;</span><br><span class="line">system.win &#x3D; &quot;Phone&quot;;</span><br><span class="line">system.winMobile &#x3D; parseFloat(RegExp[&quot;$1&quot;]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;检测iOS 版本</span><br><span class="line">if (system.mac &amp;&amp; ua.indexOf(&quot;Mobile&quot;) &gt; -1)&#123;</span><br><span class="line">if (&#x2F;CPU (?:iPhone )?OS (\d+_\d+)&#x2F;.test(ua))&#123;</span><br><span class="line">system.ios &#x3D; parseFloat(RegExp.$1.replace(&quot;_&quot;, &quot;.&quot;));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">system.ios &#x3D; 2; &#x2F;&#x2F;不能真正检测出来，所以只能猜测</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;检测Android 版本</span><br><span class="line">if (&#x2F;Android (\d+\.\d+)&#x2F;.test(ua))&#123;</span><br><span class="line">system.android &#x3D; parseFloat(RegExp.$1);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;游戏系统</span><br><span class="line">system.wii &#x3D; ua.indexOf(&quot;Wii&quot;) &gt; -1;</span><br><span class="line">system.ps &#x3D; &#x2F;playstation&#x2F;i.test(ua);</span><br><span class="line">&#x2F;&#x2F;返回这些对象</span><br><span class="line">return &#123;</span><br><span class="line">engine: engine,</span><br><span class="line">browser: browser,</span><br><span class="line">system: system</span><br><span class="line">&#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-12-BOM-2</title>
      <link href="/2019/11/02/Javascript-12-BOM-2/"/>
      <url>/2019/11/02/Javascript-12-BOM-2/</url>
      
        <content type="html"><![CDATA[<h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><p>location对象是最有用的BOM对象之一，它提供了与当前窗口加载的文档有关的信息，还提供了一些导航功能。location对象既是window对象的属性，也是document对象的属性；换句话说，window.location和document.location引用的是同一个对象。location对象的用处不只表现在它保存着当前文档的信息，还表现在它将URL解析为独立的片段，让我们可以通过不同的属性访问这些片段。下表列出了location对象的所有属性(省略了每个属性前面的location前缀)。</p><a id="more"></a><p><img src="https://img-blog.csdn.net/20160923152459667" alt=""></p><h4 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h4><p>虽然可以通过location.search得到从问号到URL末尾的所有内容，但却没办法逐个访问，因此可以像下面这样创建一个函数，用以解析每个字符串，然后返回包含所有参数的一个对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function getQueryStringArgs() &#123;</span><br><span class="line">    &#x2F;&#x2F; 取得查询字符串并去掉开头的问号</span><br><span class="line">    var qs &#x3D; location.search.length&gt;0? location.search.substring(1):&quot;&quot;;</span><br><span class="line">    &#x2F;&#x2F; 保存数据的对象</span><br><span class="line">    var args &#x3D; &#123;&#125;;</span><br><span class="line">    &#x2F;&#x2F; 取得每一项</span><br><span class="line">    var items &#x3D; qs.length?qs.split(&quot;&amp;&quot;):[];</span><br><span class="line">    var item &#x3D; null;</span><br><span class="line">    var name &#x3D; null;</span><br><span class="line">    var value &#x3D; null;</span><br><span class="line"></span><br><span class="line">    for (var i &#x3D; 0; i &lt; items.length; i++) &#123;</span><br><span class="line">        item &#x3D; items[i].split(&quot;&#x3D;&quot;);</span><br><span class="line">        name &#x3D; decodeURIComponent(item[0]);</span><br><span class="line">        value &#x3D; decodeURIComponent(items[1]);</span><br><span class="line"></span><br><span class="line">        if (name.length) &#123;</span><br><span class="line">            args[name] &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h4><ul><li><p>assign()：立即打开新URL并在浏览器的历史记录中生成一条记录</p></li><li><p>replace()：导航到新URL，但不会在历史记录中生成新纪录，即，用户不能返回到前一个页面</p></li><li><p>reload()：重新加载当前显示的页面</p><h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><p>navigator对象包含有关浏览器的信息，是识别客户端浏览器的事实标准。下表列出了存在于所有浏览器中的属性和方法，以及支持它们的浏览器版本。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3N0YXRpYy5vc2NoaW5hLm5ldC91cGxvYWRzL3NwYWNlLzIwMTQvMDgyOC8xODAyMTBfOFRYWF8yMDA0MTcxLmpwZw?x-oss-process=image/format,png" alt=""><br>表中的这些navigator对象的属性通常用于检测显示网页的浏览器类型。</p><h4 id="检测插件"><a href="#检测插件" class="headerlink" title="检测插件"></a>检测插件</h4><p>在非IE浏览器下检测插件(利用navigator.plugins数组进行检测)<br>navigator.plugins数组有如下属性：</p><ul><li>name：插件的名字</li><li>description：插件的描述</li><li>filename：插件的文件名</li><li>length：插件所处理的MIME类型数量<br>一般来说，name属性中会包含检测插件必需的所有信息，但有时候也不完全如此。在检测插件时，需要像下面这样循环迭代每个插件并将插件的name与给定的名字进行比较。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 不支持IE</span><br><span class="line">function hasPlugin(name) &#123;</span><br><span class="line">    name &#x3D; name.toLowerCase();</span><br><span class="line">    var pluginsArray &#x3D; navigator.plugins;</span><br><span class="line">    for (var i &#x3D; 0, pluginLength &#x3D; pluginsArray.length; i &lt; pluginLength; i++) &#123;</span><br><span class="line">        if (pluginsArray[i].name.toLowerCase().indexOf(name) &gt; -1) &#123;</span><br><span class="line">        return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 检测flash</span><br><span class="line">hasPlugin(&quot;Flash&quot;);</span><br><span class="line">&#x2F;&#x2F; 检测QuickTime</span><br><span class="line">hasPlugin(&quot;QuickTime&quot;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>检测IE中的插件比较麻烦，因为IE不支持Natscape式的插件。在IE中检测插件的唯一方式就是使用专有的ActiveXObject类型，并尝试创建一个特定插件的实例。IES是以COM对象的方式实现插件的，而COM对象使用唯一标识符来标识。因此，要想检查特定的插件，就必须知道其COM标识符。例如，Flash的标识符是ShockwaveFlash.ShockwaveFlash。知道唯一标识符后，就可以编写类似下面的函数来检测IE中是否安装相应的插件了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 检测IE中的插件</span><br><span class="line">function hasIEPlugin(name) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        new ActiveXObject(name);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; catch(e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鉴于检测这两种插件的方法差别太大，因此典型的做法是针对每个插件分别创建检测函数，而不是使用前面介绍的通用检测方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 检测所有浏览器中的Flash</span><br><span class="line">function hasFlash() &#123;</span><br><span class="line">    var resultFlag &#x3D; hasPlugin(&quot;Flash&quot;);</span><br><span class="line">    if (!resultFlag) &#123;</span><br><span class="line">        resultFlag &#x3D; hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return resultFlag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>navigator.plugins.refresh（）：用于刷新最新安装插件plugins的集合<br>navigator.plugins.refresh（true）:更新插件集合，以及重新加载包含插件集合的所有页面。</p><h3 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h3><p>screen对象基本上只用来标明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。下表列出了所有属性及支持相应属性的浏览器。</p><table><thead><tr><th>属 性</th><th>说 明</th><th>IE</th><th>Firefox</th><th>Safari/Chrome</th><th>Opera</th></tr></thead><tbody><tr><td>availHeight</td><td>屏幕的像素高度减系统部件高度之后的值（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>availLeft</td><td>未被系统部件占用的最左侧的像素值（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>availTop</td><td>未被系统部件占用的最上方的像素值（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>availWidth</td><td>屏幕的像素宽度减系统部件宽度之后的值（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>bufferDepth</td><td>读、写用于呈现屏外位图的位数</td><td></td><td></td><td></td><td></td></tr><tr><td>colorDepth</td><td>用于表现颜色的位数；多数系统都是32（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>deviceXDPI</td><td>屏幕实际的水平DPI（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>deviceYDPI</td><td>屏幕实际的垂直DPI（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>fontSmoothingEnabled</td><td>表示是否启用了字体平滑（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>height</td><td>屏幕的像素高度</td><td></td><td></td><td></td><td></td></tr><tr><td>left</td><td>当前屏幕距左边的像素距离</td><td></td><td></td><td></td><td></td></tr><tr><td>logicalXDPI</td><td>屏幕逻辑的水平DPI（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>logicalYDPI</td><td>屏幕逻辑的垂直DPI（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>pixelDepth</td><td>屏幕的位深（只读）</td><td></td><td></td><td></td><td></td></tr><tr><td>top</td><td>当前屏幕距上边的像素距离</td><td></td><td></td><td></td><td></td></tr><tr><td>updateInterval</td><td>读、写以毫秒表示的屏幕刷新时间间隔</td><td></td><td></td><td></td><td></td></tr><tr><td>width</td><td>屏幕的像素宽度</td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="hostory对象"><a href="#hostory对象" class="headerlink" title="hostory对象"></a>hostory对象</h3><p>history对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。由于安全方面的考虑，开发人员无法得到用户浏览器的URL，但借由用户访问过的页面列表，可以在不知道实际URL的情况下实现后退和前进。</p><p>使用go()方法可以在用户的历史记录中任意跳转。这个方法接收一个参数，表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转(类似于后退按钮)，正数表示向前跳转(类似于前进按钮)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;后退一页</span><br><span class="line">history.go(-1)</span><br><span class="line">&#x2F;&#x2F;前进一页</span><br><span class="line">history.go(1);</span><br><span class="line">&#x2F;&#x2F;前进两页</span><br><span class="line">history.go(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;刷新当前页面</span><br><span class="line">history.go();</span><br><span class="line">&#x2F;&#x2F;刷新当前页面</span><br><span class="line">history.go(0);</span><br></pre></td></tr></table></figure><p>back()方法用于模仿浏览器的后退按钮，相当于history.go(-1)。</p><p>forward()方法用于模仿浏览器的前进按钮，相当于history.go(1)。</p><p>history.length属性保存着历史记录的URL数量。初始时，该值为1。如果当前窗口先后访问了三个网址，history.length属性等于3。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-12-BOM-1</title>
      <link href="/2019/10/25/Javascript-12-BOM-1/"/>
      <url>/2019/10/25/Javascript-12-BOM-1/</url>
      
        <content type="html"><![CDATA[<h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><p>BOM的核心对象是window，他表示浏览器的一个实例。在浏览器中，window对象有双重角色，它既是通过Jacascript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。这意味着在网页中定义的任何一个对象、变量和函数，都以window作为其Global对象，因此有权访问parseInt()等方法。</p><a id="more"></a><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>由于window对象同时扮演者ECMAScript中Global对象的角色，因此所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法。抛开全局变量会成为window对象的属性不谈，定义全局变量与在window对象上直接定义属性还是有一点差别：全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性可以。</p><p>尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的变量是否存在。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里会抛出错误，因为oldValue未定义</span><br><span class="line">var newValue &#x3D; oldValue;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里不会抛出错误，因为这是一次属性查询</span><br><span class="line">&#x2F;&#x2F; newValue的值是undefined</span><br><span class="line">var newValue &#x3D; window.oldValue;</span><br></pre></td></tr></table></figure><h4 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h4><p>如果页面中包含框架，则每个框架都拥有自己饿winodw对象，并且保存在frames集合中。在frames集合中，可以通过数值索引(从0开始，从左至右，从上到下)或者框架名称来访问相应的window对象。每个window对象都有一个name属性，其中包含框架的名称。</p><p>top对象始终指向最高(最外)层的框架，也就是浏览器窗口。使用它可以确保在一个框架中正确地访问另一个框架。因为对于在一个框架中编写的任何代码来说，其中的window对象指向的都是那个框架的特定实例，而非最高层的框架。</p><p>与top相对的另一个window对象是parent。顾名思义，parent(父)对象始终指向当前框架的直接上层框架。在某些情况下，parent有可能等于top；但在没有框架的情况下，parent一定等于top(此时它们都等于window)。</p><p>与框架有关的最后一个对象是self，它始终指向window；实际上，self和window对象可以互换使用。引入self对象的目的只是为了与top和parent对象对应起来，因此它不格外包含其他值。</p><p>所有这些对象都是window对象的属性，可以通过window.parent、window.top等形式来访问。同时，这也意味着可以将不同层次的window对象连缀起来，例如<code>window.parent.parent.frames[0]</code>.</p><h4 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h4><p>用来确定和修改window 对象位置的属性和方法有很多。IE、Safari、Opera 和Chrome 都提供了<br>screenLeft 和screenTop 属性，分别用于表示窗口相对于屏幕左边和上边的位置。Firefox 则在<br>screenX 和screenY 属性中提供相同的窗口位置信息，Safari 和Chrome 也同时支持这两个属性。Opera<br>虽然也支持screenX 和screenY 属性，但与screenLeft 和screenTop 属性并不对应，因此建议大<br>家不要在Opera 中使用它们。使用下列代码可以跨浏览器取得窗口左边和上边的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var leftPos &#x3D; (typeof window.screenLeft &#x3D;&#x3D; &quot;number&quot;) ?</span><br><span class="line">window.screenLeft : window.screenX;</span><br><span class="line">var topPos &#x3D; (typeof window.screenTop &#x3D;&#x3D; &quot;number&quot;) ?</span><br><span class="line">window.screenTop : window.screenY;</span><br></pre></td></tr></table></figure><p>这个例子运用二元操作符首先确定screenLeft 和screenTop 属性是否存在，如果是（在IE、<br>Safari、Opera 和Chrome 中），则取得这两个属性的值。如果不存在（在Firefox 中），则取得screenX<br>和screenY 的值。<br>在使用这些值的过程中，还必须注意一些小问题。在IE、Opera 中，screenLeft 和screenTop 中保存<br>的是从屏幕左边和上边到由window 对象表示的页面可见区域的距离。换句话说，如果window 对象是<br>最外层对象，而且浏览器窗口紧贴屏幕最上端——即y 轴坐标为0，那么screenTop 的值就是位于页面<br>可见区域上方的浏览器工具栏的像素高度。但是，在Chrome、Firefox 和Safari 中，screenY 或screenTop<br>中保存的是整个浏览器窗口相对于屏幕的坐标值，即在窗口的y 轴坐标为0 时返回0。<br>更让人捉摸不透是，Firefox、Safari 和Chrome 始终返回页面中每个框架的top.screenX 和<br>top.screenY 值。即使在页面由于被设置了外边距而发生偏移的情况下，相对于window 对象使用<br>screenX 和screenY 每次也都会返回相同的值。而IE 和Opera 则会给出框架相对于屏幕边界的精确坐<br>标值。<br>最终结果，就是无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值。然而，使用moveTo()<br>和moveBy()方法倒是有可能将窗口精确地移动到一个新位置。这两个方法都接收两个参数，其中<br>moveTo()接收的是新位置的x 和y 坐标值，而moveBy()接收的是在水平和垂直方向上移动的像素数。<br>下面来看几个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;将窗口移动到屏幕左上角</span><br><span class="line">window.moveTo(0,0);</span><br><span class="line">&#x2F;&#x2F;将窗向下移动100 像素</span><br><span class="line">window.moveBy(0,100);</span><br><span class="line">&#x2F;&#x2F;将窗口移动到(200,300)</span><br><span class="line">window.moveTo(200,300);</span><br><span class="line">&#x2F;&#x2F;将窗口向左移动50 像素</span><br></pre></td></tr></table></figure><p>需要注意的是，这两个方法可能会被浏览器禁用；而且，在Opera 和IE 7（及更高版本）中默认就<br>是禁用的。另外，这两个方法都不适用于框架，只能对最外层的window 对象使用。</p><h4 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h4><p>跨浏览器确定一个窗口的大小不是一件简单的事。IE9+、Firefox、Safari、Opera 和 Chrome 均为此提供了4个属性： innerWidth 、 innerHeight  、 outerWidth 和  outerHeight  。</p><p>在 IE9+、Safari 和 Firefox 中，  outerWidth  和  outerHeight  返回浏览器窗口本身的尺寸（无论是从最外层的  window  对象还是从某个框架访问）。</p><p>在 Opera 中，这两个属性的值表示页面视图容器 的大小。而  innerWidth  和  innerHeight  则表示该容器中页面视图区的大小（减去边框宽度）。</p><p>在 Chrome 中， outerWidth 、 outerHeight  与  innerWidth 、  innerHeight  返回相同的值，即视口（viewport）大小而非浏览器窗口大小。</p><p>这里所谓的“页面视图容器”指的是 Opera 中单个标签页对应的浏览器窗口。IE8 及更早版本没有提供取得当前浏览器窗口尺寸的属性；不过，它通过 DOM 提供了页面可见区域的相关信息。</p><p>在 IE、Firefox、Safari、Opera 和 Chrome 中，  document.documentElement.clientWidth  和  document.documentElement.clientHeight  中保存了页面视口的信息。在 IE6 中，这些属性必须在标准模式下才有效；如果是混杂模式，就必须通过</p><p> document.body.clientWidth  和  document.body.  clientHeight  取得相同信息。而对于混杂模式下的Chrome，则无论通过 document.documentElement  还是  document.body  中的  clientWidth  和  clientHeight 属性，都可以取得视口的大小。</p><p>虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var pageWidth &#x3D; window.innerWidth,</span><br><span class="line"></span><br><span class="line">pageHeight &#x3D; window.innerHeight;</span><br><span class="line"></span><br><span class="line">if (typeof pageWidth !&#x3D; “number”)&#123;</span><br><span class="line"></span><br><span class="line">    if (document.compatMode &#x3D;&#x3D; “CSS1Compat”)&#123;</span><br><span class="line"></span><br><span class="line">    pageWidth &#x3D; document.documentElement.clientWidth;</span><br><span class="line"></span><br><span class="line">    pageHeight &#x3D; document.documentElement.clientHeight;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">    pageWidth &#x3D; document.body.clientWidth;</span><br><span class="line"></span><br><span class="line">    pageHeight &#x3D; document.body.clientHeight;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们首先将  window.innerWidth  和 window.innerHeight  的值分别赋给了  pageWidth  和 pageHeight  。然后检查  pageWidth  中保存的是不是一个数值；如果不是，则通过检查 document.compatMode （这个属性在《 HTML5扩展了HTMLDocument，增加了新的功能 》里面已经说明）来确定页面是否处于标准模式。如果是，则分别使用  document.documentElement.clientWidth  和 document.documentElement.clientHeight  的值。否则，就使用  document.body.clientWidth  和 document.body.clientHeight  的值。</p><p>对于移动设备，window.innerWidth  和 window.innerHeight  保存着可见视口，也就是屏幕上可见页面区域的大小。移动IE浏览器不支持这些属性，但通过document.documentElement.clientWidth  和 document.documentElement.clientHeihgt 提供了相同的信息。随着页面的缩放，这些值也会相应变化。</p><p>在其他移动浏览器中， document.documentElement 度量的是布局视口，即渲染后页面的实际大小（与可见视口不同，可见视口只是整个页面中的一小部分）。移动IE浏览器把布局视口的信息保存在 document.body.clientWidth和document.body.clientHeight  中。这些值不会随着页面缩放变化。</p><p>由于与桌面浏览器间存在这些差异，最好是先检测一下用户是否在使用移动设备，然后再决定使用哪个属性。</p><h4 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h4><p>使用 window.open() 方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。这个方法可以接收4个参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。</p><p>如果为 window.open() 传递了第二个参数，而且该参数是已有窗口或框架的名称，那么就会在具有该名称的窗口或框架中加载第一个参数指定的URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 等同于&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.domain.com&quot; target&#x3D;&quot;topFrame&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">window.open(&#39;https:&#x2F;&#x2F;www.domain.com&#x2F;&#39;, &#39;topFrame&#39;)</span><br></pre></td></tr></table></figure><h5 id="弹出窗口"><a href="#弹出窗口" class="headerlink" title="弹出窗口"></a>弹出窗口</h5><p>如果给window.open()传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根据在第三个参数位置上传入的字符串创建一个新窗口或新标签页。如果没有传入第三个参数，那么就会打开一个带有全部默认设置（工具栏、地址栏和状态栏等）的新浏览器窗口（或者打开一个新标签页——根据浏览器设置）。在不打开新窗口的情况下，会忽略第三个参数。</p><p>第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性。下表列出了可以出现在这个字符串中的设置选项。<br><img src="https://img-blog.csdn.net/20151013100024530?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><p>表中所列的部分或全部设置选项，都可以通过逗号分隔的名值对列表来指定。其中，名值对以等号表示（注意，整个特性字符串中不允许出现空格），如下面的例子所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.open(&quot;http:&#x2F;&#x2F;www.wrox.com&#x2F;&quot;,&quot;wroxWindow&quot;,</span><br><span class="line">&quot;height&#x3D;400,width&#x3D;400,top&#x3D;10,left&#x3D;10,resizable&#x3D;yes&quot;);</span><br></pre></td></tr></table></figure><p>window.open()方法会返回一个指向新窗口的引用。引用的对象与其他window 对象大致相似，但我们可以对其进行更多控制。例如，有些浏览器在默认情况下可能不允许我们针对主浏览器窗口调整大小或移动位置，但却允许我们针对通过window.open()创建的窗口调整大小或移动位置。通过这个返回的对象，可以像操作其他窗口一样操作新打开的窗口，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var wroxWin &#x3D; window.open(&quot;http:&#x2F;&#x2F;www.wrox.com&#x2F;&quot;,&quot;wroxWindow&quot;,</span><br><span class="line">&quot;height&#x3D;400,width&#x3D;400,top&#x3D;10,left&#x3D;10,resizable&#x3D;yes&quot;);</span><br><span class="line">&#x2F;&#x2F;调整大小</span><br><span class="line">wroxWin.resizeTo(500,500);</span><br><span class="line">&#x2F;&#x2F;移动位置</span><br><span class="line">wroxWin.moveTo(100,100);</span><br><span class="line">调用close()方法还可以关闭新打开的窗口。</span><br><span class="line">wroxWin.close();</span><br><span class="line">&#x2F;&#x2F; 这个方法仅适用于通过window.open()打开的弹出窗口</span><br></pre></td></tr></table></figure><p>新创建的window 对象有一个opener 属性，其中保存着打开它的原始窗口对象。这个属性只在弹出窗口中的最外层window 对象（top）中有定义，而且指向调用window.open()的窗口或框架。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var wroxWin &#x3D; window.open(&quot;http:&#x2F;&#x2F;www.wrox.com&#x2F;&quot;,&quot;wroxWindow&quot;,</span><br><span class="line">&quot;height&#x3D;400,width&#x3D;400,top&#x3D;10,left&#x3D;10,resizable&#x3D;yes&quot;);</span><br><span class="line">alert(wroxWin.opener &#x3D;&#x3D; window); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><p>虽然弹出窗口中有一个指针指向打开它的原始窗口，但原始窗口中并没有这样的指针指向弹出窗口。窗口并不跟踪记录它们打开的弹出窗口，因此我们只能在必要的时候自己来手动实现跟踪。有些浏览器（如IE8 和Chrome）会在独立的进程中运行每个标签页。当一个标签页打开另一个标签页时，如果两个window 对象之间需要彼此通信，那么新标签页就不能运行在独立的进程中。在Chrome中，将新创建的标签页的opener 属性设置为null，即表示在单独的进程中运行新标签页，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var wroxWin &#x3D; window.open(&quot;http:&#x2F;&#x2F;www.wrox.com&#x2F;&quot;,&quot;wroxWindow&quot;,</span><br><span class="line">&quot;height&#x3D;400,width&#x3D;400,top&#x3D;10,left&#x3D;10,resizable&#x3D;yes&quot;);</span><br><span class="line">wroxWin.opener &#x3D; null</span><br></pre></td></tr></table></figure><p>将opener 属性设置为null 就是告诉浏览器新创建的标签页不需要与打开它的标签页通信，因此可以在独立的进程中运行。标签页之间的联系一旦切断，将没有办法恢复。</p><h5 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h5><p>Windows XP SP2 中的IE6 对弹出窗口施加了多方面的安全限制，包括不允许在屏幕之外创建弹出窗口、不允许将弹出窗口移动到屏幕以外、不允许关闭状态栏等。IE7 则增加了更多的安全限制，如不允许关闭地址栏、默认情况下不允许移动弹出窗口或调整其大小。Firefox 1 从一开始就不支持修改状态栏，<br>因此无论给window.open()传入什么样的特性字符串，弹出窗口中都会无一例外地显示状态栏。后来的Firefox 3 又强制始终在弹出窗口中显示地址栏。Opera 只会在主浏览器窗口中打开弹出窗口，但不允许它们出现在可能与系统对话框混淆的地方。<br>此外，有的浏览器只根据用户操作来创建弹出窗口。这样一来，在页面尚未加载完成时调用window.open()的语句根本不会执行，而且还可能会将错误消息显示给用户。换句话说，只能通过单击或者击键来打开弹出窗口。对于那些不是用户有意打开的弹出窗口，Chrome 采取了不同的处理方式。它不会像其他浏览器那样简单地屏蔽这些弹出窗口，而是只显示它们的标题栏，并把它们放在浏览器窗口的右下角。</p><h5 id="弹出窗口屏蔽程序"><a href="#弹出窗口屏蔽程序" class="headerlink" title="弹出窗口屏蔽程序"></a>弹出窗口屏蔽程序</h5><p>大多数浏览器都内置有弹出窗口屏蔽程序，而没有内置此类程序的浏览器，也可以安装Yahoo!Toolbar 等带有内置屏蔽程序的实用工具。结果就是用户可以将绝大多数不想看到弹出窗口屏蔽掉。于是，在弹出窗口被屏蔽时，就应该考虑两种可能性。如果是浏览器内置的屏蔽程序阻止的弹出窗口，那么window.open()很可能会返回null。此时，只要检测这个返回的值就可以确定弹出窗口是否被屏蔽了，如下面的例子所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var wroxWin &#x3D; window.open(&quot;http:&#x2F;&#x2F;www.wrox.com&quot;, &quot;_blank&quot;);</span><br><span class="line">if (wroxWin &#x3D;&#x3D; null)&#123;</span><br><span class="line">alert(&quot;The popup was blocked!&quot;);</span><br></pre></td></tr></table></figure><p>如果是浏览器扩展或其他程序阻止的弹出窗口，那么window.open()通常会抛出一个错误。因此，要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对window.open()的调用封装在一个try-catch 块中，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var blocked &#x3D; false;</span><br><span class="line">try &#123;</span><br><span class="line">var wroxWin &#x3D; window.open(&quot;http:&#x2F;&#x2F;www.wrox.com&quot;, &quot;_blank&quot;);</span><br><span class="line">if (wroxWin &#x3D;&#x3D; null)&#123;</span><br><span class="line">blocked &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (ex)&#123;</span><br><span class="line">blocked &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">if (blocked)&#123;</span><br><span class="line">alert(&quot;The popup was blocked!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在任何情况下，以上代码都可以检测出调用window.open()打开的弹出窗口是不是被屏蔽了。但要注意的是，检测弹出窗口是否被屏蔽只是一方面，它并不会阻止浏览器显示被屏蔽的弹出窗口有关的消息。</p><h4 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h4><p>Javascript是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。前者是在指定的时间过后执行代码，而后者则是每隔指定的时间就执行一次代码。</p><p>超时调用需要使用window对象的setTimeout()方法，它接受两个参数：要执行的代码和以毫秒表示的时间(即在执行代码前需要等待多少毫秒)。其中，第一个参数可以是一个包含JS代码的字符串(就和在eval()函数中使用的字符串一样)，也可以是一个函数。虽然这两种调用方式都没有问题，但由于传递字符串可能导致性能损失，因此，不建议以字符串作为第一个参数。</p><p>第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定会执行。JS是一个单线程的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JS任务队列。这些任务会按照将他们添加到队列的顺序执行。setTimeout()的第二个参数告诉JS再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它要等前面的代码执行完了以后再执行。</p><p>调用setTimeout()之后，该方法会返回一个数值ID，表示超时调用。该ID是计划执行代码的唯一标识符，可以通过它来取消超时调用，可以调用clearTimeout()方法并将相应的超时调用ID作为参数传递给它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var timeoutId &#x3D; setTimeout(function() &#123;</span><br><span class="line">    alert(&#39;Hello world&#39;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">clearTimeout(timeoutId);</span><br></pre></td></tr></table></figure><p>超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象，在严格模式下是undefined。</p><p>间歇调用和超时调用类似，只不过它会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。设置间歇调用的方法是setInterval()，它接受的参数与setTimeout()相同；要执行的代码(字符串或函数)和每次执行之前需要等待的毫秒数。</p><p>要取消尚未执行的间歇调用，可以使用clearInterval()方法并传入相应的间歇调用ID。<br>取消间歇调用的重要性远远高于取消超时调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 0;</span><br><span class="line">var max &#x3D; 10;</span><br><span class="line">var intervalId &#x3D; null</span><br><span class="line"></span><br><span class="line">function incrementNumber() &#123;</span><br><span class="line">    num++;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果执行次数达到max设定的值，则取消后续尚未执行的调用</span><br><span class="line">    if(max &#x3D;&#x3D;&#x3D; num) &#123;</span><br><span class="line">        clearInterval(intercalId);</span><br><span class="line">        alert(&quot;Down&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var intercalId &#x3D; setInterval(incrementNumber, 1000);</span><br></pre></td></tr></table></figure><p>也可以使用超时调用来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 0;</span><br><span class="line">var max &#x3D; 10;</span><br><span class="line"></span><br><span class="line">function incrementNumber() &#123;</span><br><span class="line">    num++;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    if (num &lt; max) &#123;</span><br><span class="line">        setTimeout(incrementNumber, 1000);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        alert(&quot;Done&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(incrementNumber, 1000);</span><br></pre></td></tr></table></figure><p>可见，在使用超时调用时，没有必要跟踪超时调用ID，因此每次执行代码之后，如果不设置另一个超时调用，调用就会自行停止。一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境中，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。所以最好不要使用间歇调用。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全问题和解决方案</title>
      <link href="/2019/10/21/Web%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2019/10/21/Web%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>目前常见的web安全问题有以下几种：</p><ul><li>同源策略</li><li>XSS</li><li>CSRF</li><li>SQL注入</li><li>点击劫持</li><li>window.opener安全问题</li><li>文件上传漏洞<a id="more"></a><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4></li></ul><p>如果两个URL的协议、域名、端口都相同，我们称之为同源。</p><ul><li>同源策略限制了来自不同源的JS脚本对当前DOM对象的读写操作。</li><li>同源策略限制了来自不同源的站点读取当前站点的Cookie、LocalStorage等操作。</li><li>同源策略限制了通过XMLHttpRequest等方式将站点的数据发送给不同源的站点。</li></ul><p>对应的解决方法：</p><ul><li>跨域资源共享(CORS)：服务端设置跨域资源允许跨域。</li><li>内容安全策略(CSP)：用白名单的形式配置可信任的内容来源。</li><li>跨文档消息机制：window.postMessage可以和不同源的DOM进行通信。</li></ul><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><p>跨站脚本攻击(Cross Site Scripting)</p><p>1，存储型XSS攻击</p><p>存储型XSS，利用漏洞提交恶意JS代码，比如在可以输入的区域输入恶意script标签提交给服务器，当用户打开网站时恶意脚本会执行获取用户相关信息。</p><p>2，反射型XSS攻击</p><p>反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。常用手段例如通过邮件、群等渠道诱导点击。</p><p>3，基于DOM的XSS攻击</p><p>基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。</p><p>4，预防策略</p><ul><li>将cookie等敏感信息设置为httponly，浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。</li><li>输入检查，不要相信用户的任何输入。对于所有的输入做严格的校验。</li><li>输出检查，用户的输入会存在问题，服务端的输出也会有问题。</li><li>对于特殊字符进行转义或者过滤</li><li>CSP(Content Security Policy)，内容安全策略。用白名单的形式配置可信的内容来源。</li></ul><p>CSP配置方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; meta</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;Content-Security-Policy&quot; content&#x3D;&quot;script-src &#39;self&#39;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; HTTP头部</span><br><span class="line">Content-Security-Policy: script-src &#39;unsafe-inline&#39; &#39;unsafe-eval&#39; &#39;self&#39; *.domain.cn *.domain.com;report-uri &#x2F;error&#x2F;csp</span><br></pre></td></tr></table></figure><h4 id="CSRF-Cross-site-request-forgery"><a href="#CSRF-Cross-site-request-forgery" class="headerlink" title="CSRF(Cross-site request forgery)"></a>CSRF(Cross-site request forgery)</h4><p>中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。<br>通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p><p>预防策略：</p><ul><li>验证码，验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。但不能作为最主要的解决方案。</li><li>Referer Check。根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的”源”。</li><li>添加token验证。CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。因此要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</li><li>SameSite。Cookie的SameSite属性有Strict、Lax、None三个值。Sreict-浏览器会完全禁止第三方Cookie。LaxLax-相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。None-在任何情况下都会发送 Cookie 数据。</li></ul><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><h5 id="注入方式"><a href="#注入方式" class="headerlink" title="注入方式"></a>注入方式</h5><p>SQL注入的攻击方式根据应用程序处理数据库返回内容的不同，可以分为可显注入、报错注入和盲注：</p><p>1、可显注入：攻击者可以直接在当前界面内容中获取想要获得的内容</p><p>2、报错注入：数据库查询返回结果并没有在页面中显示，但是应用程序将数据库报错信息打印到了页面中，所以攻击者可以构造数据库报错语句，从报错信息中获取想要获得的内容</p><p>3、盲注：数据库查询结果无法从直观页面中获取，攻击者通过使用数据库逻辑或使数据库库执行延时等方法获取想要获得的内容</p><p>预防策略：</p><ul><li>减少不必要的数据库错误信息</li><li>禁止目标网站用动态拼接字符串的方式访问数据库</li><li>数据库权限</li><li>过滤和净化SQL保留字</li></ul><h4 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h4><p>顾名思义，用户点击某个按钮，却触发了不是用户真正意愿的事件。</p><p>预防策略：</p><p>1，JS禁止内嵌<br>在目标网站页面添加如下代码，也可以用top.location.hostname和self.location.hostname进行判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">script&gt;</span><br><span class="line">    if (top.location !&#x3D; window.location) &#123;</span><br><span class="line">        top.location &#x3D; window.location;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>2，服务端添加 X-Frame-Options 响应头,这个响应头是用来给浏览器指示允许一个页面可否在 <code>&lt;frame&gt;</code> 或者 <code>&lt;object&gt;</code> 中展现的标记</p><p>3，点击劫持只需要用户简单的点击按钮就触发事件，我们可以增加用户的操作成本，从而让用户有所警觉。如：设置验证码等。</p><h4 id="window-opener安全"><a href="#window-opener安全" class="headerlink" title="window.opener安全"></a>window.opener安全</h4><p>window.opener 表示打开当前窗体页面的的父窗体的是谁，被用来跳转钓鱼网站。</p><p>预防策略：<br>1，设置标签rel属性noopener规定禁止新页面传递源页面的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;domain.com&quot; rel&#x3D;&quot;noopener noreferrer&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><p>2，将外链替换为内部的跳转连接服务，跳转时先跳到内部地址，再由服务器 redirect 到外链。<br>3，可以由 widow.open 打开外链。</p><h4 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h4><p>没有对上传的任何文件做过滤安全校验.可直接上传webshell到服务器.或者仅对文件类型进行了校验,可以通过代理的方式来修改文件类型的方式来绕过这个检测。</p><p>预防策略：</p><ul><li>文件扩展名服务端校验.</li><li>文件内容服务端校验.</li><li>上传文件重命名.</li><li>上传文件路径隐藏.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-11-函数表达式-2</title>
      <link href="/2019/10/16/Javascript-11-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F-2/"/>
      <url>/2019/10/16/Javascript-11-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F-2/</url>
      
        <content type="html"><![CDATA[<h3 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h3><p>JS中没有块级作用域的概念。这意味着在块语句中定义的变量，实际上是包含函数中而非语句中创建的，例如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function outputNumbers(count) &#123;</span><br><span class="line">    for(var i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        alert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    alert(i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>JS从来不会告诉你是否多次声明了同一个变量；遇到这种情况，他只会对后续的声明视而不见(不过，他会执行后续声明中的变量初始化)。匿名函数可以用来模仿块级作用域并避免这个问题。用作块级作用域(私有作用域)的匿名函数的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 这里是块级作用域</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。这种做法可以减少闭包占用的内存问题。</p><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>严格来讲，JS中没有私有成员的概念；所有对象属性都是公有的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包含函数的参数、局部变量和在函数内部定义的其他函数。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function add(num1, num2) &#123;</span><br><span class="line">    var sum &#x3D; num1 + num2;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把有权访问私有变量和私有函数的公有方法称为特权方法。有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法，基本模式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function MyObject() &#123;</span><br><span class="line">    &#x2F;&#x2F; 私有变量和私有函数</span><br><span class="line">    var privateVariable &#x3D; 10;</span><br><span class="line"></span><br><span class="line">    function privateFunction() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 特权方法</span><br><span class="line">    this.publicMethod &#x3D; function() &#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        return privateFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个模式在构造函数内部定义了所有私有变量和函数。然后，又继续创建了能够访问这些私有成员的特权方法。能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。</p><h4 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h4><p>通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法，其基本模式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 私有变量和私有函数</span><br><span class="line">    var privateVariable &#x3D; 10;</span><br><span class="line"></span><br><span class="line">    function privateFunction() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构造函数</span><br><span class="line">    MyObject &#x3D; function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 公有&#x2F;特权方法</span><br><span class="line">    MyObject.prototype.publicMethod &#x3D; function() &#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        return privateFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。在私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数及其公有方法。公有方法是在原型上定义的，这一点体现了典型的原型模式。</p><p>这个模式与在构造函数中定义特权方法的主要区别，就在于私有变量和函数由实例共享的。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存在对包含作用域的引用。</p><h4 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h4><p>模块模式是为单例创建私有变量和特权方法。所谓单例(singleton)，指的就是只有一个实例的对象。按照惯例，JS是以对象字面量的方法来创建单例对象的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var singleton &#x3D; &#123;</span><br><span class="line">    name: value,</span><br><span class="line">    method: function() &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里是方法的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模块模式通过为单例添加私有变量和特权方法能够使其得到增强，其语法形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var singleton &#x3D; function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 私有变量和私有函数</span><br><span class="line">    var privateVariable &#x3D; 10;</span><br><span class="line"></span><br><span class="line">    function privateFunction() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 特权&#x2F;公有方法和属性</span><br><span class="line">    return &#123;</span><br><span class="line">        publicProperty: true,</span><br><span class="line">        publicMethod: function() &#123;</span><br><span class="line">            privateVariable++;</span><br><span class="line">            return privateFunction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>z这个模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，首先定义了私有变量和函数。然后，将一个对象字面量作为函数的值返回。返回的对象字面量中只包含可以公开的属性和方法。由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时有需要维护其私有变量时是非常有用的。</p><p>如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是Object的实例，因为最终要通过一个对象字面量来表示它。</p><h4 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h4><p>增强的模块模式，即在返回对象之前加入对其增强的代码。这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和方法对其加以增强的情况。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-11-函数表达式-1</title>
      <link href="/2019/10/14/Javascript-11-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F-1/"/>
      <url>/2019/10/14/Javascript-11-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F-1/</url>
      
        <content type="html"><![CDATA[<p>函数表达式是JS中一种既强大又容易令人困惑的特性。定义函数的方式有两种：一种是函数声明，另一种就是函数表达式。函数声明的语法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function functionName(arg0, arg1, arg2) &#123;</span><br><span class="line">    &#x2F;&#x2F; 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数声明的一个重要特征就是函数声明提升，意思是在执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHi();</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">    alert(&#39;Hi!&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>函数表达式有几种不同的语法形式。最常见的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var functionName &#x3D; function(arg0, arg1, arg2) &#123;</span><br><span class="line">    &#x2F;&#x2F; 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种形式看起来好像是常规的变量赋值语句，即创建一个函数并将它赋值给变量functionName。这种情况下创建的函数叫做匿名函数，因为function关键字后面没有标识符(匿名函数有时也叫拉姆达函数)。匿名函数的name属性是字符串。</p><p>函数表达式与其他表达式一样，在使用前必须先赋值。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归函数是在一个函数通过名字调用自身的情况下构成的，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num) &#123;</span><br><span class="line">    if (num &lt;&#x3D; 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num * factorial(num - 1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var anotherFactorial &#x3D; factorial;</span><br><span class="line">factorial &#x3D; null;</span><br><span class="line">alert(anotherFactorial(4)); &#x2F;&#x2F; 出错</span><br></pre></td></tr></table></figure><p>在这种情况下，使用arguments.callee可以解决这个问题。arguments.callee是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num) &#123;</span><br><span class="line">    if (num &lt;&#x3D; 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num *  arguments.callee(num - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，在编写递归函数时，使用arguments.callee总比使用函数名更保险。</p><p>但在严格模式下，不能通过脚本访问arguments.callee，访问这个属性会导致错误。不过，可以使用命名函数表达式来达成相同的结果。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var factorial &#x3D; (functon f(num) &#123;</span><br><span class="line">    if (num &lt;&#x3D; 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num * f(num - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这种方式在严格模式和非严格模式喜爱都行得通。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createComparisonFunction(propertyName) &#123;</span><br><span class="line">    return function(object1, object2) &#123;</span><br><span class="line">        var value1 &#x3D; object1[propertyName];</span><br><span class="line">        var value2 &#x3D; object2[propertyName];</span><br><span class="line"></span><br><span class="line">        if (value1 &lt; value2) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else if(value1 &gt; value2) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当某个函数被调用时，会创建一个执行环境及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，…直至作为作用域链终点的全局执行环境。</p><p>作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。</p><p>在另一个函数内部定义的函数会将包含函数(即外部函数)的活动对象添加到它的作用域中。</p><h4 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h4><p>闭包只能取得包含函数中任何变量的最后一个值。闭包所保存的是整个变量对象，而不是某个特殊的变量。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function createFunctions() &#123;</span><br><span class="line">    var result &#x3D; new Array();</span><br><span class="line"></span><br><span class="line">    for(var i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        result[i] &#x3D; function() &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 实际上每个函数都返回10，我们可以通过创建另一个匿名函数强制让闭包的行为符合预期</span><br><span class="line"></span><br><span class="line">function createFunctions1()&#123;</span><br><span class="line">    var result &#x3D; new Array();</span><br><span class="line"></span><br><span class="line">    for(var i &#x3D; 0; i &lt; 10; i++)&#123;</span><br><span class="line">        result[i] &#x3D; function(num) &#123;</span><br><span class="line">            return function() &#123;</span><br><span class="line">                return num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于this对象"><a href="#关于this对象" class="headerlink" title="关于this对象"></a>关于this对象</h4><p>this对象是在运行时基于函数的执行环境绑定的；在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。不过，匿名函数的执行环境具有全局性，因此其this通常指向window。当然在通过call()和apply()改变函数执行环境的情况下，this就会指向其他对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &#39;The Window&#39;;</span><br><span class="line"></span><br><span class="line">var object &#x3D; &#123;</span><br><span class="line">    name: &#39;My Object&#39;,</span><br><span class="line"></span><br><span class="line">    getNameFunc: function() &#123;</span><br><span class="line">        return function() &#123;</span><br><span class="line">            return this.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(object.getNameFunc()()); &#x2F;&#x2F; &#39;The Window&#39;(在非严格模式下)</span><br></pre></td></tr></table></figure><p>前面提到过，每个函数在被调用时都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。不过，把外部作用域中的this对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &#39;The Window&#39;;</span><br><span class="line"></span><br><span class="line">var object &#x3D; &#123;</span><br><span class="line">    name: &#39;My Object&#39;,</span><br><span class="line"></span><br><span class="line">    getNameFunc: function() &#123;</span><br><span class="line">        var that &#x3D; this;</span><br><span class="line">        return function() &#123;</span><br><span class="line">            return that.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(object.getNameFunc()()); &#x2F;&#x2F; &#39;My Object&#39;</span><br></pre></td></tr></table></figure><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function assignhandler() &#123;</span><br><span class="line">    var element &#x3D; document.getElementById(&#39;someElement&#39;);</span><br><span class="line">    elment.onclick &#x3D; function() &#123;</span><br><span class="line">        alert(element.id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环引用导致element所占用的内存永远不会被回收。</p><p>闭包会引用包含函数的整个活动对象，而其中包含着element。即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个引用。因此，有必要把element变量设置为null。这样就能够解除对DOM对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo next 日常问题解决方案</title>
      <link href="/2019/10/07/hexo-next-%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2019/10/07/hexo-next-%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="分页显示问题"><a href="#分页显示问题" class="headerlink" title="分页显示问题"></a>分页显示问题</h3><p><img src="https://img-blog.csdnimg.cn/20191201150136673.png" alt="分页图片"></p><a id="more"></a><p>修改：/博客文件夹/themes/next/layout/_partials/pagination.swig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;%- if page.prev or page.next %&#125;</span><br><span class="line"> &lt;nav class&#x3D;&quot;pagination&quot;&gt;</span><br><span class="line">   &#123;&#123;</span><br><span class="line">     paginator(&#123;</span><br><span class="line">       prev_text: &#39;&lt;i class&#x3D;&quot;fa fa-angle-left&quot; aria-label&#x3D;&quot;&#39;+__(&#39;accessibility.prev_page&#39;)+&#39;&quot;&gt;&lt;&#x2F;i&gt;&#39;,</span><br><span class="line">       next_text: &#39;&lt;i class&#x3D;&quot;fa fa-angle-right&quot; aria-label&#x3D;&quot;&#39;+__(&#39;accessibility.next_page&#39;)+&#39;&quot;&gt;&lt;&#x2F;i&gt;&#39;,</span><br><span class="line">       mid_size: 1,</span><br><span class="line">       escape: false</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;&#125;</span><br><span class="line"> &lt;&#x2F;nav&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure><h3 id="点击搜索后，跳转about-blank-blocked"><a href="#点击搜索后，跳转about-blank-blocked" class="headerlink" title="点击搜索后，跳转about:blank#blocked"></a>点击搜索后，跳转about:blank#blocked</h3><p>原因就是打开了外链，要么关了，要么就限定下作用域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">external_link:</span><br><span class="line">    enable: true</span><br><span class="line">    field: post</span><br></pre></td></tr></table></figure><p>如果还不行的话，就到blog下的配置文件中修改<br>external_link:<br>    enable: false<br>然后重新启动项目看下效果</p><h3 id="设置透明度"><a href="#设置透明度" class="headerlink" title="设置透明度"></a>设置透明度</h3><p>修改文件：/你的博客文件夹/themes/next/source/css/_schemes/Pisces/_layout.styl 的<br>opacity: 1;</p><h3 id="文本中添加图片不能显示"><a href="#文本中添加图片不能显示" class="headerlink" title="文本中添加图片不能显示"></a>文本中添加图片不能显示</h3><p>使用语法如 “[desc] (demo.jpeg)”添加本地图图片后不能显示。主要原因是hexo的升级后造成的。<br>卸载npm uninstall hexo-asset-image。<br>hexo clean、hexo g、hexo s可能会解决你的疑问。如果不能，网上还有比较靠谱的解决方法，可以保持耐心进行尝试。</p><h3 id="网站访问速度慢"><a href="#网站访问速度慢" class="headerlink" title="网站访问速度慢"></a>网站访问速度慢</h3><p>安装hexo-service-worker包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-service-worker --save</span><br></pre></td></tr></table></figure><p>在站点的配置文件中加入下面信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># offline config passed to sw-precache.</span><br><span class="line">service_worker:</span><br><span class="line">  maximumFileSizeToCacheInBytes: 5242880</span><br><span class="line">  staticFileGlobs:</span><br><span class="line">  - public&#x2F;**&#x2F;*.&#123;js,html,css,png,jpg,gif,svg,eot,ttf,woff,woff2&#125;</span><br><span class="line">  stripPrefix: public</span><br><span class="line">  verbose: true</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-10-面向对象-3</title>
      <link href="/2019/10/03/Javascript-10-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-3/"/>
      <url>/2019/10/03/Javascript-10-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-3/</url>
      
        <content type="html"><![CDATA[<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在JS中无法实现接口继承，JS只支持实现继承，而且其实现继承主要是依靠原型链来实现的。</p><a id="more"></a><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。</p><p>JS将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p><p>实现原型链有一种基本模式，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function SuperType() &#123;</span><br><span class="line">    this.property &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue &#x3D; function() &#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SuperType() &#123;</span><br><span class="line">    this.subProperty &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 继承了SuperType</span><br><span class="line"></span><br><span class="line">SuperType.prototype &#x3D; new SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSuperValue &#x3D; function() &#123;</span><br><span class="line">    return this.subProperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance &#x3D; new SuperType();</span><br><span class="line">alert(instance.getSuperValue()); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。在找不到属性或方法的情况下，搜索过程总是一环一环地前行到原型链末端才会停下。</p><h5 id="默认的原型"><a href="#默认的原型" class="headerlink" title="默认的原型"></a>默认的原型</h5><p>所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。</p><h5 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h5><p>可以通过两种方式来确定原型和实例之间的关系。第一种方式就是使用instanceof操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(instance instanceof Object); &#x2F;&#x2F; true</span><br><span class="line">alert(instance instanceof SuperType); &#x2F;&#x2F; true</span><br><span class="line">alert(instance instanceof SubType); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>第二种方式是使用isPrototypeOf()。只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此isPrototypeOf()也会返回true。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(Object.prototype.isPrototypeOf(instance)); &#x2F;&#x2F; true</span><br><span class="line">alert(SuperType.prototype.isPrototypeOf(instance)); &#x2F;&#x2F; true</span><br><span class="line">alert(SubType.prototype.isPrototypeOf(instance)); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h5 id="谨慎地定义方法"><a href="#谨慎地定义方法" class="headerlink" title="谨慎地定义方法"></a>谨慎地定义方法</h5><p>子类有时候需要覆盖超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。</p><p>在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做会重写原型链。</p><h5 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h5><p>最主要的问题来自包含引用类型值的原型。包含引用类型值的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章的变成了现在的原型属性了。</p><p>第二个问题是在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。</p><h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><p>在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用借用构造函数的技术(也叫做伪造对象或经典继承)。这种技术的基本思想是在自类型构造函数的内部调用超类型构造函数。函数只不过是在特定环境中执行代码的对象，因此通过apply()和call()方法也可以在(将来)新创建的对象上执行构造函数。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function SuperType() &#123;</span><br><span class="line">    this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType() &#123;</span><br><span class="line">    &#x2F;&#x2F; 继承了SuperType</span><br><span class="line">    SuperType.call(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 &#x3D; new SubType();</span><br><span class="line">instance1.colors.push(&#39;black&#39;);</span><br><span class="line">alert(instance1.colors); &#x2F;&#x2F; &#39;red, blue, green, black&#39;</span><br><span class="line"></span><br><span class="line">var instance2 &#x3D; new SubType();</span><br><span class="line">alert(instance2.colors); &#x2F;&#x2F; &#39;red, blue, green&#39;</span><br></pre></td></tr></table></figure><h5 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h5><p>相对于原型链而言，借用构造函数可以在自类型构造函数中向超类型构造函数传递参数。</p><h5 id="借用构造函数的问题"><a href="#借用构造函数的问题" class="headerlink" title="借用构造函数的问题"></a>借用构造函数的问题</h5><p>如果仅仅是借用构造函数，那么也将无从避免构造函数模式存在的问题–方法都在构造函数中定义，因此函数复用就无从谈起。而且，在超类型的原型中定义的方法，对自类型而言也是不可见的。结果所有类型都只能使用构造函数模式。</p><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>组合继承(combination inheritance)，有时候也叫伪经典继承，指的是将原型链和借用构造函数肚饿技术组合到一块，从而发挥二者之长的一种继承模式。思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，即通过在原型上定义方法显示了复用，又保证每个实例都有自己的属性。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Supertype.prototype.sayName &#x3D; function() &#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line">    &#x2F;&#x2F; 继承属性</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 继承方法</span><br><span class="line">SubType.prototype &#x3D; new SuperType();</span><br><span class="line">SubType.prototype.constructor &#x3D; SubType;</span><br><span class="line">SubType.prototype.sayAge &#x3D; function() &#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 &#x3D; new SubType(&#39;Nicholas&#39;, 29);</span><br><span class="line">instance1.colors.push(&#39;black&#39;);</span><br><span class="line">alert(instance1.colors); &#x2F;&#x2F; &#39;red, blue, green, black&#39;</span><br><span class="line">instance1.sayName(); &#x2F;&#x2F; &#39;Nicholas&#39;</span><br><span class="line">instance1.sayAge(); &#x2F;&#x2F; 29</span><br><span class="line"></span><br><span class="line">var isntance2 &#x3D; new SubType(&#39;Greg&#39;, 27);</span><br><span class="line">alert(instance2.colors); &#x2F;&#x2F; &#39;red, blue, green&#39;</span><br><span class="line">instance2.sayName(); &#x2F;&#x2F; &#39;Greg&#39;</span><br><span class="line">instance2.sayAge(); &#x2F;&#x2F; 27</span><br></pre></td></tr></table></figure><p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，称为JS中最常用的继承模式。而且，instanceof和isPrototypeOf()也能够用于识别基于组合创建的对象。</p><h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>原型式继承的的实现方法与普通继承的实现方法不同，原型式继承并没有使用严格意义上的构造函数，而是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。</p><p>Object.create()这个方法接收两个参数：一个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()与Object()方法的行为相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name : &#39;Nicholas&#39;,</span><br><span class="line"></span><br><span class="line">  friends : [&#39;Shelby&#39;, &#39;Court&#39;, &#39;Van&#39;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var anotherPerson &#x3D; object.create(person);</span><br><span class="line"></span><br><span class="line">anotherPerson.name &#x3D; &#39;Greg&#39;;</span><br><span class="line"></span><br><span class="line">anotherPerson.friends.push(&#39;Bob&#39;);</span><br><span class="line"></span><br><span class="line">var anotherPerson2 &#x3D; object.create(person);</span><br><span class="line"></span><br><span class="line">anotherPerson2.name &#x3D; &#39;Linda&#39;;</span><br><span class="line"></span><br><span class="line">anotherPerson2.friends.push(&#39;Rose&#39;);</span><br><span class="line"></span><br><span class="line">alert(person.friends);  &#x2F;&#x2F; Shelby, Court, Van, Bob, Linda</span><br></pre></td></tr></table></figure><p>第二个参数与Object.defineProperties()方法的第二个参数格式相同；每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">  name : &#39;Nicholas&#39;,</span><br><span class="line"></span><br><span class="line">  friends : [&#39;Shelby&#39;, &#39;Court&#39;, &#39;Van&#39;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var anotherPerson &#x3D; Object.create(person, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: &#39;Greg&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(anotherPerson.name); &#x2F;&#x2F; Greg</span><br></pre></td></tr></table></figure><h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>寄生式(parasitic)继承式与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地式它做了所有工作一样返回对象。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original) &#123;</span><br><span class="line">    var clone &#x3D; object(original); &#x2F;&#x2F; 通过调用函数创建一个新对象</span><br><span class="line">    clone.sayHi &#x3D; function() &#123; &#x2F;&#x2F; 以某种方式来增强这个对象</span><br><span class="line">        alert(&#39;hi&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    return clone; &#x2F;&#x2F; 返回这个对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。任何能够放那hi新对象的函数都适用于此模式。</p><h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>继承组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数。本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(subType, superType)&#123;</span><br><span class="line">    var prototype &#x3D; object(superType.prototype); &#x2F;&#x2F; 创建对象</span><br><span class="line">    prototype.constructor &#x3D; subType; &#x2F;&#x2F; 增强对象</span><br><span class="line">    subType.prototype &#x3D; prototype; &#x2F;&#x2F; 指定对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.colors &#x3D; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName &#x3D; function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function SubType(name, age)&#123;</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType);&#x2F;&#x2F;实现继承</span><br><span class="line">SubType.prototype.sayAge &#x3D; function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发人员普遍认为寄生组合式继承式引用类型最理想的继承范式。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用nextcloud搭建个人网盘</title>
      <link href="/2019/09/29/%E7%94%A8nextcloud%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%9B%98/"/>
      <url>/2019/09/29/%E7%94%A8nextcloud%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一直以来主要是用百度云网盘和其他的微云什么的搭配使用，什么方便用为什么，个人数据放得自己的找不到，之前也看过搭建个人网盘但是一直没有自己去搞过，这次想着花点时间搞个个人网盘来用，顺便写下自己的搭建过程。</p><a id="more"></a><h3 id="框架选择"><a href="#框架选择" class="headerlink" title="框架选择"></a>框架选择</h3><p>选择nextcloud的原因：</p><ul><li>各个平台都有对应的客户端，方便。</li><li>开源，可以自己动手操作。</li><li>功能比较完善。</li></ul><p><a href="https://nextcloud.com" target="_blank" rel="noopener">nextCloud官网</a></p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>自己查了以下发现ucloud最近在做活动，比较便宜。</p><h4 id="注册连接"><a href="#注册连接" class="headerlink" title="注册连接"></a>注册连接</h4><p><a href="https://passport.ucloud.cn/#register" target="_blank" rel="noopener">前往注册</a></p><h4 id="领券连接"><a href="#领券连接" class="headerlink" title="领券连接"></a>领券连接</h4><p><a href="https://www.ucloud.cn/site/global.html#xianggang" target="_blank" rel="noopener">前往领券</a></p><h4 id="系统版本"><a href="#系统版本" class="headerlink" title="系统版本"></a>系统版本</h4><p>我购买的时候都是直接按照默认的来，系统默认的是CentOS 8。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="安装DNF"><a href="#安装DNF" class="headerlink" title="安装DNF"></a>安装DNF</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install dnf</span><br><span class="line"></span><br><span class="line">dnf update -y</span><br></pre></td></tr></table></figure><h4 id="安装Apache"><a href="#安装Apache" class="headerlink" title="安装Apache"></a>安装Apache</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装</span><br><span class="line">dnf install -y httpd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启动</span><br><span class="line">systemctl enable httpd.service</span><br><span class="line">systemctl start httpd.service</span><br></pre></td></tr></table></figure><h4 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dnf install https:&#x2F;&#x2F;dl.fedoraproject.org&#x2F;pub&#x2F;epel&#x2F;epel-release-latest-8.noarch.rpm</span><br><span class="line"></span><br><span class="line">dnf install https:&#x2F;&#x2F;rpms.remirepo.net&#x2F;enterprise&#x2F;remi-release-8.rpm</span><br><span class="line"></span><br><span class="line">dnf install yum-utils</span><br><span class="line"></span><br><span class="line">dnf module reset php</span><br><span class="line"></span><br><span class="line">dnf module install php:remi-7.4</span><br><span class="line"></span><br><span class="line">dnf install -y php php-gd php-mbstring php-intl php-pecl-apcu php-mysqlnd php-opcache php-json php-zip php-dom</span><br></pre></td></tr></table></figure><h4 id="安装数据库"><a href="#安装数据库" class="headerlink" title="安装数据库"></a>安装数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装</span><br><span class="line">dnf install -y mariadb mariadb-server</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启动</span><br><span class="line">systemctl enable mariadb.service</span><br><span class="line">systemctl start mariadb.service</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 配置密码</span><br><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure><h4 id="安装nextcloud"><a href="#安装nextcloud" class="headerlink" title="安装nextcloud"></a>安装nextcloud</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;download.nextcloud.com&#x2F;server&#x2F;releases&#x2F;nextcloud-18.0.3.zip</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解压</span><br><span class="line">unzip nextcloud-*.zip</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拷贝到Apache目录</span><br><span class="line">cp -R nextcloud&#x2F; &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建数据目录</span><br><span class="line">mkdir &#x2F;var&#x2F;www&#x2F;html&#x2F;nextcloud&#x2F;data</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置权限并重启</span><br><span class="line">chown -R apache:apache &#x2F;var&#x2F;www&#x2F;html&#x2F;nextcloud</span><br><span class="line"></span><br><span class="line">systemctl restart httpd.service</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果你是 SELinux 需要运行如下命令</span><br><span class="line"></span><br><span class="line">semanage fcontext -a -t httpd_sys_rw_content_t &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;nextcloud&#x2F;data(&#x2F;.*)?&#39;</span><br><span class="line"></span><br><span class="line">semanage fcontext -a -t httpd_sys_rw_content_t &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;nextcloud&#x2F;config(&#x2F;.*)?&#39;</span><br><span class="line"></span><br><span class="line">semanage fcontext -a -t httpd_sys_rw_content_t &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;nextcloud&#x2F;apps(&#x2F;.*)?&#39;</span><br><span class="line"></span><br><span class="line">semanage fcontext -a -t httpd_sys_rw_content_t &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;nextcloud&#x2F;.htaccess&#39;</span><br><span class="line"></span><br><span class="line">semanage fcontext -a -t httpd_sys_rw_content_t &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;nextcloud&#x2F;.user.ini&#39;</span><br><span class="line"></span><br><span class="line">semanage fcontext -a -t httpd_sys_rw_content_t &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;nextcloud&#x2F;3rdparty&#x2F;aws&#x2F;aws-sdk-php&#x2F;src&#x2F;data&#x2F;logs(&#x2F;.*)?&#39;</span><br><span class="line"></span><br><span class="line">restorecon -R &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;nextcloud&#x2F;&#39;</span><br><span class="line"></span><br><span class="line">setsebool -P httpd_can_network_connect on</span><br></pre></td></tr></table></figure><p>都部署好之后可以访问页面配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;yourdomain&#x2F;nextcloud</span><br></pre></td></tr></table></figure><p>这里填写你的管理员账号密码<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzE4LzE3MThhYjFmODNmYWZkOGI?x-oss-process=image/format,png" alt="avatar"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzE4LzE3MThhYjFmODNmMzE3ZTg?x-oss-process=image/format,png" alt="avatar"><br>这里训责MySQL/MariaDB，用户名默认为root，然后填写你刚才设置的数据库密码，数据库名可填为nexcloud(随意)，下面localhost后加上端口号，然后点击安装完成，等待就好了。</p><p>客户端的话在上面提到的官网中下载。</p><h4 id="域名访问"><a href="#域名访问" class="headerlink" title="域名访问"></a>域名访问</h4><p>通过域名访问<code>http://yourdomain/nextcloud</code>，需要打开nextcloud/config/config.php，找到trusted_domains，在array中添加。</p><p>国内的话网站还需要备案哦!</p>]]></content>
      
      
      <categories>
          
          <category> nextcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nextcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-10-面向对象-2</title>
      <link href="/2019/09/25/Javascript-10-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-2/"/>
      <url>/2019/09/25/Javascript-10-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-2/</url>
      
        <content type="html"><![CDATA[<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为解决这一问题，人们开始使用工厂模式的一种变体。</p><a id="more"></a><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式抽象了创建具体对象的过程，用函数来封装以特定接口创建对象的细节，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name, age, job) &#123;</span><br><span class="line">    var o &#x3D; new Object();</span><br><span class="line">    o.name &#x3D; name;</span><br><span class="line">    o.age &#x3D; age;</span><br><span class="line">    o.job &#x3D; job;</span><br><span class="line">    o.sayName &#x3D; function() &#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 &#x3D; createPerson(&#39;Nicholas&#39;, 29, &#39;Software Engineer&#39;);</span><br><span class="line">var person2 &#x3D; createPerson(&#39;greg&#39;, 27, &#39;Doctor&#39;);</span><br></pre></td></tr></table></figure><p>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题(即怎样知道一个对象的类型)。</p><h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><p>JS中的构造函数可以用来创建特定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。例如，可以用构造函数重构前面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.job &#x3D; job;</span><br><span class="line">    this.sayName &#x3D; function() &#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 &#x3D; new Person(&#39;Nicholas&#39;, 29, &#39;Software Engineer&#39;);</span><br><span class="line">var person2 &#x3D; new Person(&#39;Greg&#39;, 27, &#39;Doctor&#39;);</span><br></pre></td></tr></table></figure><p>与工厂模式的不同之处：</p><ul><li>没有显式地创建对象。</li><li>直接将属性和方法赋给了this对象。</li><li>没有return语句。</li></ul><p>按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。因为构造函数本身也是函数函数，只不过可以用来创建对象而已。</p><p>要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下4步：</p><ul><li>创建一个新对象。</li><li>将构造函数的作用域赋给新对象(因此this就指向了这个新对象)。</li><li>执行构造函数中的代码(为这个新对象添加属性)。</li><li>返回新对象。</li></ul><p>对象的constructor属性最初是用来标识对象类型的。但是检测对象类型，还是instanceof操作符更可靠一些。</p><p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式爹地方。</p><h5 id="将构造函数当作函数"><a href="#将构造函数当作函数" class="headerlink" title="将构造函数当作函数"></a>将构造函数当作函数</h5><p>构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过new操作符来调用，那么它就可以作为构造函数；而任何函数，如果不通过new操作符来调用，那么它跟普通函数也不会有什么两样。</p><h5 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h5><p>使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。以这种方式创建函数，会导致不同的作用域链和标识符解析，但创建Function新实例的机制仍然是相同的。因此，不同实例上的同名函数是不相等的。</p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line">    Person.prototype.name &#x3D; &#39;Nicholas&#39;;</span><br><span class="line">    Person.prototype.age &#x3D; 29;</span><br><span class="line">    Person.prototype.job &#x3D; &#39;Software Engineer&#39;;</span><br><span class="line">    Person.prototype.sayName &#x3D; function() &#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var person1 &#x3D; new Person();</span><br><span class="line">    person1.sayName(); &#x2F;&#x2F; &#39;Nicolas&#39;</span><br><span class="line"></span><br><span class="line">    var person2 &#x3D; new Person();</span><br><span class="line">    person2.sayName(); &#x2F;&#x2F; &#39;Nicholas&#39;</span><br><span class="line"></span><br><span class="line">    alert(person1.sayName &#x3D;&#x3D; person2.sayName); &#x2F;&#x2F; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h5><p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor(构造函数)属性，这个属性是一个指向prototype属性所在函数的指针。通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。</p><p>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承来的。当调用构造函数创建一个新实例后，该实例内部将包含一个指针(内部属性)，指向构造函数的原型对象–[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但Firefox、Safari、Chrome在每个对象上都支持一个属性<strong>proto</strong>；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。</p><p>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值。如果没有找到。则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。而这正是多个对象实例共享原型所保存的属性和方法的基本原理。</p><p>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性，即添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为null，也只会在实例中设置这个属性，而不会回复其指向原型的连接。使用delete操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性。</p><p>使用hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法(不要忘了它是从Object继承来的)只在给定属性存在于对象实例中时，才会返回true。</p><h5 id="原型与in操作符"><a href="#原型与in操作符" class="headerlink" title="原型与in操作符"></a>原型与in操作符</h5><p>有两种方式使用in操作符：单独使用和在for-in循环中使用。在单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在与实例中还是原型中。</p><p>由于in操作符只要通过对象能够访问代属性就返回true，hasOwnProperty()只在属性存在于实例中时才返回true，因此，只要in操作符返回true而hasOwnProperty()返回false，就可以确定属性是原型中的属性。</p><p>在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的(enumerated)属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。</p><p>要取得对象上所有可枚举的实例属性，可以使用Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</p><h5 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h5><p>为减少不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype &#x3D; &#123;</span><br><span class="line">    name: &#39;Nicholas&#39;,</span><br><span class="line">    age: 29,</span><br><span class="line">    job: &#39;Software Engineer&#39;,</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        alert(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h5><p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来–即使是先创建了实例后修改原型也照样如此，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var friend &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHi &#x3D; function() &#123;</span><br><span class="line">    alert(&#39;Hi&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">friend.sayHi(); &#x2F;&#x2F; &#39;Hi&#39;</span><br></pre></td></tr></table></figure><p>重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的练习，它们引用的仍然是最初的原型。</p><h5 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h5><p>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型(Object、Array、String等等)都在其构造函数的原型上定义了方法。</p><p>通过原生对象的原型，不仅可以取得所有默认方法的引用，而且可以定义新方法。</p><h5 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h5><p>原型模式省略了为构造函数传递初始化参数，所有实例子啊默认情况下都将取得相同的属性值。原型模式的最大问题是由其共享的本性导致的。</p><h4 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h4><p>创造自定义类型的最常见方式就是组合使用构造函数与原型模式。构造函数用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度的节省了内存。另外，这种混成模式还支持向构造函数传递参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.job &#x3D; job;</span><br><span class="line">    this.firends &#x3D; [&#39;Sgelby&#39;, &#39;Court&#39;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype &#x3D; &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 &#x3D; new Person(&#39;Nicholas&#39;, 29, &#39;Software Engineer&#39;);</span><br><span class="line">var person2 &#x3D; new Person(&#39;Greg&#39;, 27, &#39;Doctor&#39;);</span><br><span class="line"></span><br><span class="line">person1.firends.push(&#39;Van&#39;);</span><br><span class="line">alert(person1.firends); &#x2F;&#x2F; &#39;Shelby, Court, Van&#39;</span><br><span class="line">alert(person2.friends); &#x2F;&#x2F; &#39;Shelby, Court&#39;</span><br><span class="line">alert(person1.firends &#x3D;&#x3D;&#x3D; person2.friends); &#x2F;&#x2F; false</span><br><span class="line">alert(person1.sayName &#x3D;&#x3D;&#x3D; person2.sayName); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h4 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h4><p>动态原型模式吧所有的信息都封装在了构造函数中，而通过在构造函数中初始化原型(仅在必要的情况下)，又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job) &#123;</span><br><span class="line">    &#x2F;&#x2F; 属性</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.job &#x3D; job;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 方法</span><br><span class="line">    if (typeof this.sayName !&#x3D; function) &#123;</span><br><span class="line">        Person.prototype.sayName &#x3D; function() &#123;</span><br><span class="line">            alert(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var friend &#x3D; new Person(&#39;Nicholas&#39;, 29, &#39;Software Engineer&#39;);</span><br><span class="line">friend.sayName();</span><br></pre></td></tr></table></figure><h4 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h4><p>通常，在前述的几种模式都不适用的情况下，可以使用寄生(parasitic)构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job) &#123;</span><br><span class="line">    var o &#x3D; new Object();</span><br><span class="line">    o.name &#x3D; name;</span><br><span class="line">    o.age &#x3D; age;</span><br><span class="line">    o.job &#x3D; job;</span><br><span class="line">    o.sayName &#x3D; function() &#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var friend &#x3D; new Person(&#39;Nicholas&#39;, 29, &#39;Software Engineer&#39;);</span><br><span class="line">friend.sayName(); &#x2F;&#x2F; &#39;Nicholas&#39;</span><br></pre></td></tr></table></figure><p>关于寄生构造函数模式，有一点需要说明；首先，返回的对象与构造函数或者构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没什么不同。为此，不能依赖instanceof操作符来确定对象类型。所以在可以使用其他模式的情况下，不要使用这种模式。</p><h4 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h4><p>稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中(这些环境中会禁止使用this和new)，或者防止数据被其他应用程序改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建的对象的实例方法不引用this；二是不使用new操作符调用构造函数。按照稳妥构造函数的要求，可以将前面的Person构造函数重写如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job) &#123;</span><br><span class="line">    &#x2F;&#x2F;  创建要返回的对象</span><br><span class="line">    var o &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 可以在这里定义私有变量和函数</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 添加方法</span><br><span class="line">    o.sayName &#x3D; function() &#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 返回对象</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-10-面向对象-1</title>
      <link href="/2019/09/22/javascript-10-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1/"/>
      <url>/2019/09/22/javascript-10-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1/</url>
      
        <content type="html"><![CDATA[<p>面向对象(Object-Oriented，OO)的语言有一个标志，那就是它们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。</p><p>ECMA-262对对象的定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数”。严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性和方法都有一个名字，而每个名字都映射到一个值。正因为这样，我们可以把JS的对象想象成散列表：无非就是一组明值对，其中值可以是数据或函数。</p><p>每个对象都是基于一个引用类型创建的，这个引用类型可以是原生类型，也可以是开发人员定义的类型。</p><a id="more"></a><h3 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h3><p>创建自定义对象的最简单方式就是创建一个object的实例，然后在为它添加属性和方法，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; new Object();</span><br><span class="line">person.name &#x3D; &#39;Nicholas&#39;;</span><br><span class="line">person.age &#x3D; 20;</span><br><span class="line">person.job &#x3D; &#39;Software Engineer&#39;;</span><br><span class="line"></span><br><span class="line">person.sayName &#x3D; function() &#123;</span><br><span class="line">    alert(this.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以前我们经常用这种模式创建新对象，现在主要使用对象字面量的形式来创建自定义对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">    name: &#39;Nicholas&#39;,</span><br><span class="line">    age: 20,</span><br><span class="line">    job: &#39;Software Engineer&#39;,</span><br><span class="line">    </span><br><span class="line">    sayName &#x3D; function() &#123;</span><br><span class="line">        alert(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h4><p>JS有两种属性：数据属性和访问器属性。</p><h5 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h5><p>数据属性包含一个数据值的位置。在这个文职可以读取和写入值。数据属性有4个描述其行为的特性。</p><ul><li>[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能都修改属性的特性，或者能否把属性修改为访问器属性。直接在对象上定义的属性，默认值为true。</li><li>[[Enumerable]]：表示能否通过for-in循环返回属性。直接在对象上定义的属性，默认值为true。</li><li>[[Writable]]：表示能否修改属性的值。默认为true。</li><li>[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为undefined。</li></ul><p>要修改属性默认的特性，必须使用Object.defineproperty()方法。这个方法接受三个参数：属性所在的对象、属性的名字、一个描述符对象。其中，描述符(descriptor)对象的属性必须是：configurable、enumerable、writable、value。</p><p>把configurable设置为false，表示不能从对象中删除属性。如果对这个属性调用delete，则在非严格模式下什么也不会发生，而在严格模式下会导致错误。而且，一旦把属性定义为不可配置的，就不能再把它变回可配置了。此时，再调用Object.defineproperty()修改除writable之外的特性，都会导致错误。</p><p>在调用Object.defineproperty()创建一个新的属性时，如果不指定，configurable、enumerable、writable特性的默认值都是false。如果调用Object.defineproperty()方法只是修改已定义的属性和特性，，则无此限制。</p><h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><p>访问器属性不包含数据值；它们包含一对儿getter和setter函数。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。</p><p>访问器属性有以下4个特性：</p><ul><li>[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为true。</li><li>[[Enumerable]]：表示能否通过for-in循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为true。</li><li>[[Get]]：在读取属性时调用的函数。默认值为undefined。</li><li>[[Set]]：在写入属性时调用的函数。默认值为undefined。</li></ul><p>访问器的属性不能直接定义没必须使用Object.defineproperty()来定义。访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。</p><p>不一定非要同时指定getter和setter。只指定getter意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了getter函数的属性会抛出错误。类似的，只指定setter函数的属性也不能读，否则在非严格模式下会返回undefined，而在严格模式下会抛出错误。</p><h4 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h4><p>由于为对象定义多个属性的可能性很大，JS又定义了一个Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接受两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。</p><h4 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h4><p>使用JS的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接受两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get、set；如果是数据属性，这个对象的属性有configurable、enumerable、writable、value.</p><p>在JS中，可以针对任何对象–包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor()方法.</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-9-引用类型-5</title>
      <link href="/2019/09/21/Javascript-9-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-5/"/>
      <url>/2019/09/21/Javascript-9-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-5/</url>
      
        <content type="html"><![CDATA[<h4 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h4><p>JS对内置对象的定义是：”由JS提供实现提供的、不依赖宿主环境的对象，这些对象在JS程序执行之前就已经存在了“。</p><a id="more"></a><h5 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h5><p>JS中的Global对象在某种意义上是作为一个终极的”兜底儿对象“来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是Global对象的属性。</p><h6 id="URI编码方法"><a href="#URI编码方法" class="headerlink" title="URI编码方法"></a>URI编码方法</h6><p>Global对象的encideURI()和encodeURICOMPONENT()方法可以对URI(Uniform Resource Identifiers，通用资源标识符)进行编码，以便发送给浏览器。有效的URI中不能包含某些字符，例如空格。而这两个URI编码方法用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。</p><p>encodeURI()主要用于整个URI，而encodeURIComponent()主要用于对URI中的某一段进行编码。它们的主要区别在于，encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号、井号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。</p><p>使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20.而encodeURIComponent()则会使用对应的编码替换所有非字母数字字符。</p><p>对应的方法分别是decodeURI()和decodeURIComponent()。</p><h6 id="eval-方法"><a href="#eval-方法" class="headerlink" title="eval()方法"></a>eval()方法</h6><p>eval()方法就像是一个完整的JS解析器，它只接受一个参数，即要执行的JS字符串。通过eval()执行的代码被认为是包含该此调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过eval()执行的代码可以引用在包含环境汇总定义的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var msg &#x3D; &quot;hello world&quot;;</span><br><span class="line">eval(&quot;alert(msg)&quot;); &#x2F;&#x2F; &quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>在eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在eval()执行的时候创建。</p><p>严格模式喜爱，在外部访问不到eval()创建的任何变量和函数，为eval赋值也会导致错误。</p><h6 id="Global对象的属性"><a href="#Global对象的属性" class="headerlink" title="Global对象的属性"></a>Global对象的属性</h6><table><thead><tr><th>属性</th><th>说明</th><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>undefined</code></td><td>特殊值<code>undefined</code></td><td><code>Date</code></td><td>构造函数<code>Date</code></td></tr><tr><td><code>NaN</code></td><td>特殊值<code>NaN</code></td><td><code>RegExp</code></td><td>构造函数<code>RegExp</code></td></tr><tr><td><code>Infinity</code></td><td>特殊值<code>Infinity</code></td><td><code>Error</code></td><td>构造函数<code>Error</code></td></tr><tr><td><code>Object</code></td><td>构造函数<code>Object</code></td><td><code>EvalError</code></td><td>构造函数<code>EvalError</code></td></tr><tr><td><code>Array</code></td><td>构造函数<code>Array</code></td><td><code>RangError</code></td><td>构造函数<code>RangError</code></td></tr><tr><td><code>Function</code></td><td>构造函数<code>Function</code></td><td><code>ReferenceError</code></td><td>构造函数<code>ReferenceError</code></td></tr><tr><td><code>Boolean</code></td><td>构造函数<code>Boolean</code></td><td><code>SyntaxError</code></td><td>构造函数<code>SyntaxError</code></td></tr><tr><td><code>String</code></td><td>构造函数<code>String</code></td><td><code>TypeError</code></td><td>构造函数<code>TypeError</code></td></tr><tr><td><code>Number</code></td><td>构造函数<code>Number</code></td><td><code>URIError</code></td><td>构造函数<code>URIError</code></td></tr></tbody></table><h6 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h6><p>ECMAScript虽然没有指出如何直接访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分来加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成了window对象的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function sayColor()&#123;</span><br><span class="line">alert(window.color);</span><br><span class="line">&#125;</span><br><span class="line">window.sayColor();  &#x2F;&#x2F;&quot;red&quot;</span><br><span class="line">&#x2F;*这里定义了一个名为color的全局变量和一个名为sayColor()的全局函数。在sayColor()内部，可以通过window.color来访问color变量 ，以说明全局变量是window对象的属性。然后又使用window.sayColor()来直接通过window对象调用这个函数，结果就显示在了警告框中*&#x2F;</span><br></pre></td></tr></table></figure><h5 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h5><p>ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。Math对象中还提供了辅助完成这些计算的属性和方法。</p><h6 id="Math对象的属性"><a href="#Math对象的属性" class="headerlink" title="Math对象的属性"></a>Math对象的属性</h6><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>Math.E</code></td><td>自然对数的底数，即常量e的值</td></tr><tr><td><code>Math.LN10</code></td><td>10的自然对数</td></tr><tr><td><code>Math.LN2</code></td><td>2的自然对数</td></tr><tr><td><code>Math.LOG2E</code></td><td>以2为底e的对数</td></tr><tr><td><code>Math.LOG10E</code></td><td>以10为底e的对数</td></tr><tr><td><code>Math.PI</code></td><td>∏的值</td></tr><tr><td><code>Math.SQRT1_2</code></td><td>1/2的平方根(即2的平方根的倒数)</td></tr><tr><td><code>Math.SQRT2</code></td><td>2的平方根</td></tr></tbody></table><h6 id="min-和max-方法"><a href="#min-和max-方法" class="headerlink" title="min()和max()方法"></a>min()和max()方法</h6><p>min()和max()方法用于确定一组数值中的最小值和最大值。这两个方法都可以接收任意多个数值参数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var min&#x3D;Math.min(3,54,32,16);</span><br><span class="line">alert(min);&#x2F;&#x2F;3</span><br><span class="line"></span><br><span class="line">var max&#x3D;Math.max(3,54,32,16);</span><br><span class="line">alert(max);&#x2F;&#x2F;54</span><br></pre></td></tr></table></figure><h6 id="舍入方法"><a href="#舍入方法" class="headerlink" title="舍入方法"></a>舍入方法</h6><ul><li>Math.ceil()：执行向上舍入，即它总是将数值向上舍入为最接近的整数。</li><li>Math.floor()：执行向下舍入，即它总是将数值向下舍入为最接近的整数。</li><li>Math.round()：执行标准舍入，即它总是将数值四舍五入为最接近的整数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">alert(Math.ceil(25.9));&#x2F;&#x2F;26</span><br><span class="line">alert(Math.ceil(25.5));&#x2F;&#x2F;26</span><br><span class="line">alert(Math.ceil(25.1));&#x2F;&#x2F;26</span><br><span class="line"></span><br><span class="line">alert(Math.floor(25.9));&#x2F;&#x2F;25</span><br><span class="line">alert(Math.floor(25.5));&#x2F;&#x2F;25</span><br><span class="line">alert(Math.floor(25.1));&#x2F;&#x2F;25</span><br><span class="line"></span><br><span class="line">alert(Math.round(25.9));&#x2F;&#x2F;26</span><br><span class="line">alert(Math.round(25.5));&#x2F;&#x2F;26</span><br><span class="line">alert(Math.round(25.1));&#x2F;&#x2F;25</span><br></pre></td></tr></table></figure></li></ul><h6 id="random-方法"><a href="#random-方法" class="headerlink" title="random()方法"></a>random()方法</h6><p>Math.random()返回方法返回大于等于0小于1的一个随机数。<br><code>值=Math.floor(Math.random()*可能值的总数+第一个可能的值)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num&#x3D;Math.floor(Math.random()*10+1);&#x2F;&#x2F;1到10</span><br><span class="line">var num&#x3D;Math.floor(Math.random]()*9+2);&#x2F;&#x2F;2到10</span><br></pre></td></tr></table></figure><h6 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h6><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Math.abs(num)</code></td><td>返回<code>num</code>的绝对值</td></tr><tr><td><code>Math.exp(num)</code></td><td>返回<code>Math.E</code>的<code>num</code>次幂</td></tr><tr><td><code>Math.log(num)</code></td><td>返回<code>num</code>的自然对数</td></tr><tr><td><code>Math.pow(num,power)</code></td><td>返回<code>num</code>的<code>power</code>次幂</td></tr><tr><td><code>Math.sqrt(num)</code></td><td>返回<code>num</code>的平方根</td></tr><tr><td><code>Math.acos(x)</code></td><td>返回<code>x</code>的反余弦值</td></tr><tr><td><code>Math.asin(x)</code></td><td>返回<code>x</code>的反正弦值</td></tr><tr><td><code>Math.atan(x)</code></td><td>返回<code>x</code>的反正切值</td></tr><tr><td><code>Math.atan2(y,x)</code></td><td>返回<code>y/x</code>的反正切值</td></tr><tr><td><code>Math.cos(x)</code></td><td>返回<code>x</code>的余弦值</td></tr><tr><td><code>Math.sin(x)</code></td><td>返回<code>x</code>的正弦值</td></tr><tr><td><code>Math.tan(x)</code></td><td>返回<code>x</code>的正切值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-9-引用类型-4</title>
      <link href="/2019/09/20/Javascript-9-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-4/"/>
      <url>/2019/09/20/Javascript-9-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-4/</url>
      
        <content type="html"><![CDATA[<h4 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h4><p>为了便于操作基本类型值，JS还提供了3个特殊的引用类型：Boolean、Number、String。</p><a id="more"></a><p>实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。基本类型值不是对象，因而从逻辑上讲它们不应该有方法(尽管如我们所愿，它们确实有方法)。其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。</p><ul><li>创建String类型的一个实例</li><li>在实例上调用指定的方法</li><li>销毁这个实例</li></ul><p>经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于Boolean和Number类型对应的布尔值和数字值。</p><p>引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。</p><p>对基本包装类型的实例调用typeof会返回‘object’，而且所有基本包装类型的对象在转换为布尔类型时值都是true。要注意的是，使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。</p><h5 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h5><p>Boolean类型是与布尔值对应的引用类型，要创建Boolean对象，可以像下面这样调用Boolean构造函数并传入true或false值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var booleanObject &#x3D; new Boolean(true);</span><br></pre></td></tr></table></figure><p>Boolean类型的实例重写了valueOf()方法，返回基本类型值true或false；重写了toString()方法，返回字符串‘true’和‘false’。但是，Boolean 对象在 ECMAScript 中用处不大。建议不使用。</p><h5 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h5><p>Number 是与数字值对应的引用类型。要创建 Number 对象，可以调用 Number 构造函数时向其中传递相应的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var numberObject &#x3D; new Number(10)</span><br></pre></td></tr></table></figure><p>与 Boolean 类型一样，Number 类型也重写了 valueOf ( ) 、toString ( ) 和 toLocalString ( ) 方法。valueOf ( ) 方法返回对象表示的基本类型的数字，另外两个方法则返回字符串形式的数值。</p><h6 id="数值格式化方法："><a href="#数值格式化方法：" class="headerlink" title="数值格式化方法："></a>数值格式化方法：</h6><ul><li>toFixed(): 会按照指定的小数位返回数值的字符串表示。如果本来的小数位多于指定数值，则四舍五入。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 10</span><br><span class="line">alert(num.toFixed(2))&#x2F;&#x2F; &quot;10.00&quot;</span><br></pre></td></tr></table></figure></li><li>toExponential(): 该方法返回以指数表示法（也称 e 表示法）表示的数值的字符串形式，与 toFixed ( ) 一样，也接受一个参数作为小数位数。</li><li>toPrecision(): 该方法看哪种格式更合适来返回以上两种表示方式中的一种。也接受一个参数，即表示数值的所有数字的位数（不包括指数部分）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 99</span><br><span class="line">alert(num.toPrecision(1))&#x2F;&#x2F; 1e+2</span><br><span class="line">alert(num.toPrecision(2))&#x2F;&#x2F; 99</span><br><span class="line">alert(num.toPrecision(3))&#x2F;&#x2F; 99.0</span><br></pre></td></tr></table></figure></li></ul><h6 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h6><p>String 类型是字符串的对象包装类型，可以像下面这样使用 String 构造函数来创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var stringObject &#x3D; new String(&quot;hello world&quot;);</span><br></pre></td></tr></table></figure><p>String 对象的方法也可以在所有基本的字符串值中访问到。其中，继承valueOf()、toLocaleString()和 toString()方法，都返回对象所表示的基本字符串值</p><p>String 类型的每个实例都有一个length 属性，表示字符串中包含多个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var stringValue &#x3D; &quot;hello world&quot;; </span><br><span class="line">alert(stringValue.length); &#x2F;&#x2F;&quot;11&quot;</span><br></pre></td></tr></table></figure><h6 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h6><p>两个用于访问字符串中特定字符的方法是：charAt()和 charCodeAt()。这两个方法都接收一个参数，即基于 0 的字符位置。其中，charAt()方法以单字符字符串的形式返回给定位置的那个字符（ECMAScript 中没有字符类型）。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var stringValue &#x3D; &quot;hello world&quot;; </span><br><span class="line">alert(stringValue.charAt(1)); &#x2F;&#x2F;&quot;e&quot; </span><br><span class="line">字符串&quot;hello world&quot;位置 1 处的字符是&quot;e&quot;，因此调用 charAt(1)就返回了&quot;e&quot;。如果你想得到的不是字符而是字符编码，那么就要像下面这样使用 charCodeAt()了。</span><br><span class="line">var stringValue &#x3D; &quot;hello world&quot;; </span><br><span class="line">alert(stringValue.charCodeAt(1)); &#x2F;&#x2F;输出&quot;101&quot; </span><br><span class="line">这个例子输出的是&quot;101&quot;，也就是小写字母&quot;e&quot;的字符编码。</span><br><span class="line"></span><br><span class="line">ECMAScript 5 还定义了另一个访问个别字符的方法。在支持此方法的浏览器中，可以使用方括号加数字索引来访问字符串中的特定字符</span><br><span class="line">var stringValue &#x3D; &quot;hello world&quot;; </span><br><span class="line">alert(stringValue[1]); &#x2F;&#x2F;&quot;e&quot;</span><br></pre></td></tr></table></figure><h6 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h6><p>concat() : 用于将一个或多个字符串拼接起来，返回拼接得到的新字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var stringValue &#x3D; &quot;hello &quot;; </span><br><span class="line">var result &#x3D; stringValue.concat(&quot;world&quot;); </span><br><span class="line">alert(result); &#x2F;&#x2F;&quot;hello world&quot; </span><br><span class="line">alert(stringValue); &#x2F;&#x2F;&quot;hello&quot;</span><br><span class="line"></span><br><span class="line">concat()方法可以接受任意多个参数，也就是说可以通过它拼接任意多个字符串</span><br><span class="line">var stringValue &#x3D; &quot;hello &quot;; </span><br><span class="line">var result &#x3D; stringValue.concat(&quot;world&quot;, &quot;!&quot;); </span><br><span class="line">alert(result); &#x2F;&#x2F;&quot;hello world!&quot; </span><br><span class="line">alert(stringValue); &#x2F;&#x2F;&quot;hello&quot;</span><br></pre></td></tr></table></figure><p>虽然 concat()是专门用来拼接字符串的方法，但实践中使用更多的还是加号操作符（+）。而且，使用加号操作符在大多数情况下都比使用concat()方法要简便易行（特别是在拼接多个字符串的情况下）</p><p>JS还提供了基于子字符串创建新字符串的方法: </p><ul><li>slice()</li><li>substr()</li><li>substring()</li></ul><p>这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。具体来说，slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置。而 substr()的第二个参数指定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。与concat()方法一样，slice()、substr()和 substring()也不会修改字符串本身的值——它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var stringValue &#x3D; &quot;hello world&quot;; </span><br><span class="line">alert(stringValue.slice(3)); &#x2F;&#x2F;&quot;lo world&quot; </span><br><span class="line">alert(stringValue.substring(3)); &#x2F;&#x2F;&quot;lo world&quot; </span><br><span class="line">alert(stringValue.substr(3)); &#x2F;&#x2F;&quot;lo world&quot; </span><br><span class="line">alert(stringValue.slice(3, 7)); &#x2F;&#x2F;&quot;lo w&quot; </span><br><span class="line">alert(stringValue.substring(3,7)); &#x2F;&#x2F;&quot;lo w&quot; </span><br><span class="line">alert(stringValue.substr(3, 7)); &#x2F;&#x2F;&quot;lo worl&quot;</span><br></pre></td></tr></table></figure><h6 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h6><p>从字符串中查找子字符串的方法：indexOf()和 lastIndexOf()<br>这两个方法都是从一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该子字符串，则返回-1）。这两个方法的区别在于：indexOf()方法从字符串的开头向后搜索子字符串，而 lastIndexOf()方法是从字符串的末尾向前搜索子字符串.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var stringValue &#x3D; &quot;hello world&quot;; </span><br><span class="line">alert(stringValue.indexOf(&quot;o&quot;)); &#x2F;&#x2F;4 </span><br><span class="line">alert(stringValue.lastIndexOf(&quot;o&quot;)); &#x2F;&#x2F;7</span><br></pre></td></tr></table></figure><p>这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。换句话说，indexOf()会从该参数指定的位置向后搜索，忽略该位置之前的所有字符；而 lastIndexOf()则会从指定的位置向前搜索，忽略该位置之后的所有字符.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var stringValue &#x3D; &quot;hello world&quot;; </span><br><span class="line">alert(stringValue.indexOf(&quot;o&quot;, 6)); &#x2F;&#x2F;7 </span><br><span class="line">alert(stringValue.lastIndexOf(&quot;o&quot;, 6)); &#x2F;&#x2F;4</span><br></pre></td></tr></table></figure><h6 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim()方法"></a>trim()方法</h6><p>trim()方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var stringValue &#x3D; &quot; hello world &quot;; </span><br><span class="line">var trimmedStringValue &#x3D; stringValue.trim(); </span><br><span class="line">alert(stringValue); &#x2F;&#x2F;&quot; hello world &quot; </span><br><span class="line">alert(trimmedStringValue); &#x2F;&#x2F;&quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>字符串大小写转换方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var stringValue &#x3D; &quot;hello world&quot;; </span><br><span class="line">alert(stringValue.toUpperCase()); &#x2F;&#x2F;&quot;HELLO WORLD&quot; </span><br><span class="line">alert(stringValue.toLowerCase()); &#x2F;&#x2F;&quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>模式匹配方法</p><ul><li>match(pattern)：返回pattern中的字串或null。</li><li>replace(pattern, replacement)：用replacement替换pattern。</li><li>search(pattern)：返回字符串中pattern开始位置。</li><li>split(pattern)：返回字符串按指定pattern拆分的数组</li></ul><h6 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare()方法"></a>localeCompare()方法</h6><p>与操作字符串有关的最后一个方法是 localeCompare()，这个方法比较两个字符串，并返回下列值中的一个：</p><ul><li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定）；</li><li>如果字符串等于字符串参数，则返回 0；</li><li>如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是 1，具体的值同样要视实现而定）；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var stringValue &#x3D; &quot;yellow&quot;; </span><br><span class="line">alert(stringValue.localeCompare(&quot;brick&quot;)); &#x2F;&#x2F;1 </span><br><span class="line">alert(stringValue.localeCompare(&quot;yellow&quot;)); &#x2F;&#x2F;0 </span><br><span class="line">alert(stringValue.localeCompare(&quot;zoo&quot;)); &#x2F;&#x2F;-1</span><br></pre></td></tr></table></figure></li></ul><h6 id="fromCharCode-方法"><a href="#fromCharCode-方法" class="headerlink" title="fromCharCode()方法"></a>fromCharCode()方法</h6><p>这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。从本质上来看，这个方法与实例方法 charCodeAt()<br>执行的是相反的操作.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(String.fromCharCode(104, 101, 108, 108, 111)); &#x2F;&#x2F;&quot;hello&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-9-引用类型-3</title>
      <link href="/2019/09/14/Javascript-9-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-3/"/>
      <url>/2019/09/14/Javascript-9-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-3/</url>
      
        <content type="html"><![CDATA[<h4 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h4><p>函数实际上是对象。每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常是使用函数声明语法定义的，例如：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum (num1, num2) &#123;</span><br><span class="line">    return num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用函数表达式定义函数时，没有必要使用函数名。</p><p>另一种定义函数的方式是使用Function构造函数。Function构造函数可以接受任意数量的参数，但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var sum &#x3D; new Fcuntion(&#39;num1&#39;, &#39;num2&#39;, &#39;return num1 + num2&#39;); </span><br><span class="line">&#x2F;&#x2F; 不推荐，因为这种语法会导致解析两次代码(第一次是解析常规JS代码，第二次是解析传入构造函数中的字符串)，从而影响性能。不过，这种语法对于理解‘函数是对象，函数名是指针’的概念到时很直观</span><br></pre></td></tr></table></figure><h6 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h6><p>将函数名想象为指针，也有助与理解为什么JS中没有函数重载的概念。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function addSomeNumber(num) &#123;</span><br><span class="line">    return num + 100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function addSomeNumber(num) &#123;</span><br><span class="line">    return num + 200;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显然这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。</span><br></pre></td></tr></table></figure><h6 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h6><p>解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(sum(10, 10));</span><br><span class="line">function sum(num1, num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升的过程，读取并将函数声明添加到执行环境中。对代码求值时，JS引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面。JS引擎也能把函数声明提升到顶部。</p><p>除了什么时候可以通过变量访问函数这一点区别外，函数声明与函数表达式的语法其实是等价的。</p><h6 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h6><p>因为JS中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function callSomeFunction(someFunction, someArgument) &#123;</span><br><span class="line">    return someFunction(someArgument)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h6><p>在函数内部，有两个特殊的对象：arguments和this。arguments是一个累数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，但这个对象还有一个callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num) &#123;</span><br><span class="line">    if (num &lt;&#x3D; 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num * arguments.callee(num - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数内部的另一个特殊对象是this，其行为与Java和C#中的this大致类似。this引用的是函数执行的环境对象–也可以说是this值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.color &#x3D; &#39;red&#39;</span><br><span class="line">var o &#x3D; &#123; color: &#39;blue&#39; &#125;</span><br><span class="line"></span><br><span class="line">function sayColor() &#123;</span><br><span class="line">    alert(this.color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor(); &#x2F;&#x2F; &#39;red&#39;</span><br><span class="line"></span><br><span class="line">o.sayColor &#x3D; sayColor;</span><br><span class="line">o.sayColor(); &#x2F;&#x2F; &#39;blue&#39;</span><br></pre></td></tr></table></figure><p>JS也规范化了另一个函数对象的属性：caller。这个属性保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function outer() &#123;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function inner() &#123;</span><br><span class="line">    alert(inner.caller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以上代码会导致警告框中显示outer()函数的源代码，因为outer()调用了inner()，所以inner.caller就指向outer()。为了实现更松散的耦合，也可以通过arguments.callee.caller来访问相同的信息。</span><br><span class="line"></span><br><span class="line">function outer() &#123;</span><br><span class="line">    inner()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function inner() &#123;</span><br><span class="line">    alert(arguments.callee.caller)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer()</span><br></pre></td></tr></table></figure><p>当函数在严格模式下运行时，访问arguments.callee和arguments.caller会导致错误。arguments.caller在非严格模式喜爱始终是undefined。严格模式还有一个限制：不能为函数的caller属性赋值，否则会导致错误。</p><h6 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h6><p>JS中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：</p><ul><li>length：函数希望接收的命名参数的个数。</li><li>prototype：保存JS引用类型所有实例方法。不可枚举。</li></ul><p>每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。</p><ul><li>apply()接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组(可以是Array的实例，也可以是arguments对象)。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1, num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function callSum1(num1, num2) &#123;</span><br><span class="line">    return sum.apply(this, arguments); &#x2F;&#x2F; 传入arguments对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function callSum2(num1, num2) &#123;</span><br><span class="line">    return sum.apply(this, [num1, num2]); &#x2F;&#x2F; 传入数组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(callSum1(10, 10)); &#x2F;&#x2F; 20</span><br><span class="line">alert(callSum2(10, 10)); &#x2F;&#x2F; 20</span><br></pre></td></tr></table></figure></li><li>call()：第一个参数是this，后面必须把传递给函数的参数逐个列举出来<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1, num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function callSum(num1, num2) &#123;</span><br><span class="line">    return sum.call(this, num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(callSum(10, 10)); &#x2F;&#x2F; 20</span><br></pre></td></tr></table></figure></li></ul><p>事实上，apply()和call()真正强大的地方是能够扩充函数的作用域，且对象不需要与方法有任何耦合关系。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">window,color &#x3D; &#39;red&#39;</span><br><span class="line">var o &#x3D; &#123; color: &#39;blue&#39; &#125;</span><br><span class="line"></span><br><span class="line">function sayColor() &#123;</span><br><span class="line">    alert(this.color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor(); &#x2F;&#x2F; red</span><br><span class="line"></span><br><span class="line">sayColor.call(this); &#x2F;&#x2F; red</span><br><span class="line">sayColor.call(window); &#x2F;&#x2F; red</span><br><span class="line">sayColor.call(o); &#x2F;&#x2F; blue</span><br></pre></td></tr></table></figure><p>bind()，这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.color &#x3D; &#39;red&#39;</span><br><span class="line">var o &#x3D; &#123; color: &#39;blue&#39; &#125;</span><br><span class="line"></span><br><span class="line">function sayColor() &#123;</span><br><span class="line">    alert(this.color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var objectSayColor &#x3D; sayColor.bind(o)</span><br><span class="line">objectSayColor(); &#x2F;&#x2F; blue</span><br></pre></td></tr></table></figure><p>每个函数继承的toLocaleString()、toString()、valueOf()方法始终都返回函数的代码.</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-9-引用类型-2</title>
      <link href="/2019/09/10/Javascript-9-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-2/"/>
      <url>/2019/09/10/Javascript-9-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-2/</url>
      
        <content type="html"><![CDATA[<h4 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h4><p>Javascript中的Date类型是在早期java中的java.util.Date类基础上构建的。为此，Date类型使用自UTC(Coordinated Universal Time，国际协调时间)1970年1月1日午夜(零时)开始经过的毫秒数来保存日期。在使用这种数据存储格式的条件下，Date类型保存的日期能够精确到1970年1月1日之前或之后的100000000年。</p><a id="more"></a><p>要创建一个日期对象，使用new操作符和Date构造函数即可，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var now &#x3D; new Date();</span><br></pre></td></tr></table></figure><p>在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想要根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数。为了简化这一计算过程，JS提供了：</p><ul><li>Date.parse()，接收一个表示日期的字符串参数，然后尝试根据这个字符串返回响应日期的毫秒数。</li><li>Date.UTC()，参数是年份、基于0的月份、月中的哪一天、小时数、分钟、秒、毫秒数。年和月是必传的。返回表示日期的毫秒数。</li><li>Date.now()，返回表示调用这个方法时的日期和时间的毫秒数。</li></ul><h6 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h6><p>与其他引用类型一样，Date类型也重写了toLocaleString()、toString()、valueOf()方法；但这些方法返回的值与其他类型中的方法不同。</p><ul><li>toLocaleString()，会按照与浏览器设置的地区相适应的格式返回日期和时间。</li><li>toString()，返回带有时区信息的日期和时间。</li><li>valueOf()，返回日期的毫秒表示。</li></ul><h6 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h6><ul><li>toDateString()-以特定于实现的格式显示星期几、月、日和年。</li><li>toTimestring()-以特定于实现的格式显示时、分、秒和时区。</li><li>toLocaleDateString()-以特定于地区的格式显示星期几、月、日和年。</li><li>toLocaleTimeString()-以特定于实现的格式显示时、分、秒。</li><li>toUTCString()-以特定于实现的格式实现完整的UTC日期。</li></ul><h6 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h6><ul><li>getTime() 返回表示日期的毫秒数，与valueOf()方法返回的值相同。</li><li>setTime(毫秒) 以毫秒数设置日期，会改变整个日期。</li><li>getFullYear() 取得四位数的年份。</li><li>getUTCFullYear() 返回UTC日期的4位数年份。</li><li>setFullYear(年) 设置日期年份，传入的年份值必须是四位数。</li><li>setUTCFullYear(年) 设置UTC日期年份，传入的年份值必须是四位数。</li><li>getMonth() 返回日期中的月份，0表示1月，11表示12月。</li><li>getUTCMonth()  返回UTC日期中的月份，0表示1月，11表示12月。</li><li>setMonth(月) 设置日期的月份，传入的月份值必须大于0，超过11则增加年份。</li><li>setUTCMonth(月)  设置UTC日期的月份，传入的月份值必须大于0，超过11则增加年份。</li><li>getDate() 返回日期月份中的天数（1到31）。</li><li>getUTCDate() 返回UTC日期月份中的天数（1到31）。</li><li>setDate(日) 设置日期月份中的天数，如果传入的值超过了该月中应有的天数，则增加月份。</li><li>setUTCDate(日) 设置UTC日期月份中的天数，如果传入的值超过了该月中应有的天数，则增加月份。</li><li>getDay() 返回日期中星期的星期几（0表示星期日，6表示星期六）。</li><li>getUTCDay() 返回UTC日期中星期的星期几（0表示星期日，6表示星期六）。</li><li>getHours() 返回日期中的小时数（0到23）。</li><li>getUTCHours()  返回UTC日期中的小时数（0到23）。</li><li>setHours(时) 设置日期中的小时数，传入的值超过了23则增加月份中的天数。</li><li>setUTCHours(时) 设置UTC日期中的小时数，传入的值超过了23则增加月份中的天数。</li><li>getMinutes() 返回日期中的分钟数（0到59）。</li><li>getUTCMinutes() 返回UTC日期中的分钟数（0到59）。</li><li>setMinutes(分) 设置日期中的分钟数，传入的值超过59则增加小时数。</li><li>setUTCMinutes(分) 设置UTC日期中的分钟数，传入的值超过59则增加小时数。</li><li>getSeconds() 返回日期中的 秒数（0到59）。</li><li>getUTCSeconds() 返回UTC日期中的 秒数（0到59）。</li><li>setSeconds(秒) 设置日期中的秒数，传入的值超过59则增加分钟数。</li><li>setUTCSeconds(秒) 设置UTC日期中的秒数，传入的值超过59则增加分钟数。</li><li>getMilliseconds() 返回日期中的毫秒数。</li><li>getUTCMilliseconds() 返回UTC日期中的毫秒数。</li><li>setMilliseconds(毫秒) 设置日期中的毫秒数。</li><li>setUTCMilliseconds(毫秒) 设置UTC日期中的毫秒数。</li><li>getTimezoneOffset() 返回本地时间与UTC时间相差的毫秒数。</li></ul><h4 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h4><p>JS通过RegExp类型来支持正则表达式。使用下面类似Perl的语法，就可以创建一个正则表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var expression &#x3D; &#x2F; pattern &#x2F; flags;</span><br></pre></td></tr></table></figure><p>其中的模式(pattern)部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可以带有一或多个标志(flags)，泳衣标明正则表达式的行为。正则表达式的匹配模式支持下列3个标志：</p><ul><li>g：表示全局(global)模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止。</li><li>i：表示不区分大小写(case-insensitive)模式，即在确定匹配项时忽略模式和字符串的大小写。</li><li>m：表示多行(multiline)模式，记载到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项，</li></ul><p>一个正则表达式就是一个模式与上述3个标志的组合体。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 匹配字符串中所有“at”的实例 *&#x2F;</span><br><span class="line">var pattern1 &#x3D; &#x2F;at&#x2F;g;</span><br><span class="line"></span><br><span class="line">&#x2F;* 匹配第一个“bat”或“cat”，不区分大小写 *&#x2F;</span><br><span class="line">var pattern2 &#x3D; &#x2F;[bc]at&#x2F;i;</span><br><span class="line"></span><br><span class="line">&#x2F;* 匹配所有以”at“结尾的3个字符的组合，不区分大小写 *&#x2F;</span><br><span class="line">var pattern3 &#x3D; &#x2F;.at&#x2F;gi;</span><br></pre></td></tr></table></figure><p>与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( [ &#123; \ ^ $ | ) ? * + .  ] &#125;</span><br></pre></td></tr></table></figure><p>这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;匹配第一个&quot;bat&quot;或&quot;cat&quot;,不区分大小写</span><br><span class="line">var pattern1&#x3D; &#x2F;[bc]at&#x2F;i;</span><br><span class="line">&#x2F;&#x2F;匹配第一个&quot;[bc]at&quot;,不区分大小写</span><br><span class="line">var pattern2&#x3D; &#x2F;\[bc\]at&#x2F;i;</span><br><span class="line">&#x2F;&#x2F;匹配所有以&quot;at&quot;结尾的3个字符的组合,不区分大小写</span><br><span class="line">var pattern3&#x3D; &#x2F;.at&#x2F;gi;</span><br><span class="line">&#x2F;&#x2F;匹配所有&quot;.at&quot;,不区分大小写</span><br><span class="line">var pattern4&#x3D; &#x2F;\.at&#x2F;gi;</span><br></pre></td></tr></table></figure><p>上面的例子都是以字面量的形式来定义的正则表达式。另一种创建正则表达式的方式是使用RegExp构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。可以使用字面量定义的任何表达式，都可以使用构造函数来定义。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;匹配第一个&quot;bat&quot;或&quot;cat&quot;,不区分大小写</span><br><span class="line">var pattern1&#x3D; &#x2F;[bc]at&#x2F;i;</span><br><span class="line">&#x2F;&#x2F;与pattern1相同,只不过是使用构造函数创建的</span><br><span class="line">var pattern2&#x3D;new RegExp(&quot;[bc]at&quot;,&quot;i&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;*在此,pattern1和pattern2是两个完全相等的正则表达式。*&#x2F;</span><br></pre></td></tr></table></figure><ul><li><p>要注意的是，传递给RegExp构造函数的两个参数都是字符串。</p></li><li><p>由于RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符串进行转义。</p></li><li><p>所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如\n（字符\在字符串中通常被转义为\,而在正则表达式字符串中就会变成\\）。</p><div class="table-box"><table><thead><tr><th>字符量模式</th><th>等价的字符串</th></tr></thead><tbody><tr><td><code>/\[bc\]at/</code></td><td><code>"\\[bc\\]at"</code></td></tr><tr><td><code>/\.at/</code></td><td><code>"\\.at"</code></td></tr><tr><td><code>/name\/age/</code></td><td><code>"name\\/age"</code></td></tr><tr><td><code>/\d.\d{1,2}/</code></td><td><code>"\\d.\\d{1,2}"</code></td></tr><tr><td><code>/\w\\hello\\123/</code></td><td><code>"\\w\\\\hello\\\\123"</code></td></tr></tbody></table></div></li></ul><h6 id="RegExp实例属性"><a href="#RegExp实例属性" class="headerlink" title="RegExp实例属性"></a>RegExp实例属性</h6><ul><li>global：布尔值，表示是否设置了g标志。</li><li>ignoreCase：布尔值，表示是否设置了i标志。</li><li>lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。</li><li>multiline：布尔值，表示是否设置了m标志。</li><li>source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var pattern1&#x3D; &#x2F;\[bc\]at&#x2F;i;</span><br><span class="line">alert(pattern1.global);       &#x2F;&#x2F;false</span><br><span class="line">alert(pattern1.ignoreCasr);  &#x2F;&#x2F;true</span><br><span class="line">alert(pattern1.multiline);   &#x2F;&#x2F;false</span><br><span class="line">alert(pattern1.laastIndex);  &#x2F;&#x2F;0</span><br><span class="line">alert(pattern1.source);      &#x2F;&#x2F;&quot;\[bc\]at&quot;</span><br><span class="line"></span><br><span class="line">var pattern2&#x3D;new RegExp(&quot;\\[bc\\]at&quot;,&quot;i&quot;);</span><br><span class="line">alert(pattern2.global);      &#x2F;&#x2F;false</span><br><span class="line">alert(pattern2.ignoreCase);  &#x2F;&#x2F;true</span><br><span class="line">alert(pattern2.multiline);   &#x2F;&#x2F;false</span><br><span class="line">alert(pattern2.lastIndex);  &#x2F;&#x2F;0</span><br><span class="line">alert(pattern2.source);     &#x2F;&#x2F;&quot;\[bc\]at&quot;</span><br><span class="line">&#x2F;&#x2F;source属性保存的是规范形式的字符串，即字面量形式所用的字符串</span><br></pre></td></tr></table></figure><h6 id="RegExp实例方法"><a href="#RegExp实例方法" class="headerlink" title="RegExp实例方法"></a>RegExp实例方法</h6><p>RegExp对象的主要方法是exec()，该方法是专门为捕获组设置的。exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var text&#x3D; &quot;mom and dad and baby&quot;;</span><br><span class="line">var pattern&#x3D; &#x2F;mom( and dad( and baby)?)?&#x2F;gi;</span><br><span class="line">var matches&#x3D;pattern.exec(text);</span><br><span class="line">alert(matches.index);  &#x2F;&#x2F;0</span><br><span class="line">alert(matches.input);  &#x2F;&#x2F;&quot;mom and dad and baby&quot;</span><br><span class="line">alert(matches[0]);  &#x2F;&#x2F;&quot;mom and dad and baby&quot;</span><br><span class="line">alert(matches[1]);  &#x2F;&#x2F;&quot; and  dad and baby&quot;</span><br><span class="line">alert(matches[2]);  &#x2F;&#x2F;&quot; and baby&quot; </span><br><span class="line">&#x2F;*这个例子中的模式包含两个捕获组。最内部的捕获组匹 配&quot;and baby&quot;,而包含它的捕获组匹配&quot;and dad&quot;或者&quot;and dad and baby&quot;。当把字符串传入exec()方法中之后,发现了一个匹配项。因为整个字符串本身与模式匹配,所以返回的数组matches的index属性值为0。数组中大的第一项是匹配的整个字符串，第二项包含与第一个捕获组匹配的内容，第三项包含与第二个捕获组匹配的内容*&#x2F;</span><br></pre></td></tr></table></figure><p>对于exec()方法而言，即使在全局模式中设置了全局标志(g)，它每次也只会返回一个匹配项项。在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()都会在字符串中继续查找新匹配项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var text&#x3D;&quot;cat,bat,sat,fat&quot;;</span><br><span class="line">var pattern1&#x3D;&#x2F;.at&#x2F;;</span><br><span class="line"></span><br><span class="line">var matches&#x3D;pattern1.exec(text);</span><br><span class="line">alert(matches.index);&#x2F;&#x2F;0</span><br><span class="line">alert(matches[0]);&#x2F;&#x2F;cat</span><br><span class="line">alert(pattern1.lastIndex);&#x2F;&#x2F;0</span><br><span class="line"></span><br><span class="line">matches&#x3D;pattern1.exec(text);</span><br><span class="line">alert(matches.index);&#x2F;&#x2F;0</span><br><span class="line">alert(matches[0]);&#x2F;&#x2F;cat</span><br><span class="line">alert(pattern1.lastIndex);&#x2F;&#x2F;0</span><br><span class="line"></span><br><span class="line">var pattern2&#x3D; &#x2F;.at&#x2F;g;</span><br><span class="line">var matches&#x3D;pattern2.exec(text);</span><br><span class="line">alert(matches.index);&#x2F;&#x2F;0</span><br><span class="line">alert(matches[0]);&#x2F;&#x2F;cat</span><br><span class="line">alert(pattern2.lastIndex);&#x2F;&#x2F;3</span><br><span class="line"></span><br><span class="line">matches&#x3D;pattern2.exec(text);</span><br><span class="line">alert(matches.index);&#x2F;&#x2F;5</span><br><span class="line">alert(matches[0]);&#x2F;&#x2F;bat</span><br><span class="line">alert(pattern2.lastIndex);&#x2F;&#x2F;8</span><br></pre></td></tr></table></figure><p>正则表达式的第二个方法是test()，它接受一个字符串参数。在模式与该参数匹配的情况喜爱返回true；否则，返回false。在只想知道目标字符串与某个模式是否匹配，但不需知道其文本内容的情况下，使用这个方法非常方便。因此，test()方法经常被用在if语句中，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var text&#x3D;&quot;000-00-0000&quot;;</span><br><span class="line">var pattern&#x3D;&#x2F;\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;&#x2F;;</span><br><span class="line">&#x2F;&#x2F;test()方法经常被用在if语句中</span><br><span class="line">if(pattern.test(text))&#123;</span><br><span class="line">alert(&quot;The pattern was matched&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RegExp实例继承toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关.例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var pattern&#x3D;new RegExp(&quot;\\[bc\\]at&quot;,&quot;gi&quot;);</span><br><span class="line">alert(pattern.toString());&#x2F;&#x2F; &#x2F;\[bc\]at&#x2F;gi</span><br><span class="line">alert(pattern.toLocaleString());&#x2F;&#x2F; &#x2F;\[bc\]at&#x2F;gi</span><br></pre></td></tr></table></figure><h6 id="RegExp构造函数属性"><a href="#RegExp构造函数属性" class="headerlink" title="RegExp构造函数属性"></a>RegExp构造函数属性</h6><p>RegExp构造函数包含一些属性(这些属性在其他语言中被看成是静态属性)。这些属性适用于作用域中的所有正则表达式，并且基于所执行的最后一次正则表达式操作而变化。关于这些属性的另一个独特之处，就是可以通过两种方式访问它们。</p><div class="table-box"><table><thead><tr><th>长属性名</th><th>短属性名</th><th>说明</th></tr></thead><tbody><tr><td><code>input</code></td><td><code>$_</code></td><td>最近一次要匹配的字符串。Opera为实现此属性</td></tr><tr><td><code>lastMatch</code></td><td><code>$&amp;</code></td><td>最近一次的匹配项。Opera未实现此属性</td></tr><tr><td><code>|lastParen</code></td><td><code>$+</code></td><td>最近一次匹配的捕获组。Opera为实现此属性</td></tr><tr><td><code>leftContext</code></td><td><code>$</code></td><td><code>input</code>字符串中<code>lastMatch</code>之前的文本</td></tr><tr><td><code>multiline</code></td><td><code>$*</code></td><td>布尔值，表示是否所有表达式都使用多行模式。IE和Opera未实现此属性</td></tr><tr><td><code>rightContext</code></td><td><code>$'</code></td><td><code>Input</code>字符串中<code>lastMatch</code>之后的文本</td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var text&#x3D;&quot;this has been a short summer&quot;;</span><br><span class="line">var pattern&#x3D; &#x2F;(.)hort&#x2F;g;</span><br><span class="line">&#x2F;*</span><br><span class="line">*注意：Opera不支持input、lastMatch、lastParen和multiline属性</span><br><span class="line">*Internet Explorer不支持multiline属性</span><br><span class="line">*&#x2F;</span><br><span class="line">if(pattern.test(text))&#123;</span><br><span class="line">alert(RegExp.input);  &#x2F;&#x2F;this has been a short  summer</span><br><span class="line">alert(RegExp.leftContext);  &#x2F;&#x2F;this has been a</span><br><span class="line">alert(RegExp.rightContext); &#x2F;&#x2F;summer</span><br><span class="line">alert(RegExp.lastMatch);  &#x2F;&#x2F;short</span><br><span class="line">alert(RegExp.lastParen);  &#x2F;&#x2F;s</span><br><span class="line">alert(RegExp.multiline);  &#x2F;&#x2F;flase</span><br><span class="line">&#x2F;*以上代码创建了一个模式，匹配任何一个字符串后跟hort，而且把第一个字符放在了一个捕获组中*&#x2F;</span><br></pre></td></tr></table></figure><p>RegExp构造函数的各个属性返回了下列值：</p><ul><li>input属性返回了原始字符串。</li><li>leftContext属性返回了单词short之前的字符串，而rightContext属性则返回了short属性之后的字符串；</li><li>lastMatch属性返回最近一次与整个表达式匹配的字符串，即short；</li><li>lastParen属性返回最近一次匹配的捕获组。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*例子中的长属性名都可以用相应的短属性名来代替。只不过，由于这些短属性名大都不是有效的ECMAScript标识符，因此必须通过方括号语法来访问它们*&#x2F;</span><br><span class="line">var text&#x3D;&quot;this has been a short summer&quot;;</span><br><span class="line">var pattern&#x3D; &#x2F;(.)hort&#x2F;g;</span><br><span class="line">&#x2F;*</span><br><span class="line">*注意：Opera不支持input、lastMatch、lastParen和multiline属性</span><br><span class="line">*Internet Explorer不支持multiline属性</span><br><span class="line">*&#x2F;</span><br><span class="line">if(pattern.test(text))&#123;</span><br><span class="line">alert(RegExp.$_);  &#x2F;&#x2F;this has been a short summer</span><br><span class="line">alert(RegExp[&quot;$&#96;&quot;]);  &#x2F;&#x2F;this has been a</span><br><span class="line">alert(RegExp[&quot;$&#39;&quot;]);  &#x2F;&#x2F;summer</span><br><span class="line">alert(RegExp[&quot;$&amp;&quot;]);  &#x2F;&#x2F;short</span><br><span class="line">alert(RegExp[&quot;$+&quot;]);  &#x2F;&#x2F;s</span><br><span class="line">alert(RegExp[&quot;$*&quot;]);  &#x2F;&#x2F;false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="模式的局限性"><a href="#模式的局限性" class="headerlink" title="模式的局限性"></a>模式的局限性</h6><p>尽管JS中的正则表达式功能还比较完备，但仍然缺少某些语言(特别是Perl)所支持的高级正则表达式特性。</p><ul><li>匹配字符串开始和结尾的\A和\Z锚。</li><li>向后查找(lookbehind)</li><li>并集和交集类</li><li>原子组(atomic grouping)</li><li>Unicode支持(单个字符除外，如\uFFFF)</li><li>命名的捕获组</li><li>s(single，单行)和x(free-spacing，无间隔)匹配模式</li><li>条件匹配</li><li>正则表达式注释</li></ul><p>即使存在这些限制，ECMAScript正则表达式仍然是非常强大的，能够帮助我们完成绝大多数模式匹配任务</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-9-引用类型-1</title>
      <link href="/2019/09/02/Javascript-9-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-1/"/>
      <url>/2019/09/02/Javascript-9-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-1/</url>
      
        <content type="html"><![CDATA[<p>引用类型的值(对象)是引用类型的一个实例。在Javascript中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管Javascript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等接本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。</p><p>对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的。构造函数本身就是一个函数，只不过该函数是出于创建新对象的母的而定义的。</p><a id="more"></a><h4 id="1，Object类型"><a href="#1，Object类型" class="headerlink" title="1，Object类型"></a>1，Object类型</h4><p>我们看到的大多数引用类型值都是Object类型的实例；而且，object也是Javascript中国呢使用最多的一个实例。</p><p>创建Object实例的方式有两种。第一种是使用new操作符后跟Object构造函数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person  &#x3D; new Object();</span><br><span class="line">person.name &#x3D; &quot;ZhangSan&quot;;</span><br><span class="line">person.age &#x3D; 18;</span><br></pre></td></tr></table></figure><p>另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">    name: &quot;ZhangSan&quot;,</span><br><span class="line">    age: 18</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用对象字面量语法时，如果留空其花括号，则可以定义只包含默认属性和方法的对象，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;&#125;;</span><br><span class="line">person.name &#x3D; &quot;ZhangSan&quot;;</span><br><span class="line">person.age &#x3D; 18;</span><br></pre></td></tr></table></figure><h4 id="2，Array类型"><a href="#2，Array类型" class="headerlink" title="2，Array类型"></a>2，Array类型</h4><p>虽然Javascript数组与其他语言中的数组都是数据的有序列表，但与其他语言不同的是，Javascript数组的每一项可以保存任何类型的数据。而且Javascript数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。</p><p>创建数组的基本方式有两种，第一种是使用Array构造函数。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var colors &#x3D; new Array();</span><br></pre></td></tr></table></figure><p>第二种基本方式是使用数组字面量表示法。数组字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var colors &#x3D; [&quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;];</span><br><span class="line">var name &#x3D; [];</span><br></pre></td></tr></table></figure><p>在读取和设置数组的值时，要使用方括号并提供相应值的基于0的数字索引，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var colors &#x3D; [&quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;];</span><br><span class="line">alert(colors[0]);</span><br><span class="line">colors[2] &#x3D; &quot;black&quot;;</span><br><span class="line">colors[3] &#x3D; &quot;brown&quot;;</span><br></pre></td></tr></table></figure><p>方括号中的索引表示要访问的值。数组的项数保存在其length属性总，这个属性始终会返回0或更大的值。length属性不是只读的，通过设置这个属性，可以从数组的末尾移除项或向数组添加新项。</p><h6 id="a，检测数组"><a href="#a，检测数组" class="headerlink" title="a，检测数组"></a>a，检测数组</h6><p>对于一个网页或者一个全局作用域而言，使用instanceof操作符就能得到满意的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (value instanceof Array) &#123;</span><br><span class="line">    &#x2F;&#x2F; 对数组执行操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>instanceof操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果你从一个框架向另外一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。</p><p>为了解决这个问题，Javascript5新增了Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (Array.isArray(value)) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="b，转换方法"><a href="#b，转换方法" class="headerlink" title="b，转换方法"></a>b，转换方法</h6><p>所有对象都具有toLocaleString()、toString()和valueOf()方法。其中，调用valueOf()返回的是数组本身，而调用数组的toString()方法会返回由数组中每个值的字符串形式拼接而来的一个以逗号分割的字符串。实际上，为了创建这个字符串会调用数组每一项的toString()方法。</p><h6 id="c，栈方法"><a href="#c，栈方法" class="headerlink" title="c，栈方法"></a>c，栈方法</h6><p>Javascript数组也提供了一种让数组的行为类似于其他数据结构的方法。具体来说，数组可以表现得就像栈一样，后者是一种可以限制插入和删除项的数据结构。栈是一种LIFO(Last-In-First-Out， 后进先出)的数据结构，也就是最新添加的项最早被移除。而栈中项的插入(推入)和移除(弹出)，只发生在一个位置-栈的顶部。Javascript为数组专门提供了push()和pop()方法，以便实现类似栈的行为。</p><ul><li>push()，尾部添加并返回修改后数组的长度。</li><li>pop()，尾部删除并返回移除的项。</li></ul><h6 id="d，队列方法"><a href="#d，队列方法" class="headerlink" title="d，队列方法"></a>d，队列方法</h6><p>队列数据结构的访问规则是FIFO(First-In-First-Out，先进先出)。</p><ul><li>shift()，首部移除并返回该项。<ul><li>unshift()，首部添加并返回新数组的长度。</li></ul></li></ul><h6 id="e，重排序方法"><a href="#e，重排序方法" class="headerlink" title="e，重排序方法"></a>e，重排序方法</h6><ul><li><p>reverse()，反转数组项的顺序。</p></li><li><p>sort()，升序排列数组项。</p><p>它们的返回值都是经过排序之后的数组。</p></li></ul><h6 id="f，操作方法"><a href="#f，操作方法" class="headerlink" title="f，操作方法"></a>f，操作方法</h6><ul><li><p>concat()，合并数组返回新数组。</p></li><li><p>slice()，可以接受一个或两个参数，即要返回项的其实和结束位置。只有一个参数时，返回从该参数指定位置开始到当前数组末尾的所有项。有两个参数时，返回起始和结束位置之间的项，但不包括结束位置的项。不会影响原始数组。</p></li><li><p>splice()，可以删除任意数量的项，只需指定两个参数；要删除的第一项的位置和要删除的项数。可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0(要删除的项数)、要插入的项。可以项指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起始位置，要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。</p><h6 id="g，位置方法"><a href="#g，位置方法" class="headerlink" title="g，位置方法"></a>g，位置方法</h6><p>indexOf()和lastIndexOf()。这两个方法都接受两个参数：要查找的项和表示查找起点位置的索引(可选)。其中，indexOf()方法从数组的开头开始向后查找，lastIndexOf()从数组的末尾开始向前查找。</p><p>这两个方法都返回要查找的项在数组中的位置，或者在没有找到的情况下返回-1.在比较第一个参数与数组中的每一项时，会使用全等操作符；也就是说，要求查找的项必须严格相等。</p><h6 id="h，迭代方法"><a href="#h，迭代方法" class="headerlink" title="h，迭代方法"></a>h，迭代方法</h6><p>Javascript为数组定义了5个迭代方法。每个方法都接受2个参数：要在每一项上运行的函数和运行该函数的作用域对象(可选)–影响this的值。</p><ul><li>every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。</li><li>filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。</li><li>forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。</li><li>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li><li>some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。</li></ul></li></ul><p>以上方法都不会修改数组中的包含的值。</p><h6 id="i，归并方法"><a href="#i，归并方法" class="headerlink" title="i，归并方法"></a>i，归并方法</h6><p>reduce()和reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后，而erduceRight()方法则从数组的最后一项开始，向前遍历到第一项。</p><p>这两个方法都接受两个参数：一个在每一项上调用的函数和作为归并基础的初始值(可选)。传给reduce()和reduceRight()的函数接受4个参数：前一个值、当前值、项的索引、数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一个项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项。第二个参数是数组的第二项。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-8-垃圾收集</title>
      <link href="/2019/09/01/Javascript-8-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"/>
      <url>/2019/09/01/Javascript-8-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>Javascript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔(或代码执行中预定的收集时间)，周期性地执行这一操作。</p><a id="more"></a><h4 id="1，标记清除"><a href="#1，标记清除" class="headerlink" title="1，标记清除"></a>1，标记清除</h4><p>Javascript中最常用的垃圾收集方式是标记清除。当变量进入环境时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p><p>垃圾收集器在运行的时候会给存储在内存中的所有变量加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p><h4 id="2，引用计数"><a href="#2，引用计数" class="headerlink" title="2，引用计数"></a>2，引用计数</h4><p>引用计数的含义是跟踪记录每个值被引用次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1.当这个值的引用次数变成0时，则说明没有办法在访问这个值了，因此就可以将其占用的内存空间收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。</p><p>引用计数有一个很严重的问题就是循环引用。IE中有一部分对象并不是原生JAvascript对象。例如其中BOM和DOM中的对象就是使用C++以COM(组件对象模型)对象的形式实现的，而COM对象的垃圾收集机制采用的就是引用计数策略。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。只要在IE中涉及COM对象，就会存在循环引用的问题。</p><p>为了解决上述问题，IE9把BOM和DOM对象都转换成真正的Javascript对象。这样就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。</p><h4 id="3，性能问题"><a href="#3，性能问题" class="headerlink" title="3，性能问题"></a>3，性能问题</h4><p>垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。这个就联想到IE当初的性能问题。为此促使IE7重写了其垃圾收集例程。</p><p>随着IE7的发布，其Javascript引擎的垃圾收集例程改变了工作方式：触发垃圾收集的变量分配、字面量和数组元素的临界值被调整为动态修正。</p><h4 id="4，管理内存"><a href="#4，管理内存" class="headerlink" title="4，管理内存"></a>4，管理内存</h4><p>Javascript在进行内存管理及垃圾收集时面临的最主要一个问题就是分配给Web浏览器的可用内存数量通常要比分配给卓明应用程序的少。这样做的主要目的是出于安全方面的考虑，防止运行Javascript的网页耗尽全部系统内存而导致系统崩溃。</p><p>因此，确保占用最少的内存可以让页面获得更好的性能。而优化性能占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设为null来释放其引用，这个做法叫做解除引用。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用。</p><p>不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-7-执行环境及作用域</title>
      <link href="/2019/08/31/javascript-7-%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2019/08/31/javascript-7-%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>执行环境是Javascript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。</p><a id="more"></a><p>全剧执行环境是最外围的一个执行环境。在Web浏览器中，全局执行环境被认为是Window对象，因此所有全局变量和函数都是作为Window对象的属性和方法创建的。</p><p>每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。</p><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象(这个对象在全局环境中是不存在的)。作用域链中的下一个变量对象来自包含环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p><p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，知道找到标识符为止(如果找不到标识符，通常会导致错误发生)。</p><p>内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。</p><h4 id="1，延长作用域链"><a href="#1，延长作用域链" class="headerlink" title="1，延长作用域链"></a>1，延长作用域链</h4><p>虽然执行环境的类型总共只有两种—全局和局部，但还是有其他办法来延长作用域链。因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。</p><p>当执行流进入下列任何一个语句时，作用域链就会得到加长：</p><ul><li>try-catch语句的catch块</li><li>with语句</li></ul><p>这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会被指定的对西那个添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP响应状态码说明</title>
      <link href="/2019/08/30/HTTP%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81%E8%AF%B4%E6%98%8E/"/>
      <url>/2019/08/30/HTTP%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>响应状态码表示服务器的响应状态，如 200 代表服务器正常响应，404 代表页面未找到，500 代表服务器内部发生错误。在爬虫中，我们可以根据状态码来判断服务器响应状态，如状态码为 200，则证明成功返回数据，再进行进一步的处理，否则直接忽略。下表列出了常见的错误代码及错误原因。</p><a id="more"></a><table style="text-align:center;"><thead style="text-align:center;"><tr style="text-align:center;"><th>状态码</th><th>说明</th><th>详情</th></tr></thead><tbody><tr><td><code>100</code></td><td><code>继续</code></td><td><code>请求者应当继续提出请求。服务器已收到请求的一部分，正在等待其余部分</code></td></tr><tr><td><code>101</code></td><td><code>切换协议</code></td><td><code>请求者已要求服务器切换协议，服务器已确认并准备切换</code></td></tr><tr><td><code>200</td><td><code>成功</code></td><td><code>服务器已成功处理了请求</code></td></tr><tr><td><code>201</code></td><td><code>已创建</code></td><td><code>请求成功并且服务器创建了新的资源</code></td></tr><tr><td><code>202</code></td><td><code>已接受</code></td><td><code>服务器已接受请求，但尚未处理</code></td></tr><tr><td><code>203</code></td><td><code>非授权信息</code></td><td><code>服务器已成功处理了请求，但返回的信息可能来自另一个源</code></td></tr><tr><td><code>204</code></td><td><code>无内容</code></td><td><code>服务器成功处理了请求，但没有返回任何内容</code></td></tr><td><code>205</code></td><td><code>重置内容</code></td><td><code>服务器成功处理了请求，内容被重置</code></td></tr><tr><td><code>206</code></td><td><code>部分内容</code></td><td><code>服务器成功处理了部分请求</code></td></tr><tr><td><code>300</code></td><td><code>多种选择</code></td><td><code>针对请求，服务器可执行多种操作</code></td></tr><tr><td><code>301</code></td><td><code>永久移动</code></td><td><code>请求的网页已永久移动到新位置，即永久重定向</code></td></tr><tr><td><code>302</code></td><td><code>临时移动</code></td><td><code>请求的网页暂时跳转到其他页面，即暂时重定向</code></td></tr><tr><tr><td><code>303</code></td><td><code>查看其他位置</code></td><td><code>如果原来的请求是POST，重定向目标文档应该通过GET提取</code></td></tr><tr><td><code>304</code></td><td><code>未修改</code></td><td><code>此次请求返回的网页未修改，继续使用上次的资源</code></td></tr><tr><td><code>305</code></td><td><code>使用代理</code></td><td><code>请求者应该使用代理访问该网页</code></td></tr><tr><td><code>307</code></td><td><code>临时重定向</code></td><td><code>请求的资源临时从其他位置响应</code></td></tr><tr><td><code>400</code></td><td><code>错误请求</code></td><td><code>服务器无法解析该请求</code></td></tr><tr><td><code>401</code></td><td><code>未授权</code></td><td><code>请求没有进行身份验证或验证未通过</code></td></tr><tr><td><code>403</code></td><td><code>禁止访问</code></td><td><code>服务器拒绝此请求</code></td></tr><tr><td><code>404</code></td><td><code>未找到</code></td><td><code>服务器找不到请求的网页</code></td></tr><tr><td><code>405</code></td><td><code>方法禁用</code></td><td><code>服务器禁用了请求中指定的方法</code></td></tr><tr><td><code>406</code></td><td><code>不接受</code></td><td><code>无法使用请求的内容响应请求的网页</code></td></tr><tr><td><code>407</code></td><td><code>需要代理授权</code></td><td><code>请求者需要使用代理授权</code></td></tr><tr><td><code>408</code></td><td><code>请求超时</code></td><td><code>服务器请求超时</code></td></tr><tr><td><code>409</code></td><td><code>冲突</code></td><td><code>服务器在完成请求时发生冲突</code></td></tr><tr><td><code>410</code></td><td><code>已删除</code></td><td><code>请求的资源已永久删除</code></td></tr><tr><td><code>411</code></td><td><code>需要有效长度</code></td><td><code>服务器不接受不含有效内容长度标头字段的请求</code></td></tr><tr><td><code>412</code></td><td><code>未满足前提条件</code></td><td><code>服务器未满足请求者在请求中设置的其中一个前提条件</code></td></tr><tr><td><code>413</code></td><td><code>请求实体过大</code></td><td><code>请求实体过大，超出服务器的处理能力</code></td></tr><tr><td><code>414</code></td><td><code>请求URI过长</code></td><td><code>请求网址过长，服务器无法处理</code></td></tr><tr><td><code>415</code></td><td><code>不支持类型</code></td><td><code>请求格式不被请求页面支持</code></td></tr><tr><td><code>416</code></td><td><code>请求范围不符</code></td><td><code>页面无法提供请求的范围</code></td></tr><tr><td><code>417</code></td><td><code>未满足期望值</code></td><td><code>服务器未满足期望请求标头字段的要求</code></td></tr><tr><td><code>500</code></td><td><code>服务器内部错误</code></td><td><code>服务器遇到错误，无法完成请求</code></td></tr><tr><td><code>501</code></td><td><code>未实现</code></td><td><code>服务器不具备完成请求的功能</code></td></tr><tr><td><code>502</code></td><td><code>错误网关</code></td><td><code>服务器作为网管或代理，从上游服务器收到无效响应</code></td></tr><tr><td><code>503</code></td><td><code>服务不可用</code></td><td><code>服务器目前无法使用</code></td></tr><tr><td><code>504</code></td><td><code>网关超时</code></td><td><code>服务器作为网关或代理，但是没有及时从上游服务器收到请求</code></td></tr><tr><td><code>505</code></td><td><code>HTTP版本不支持</code></td><td><code>服务器不支持请求中所用的HTTP协议版本</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-6-基本类型和引用类型的值</title>
      <link href="/2019/08/28/Javascript-6-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC/"/>
      <url>/2019/08/28/Javascript-6-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>Javascript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。</p><p>基本数据类型：undefined，Null，Boolean，Number，String这五种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。</p><p>引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的(在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。 ECMAScript 放弃了这一传统。<br>① 这种说法不严密，当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际<br>的对象。——图灵社区“壮壮的前端之路”注)。</p><a id="more"></a><h4 id="1，动态的属性"><a href="#1，动态的属性" class="headerlink" title="1，动态的属性"></a>1，动态的属性</h4><p>定义基本类型值和引用类型值的方式是类似的：创建一个变量并为该变量赋值。但是，当这个值保存到变量中以后，对不同类型值可以执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。请看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; new Object();</span><br><span class="line">person.name &#x3D; &quot;Nicholas&quot;;</span><br><span class="line">alert(person.name); &#x2F;&#x2F;&quot;Nicholas</span><br></pre></td></tr></table></figure><p>以上代码创建了一个对象并将其保存在了变量person 中。然后，我们为该对象添加了一个名为name 的属性，并将字符串值”Nicholas”赋给了这个属性。紧接着，又通过alert()函数访问了这个新属性。如果对象不被销毁或者这个属性不被删除，则这个属性将一直存在。但是，我们不能给基本类型的值添加属性，尽管这样做不会导致任何错误。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &quot;Nicholas&quot;;</span><br><span class="line">name.age &#x3D; 27;</span><br><span class="line">alert(name.age); &#x2F;&#x2F;undefined</span><br></pre></td></tr></table></figure><p>在这个例子中，我们为字符串name 定义了一个名为age 的属性，并为该属性赋值27。但在下一行访问这个属性时，发现该属性不见了。这说明只能给引用类型值动态地添加属性，以便将来使用。</p><h4 id="2，复制变量值"><a href="#2，复制变量值" class="headerlink" title="2，复制变量值"></a>2，复制变量值</h4><p>除了保持的方式不同之外，在从一个变量向另一个变量复制基本类型和引用类型的值时，也存在不同。如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到位新变量分配的位置上；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num1&#x3D;5;</span><br><span class="line">var num2&#x3D;num1;</span><br></pre></td></tr></table></figure><p>在此num1种保存的值是5.当使用num1的值来初始化num2时，num2中也保存了值5。但num2中的5与num1中的5是完全独立的。该值只是num1中5的一个副本。此后，这两个变量可以参与任何操作互不影响。我觉得这一点和其他高级语言很相似例如java。<br>当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份到为新变量分配的空间中。不同的是们这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象，复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响到另一个变量。这个跟引用类型的存储位置有关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var obj1&#x3D;new Object();</span><br><span class="line">var obj2&#x3D;obj1;</span><br><span class="line">obj1.name&#x3D;&quot;Lucy&quot;;</span><br><span class="line">alert(obj2.name);</span><br></pre></td></tr></table></figure><p>打印出来的是Lucy，这是因为obj1和obj2是两个引用，这两个引用指向的值都是Object();我们操作值的时候是通过引用的，当我们的对象发生改变的，其引用的值也发生了改变；</p><h4 id="3，传递参数"><a href="#3，传递参数" class="headerlink" title="3，传递参数"></a>3，传递参数</h4><p>ECMAScript 中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。有不少开发人员在这一点上可能会感到困惑，因为访问变量有按值和按引用两种方式，而参数只能按值传递。</p><p>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript 的概念来说，就是arguments 对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。请看下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function addTen(num) &#123;</span><br><span class="line">num +&#x3D; 10;</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line">var count &#x3D; 20;</span><br><span class="line">var result &#x3D; addTen(count);</span><br><span class="line">alert(count); &#x2F;&#x2F;20，没有变化</span><br><span class="line">alert(result); &#x2F;&#x2F;30</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-5-语句</title>
      <link href="/2019/08/24/Javascript-5-%E8%AF%AD%E5%8F%A5/"/>
      <url>/2019/08/24/Javascript-5-%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>从本质上看，语句定义了Javascript中的主要语法，语句通常使用一个或多个关键字来完成给定任务。</p><a id="more"></a><h4 id="1，if语句"><a href="#1，if语句" class="headerlink" title="1，if语句"></a>1，if语句</h4><p>if语句是我们最常用的，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (status) methods1 else methods2</span><br></pre></td></tr></table></figure><p>其中的status可以是任意表达式，而且对这个表达式求值的结果不一定是布尔值。Javascript会自动调用Boolean()函数将结果转换为一个布尔值，</p><p>推荐的写法是代码块，即使要执行的只有一行代码。因为这样可以结构清晰的看出在不同条件下执行哪些语句。</p><h4 id="2，do-while语句"><a href="#2，do-while语句" class="headerlink" title="2，do-while语句"></a>2，do-while语句</h4><p>do-while语句是后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123; </span><br><span class="line">    methods1</span><br><span class="line">&#125; while (status)</span><br></pre></td></tr></table></figure><h4 id="3，while语句"><a href="#3，while语句" class="headerlink" title="3，while语句"></a>3，while语句</h4><p>while语句属于前测试循环语句，即在循环体内的代码被执行之前，就会对出口条件求值，因此，循环体内的代码有可能永远不会被执行。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while (status) methods1</span><br></pre></td></tr></table></figure><h4 id="4，for语句"><a href="#4，for语句" class="headerlink" title="4，for语句"></a>4，for语句</h4><p>for语句也是前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (initialization; expression; post-loop-expression) methods1</span><br></pre></td></tr></table></figure><p>for语句中的初始化表达式、控制表达式、循环后表达式都是可选的。将这三个表达式都省略，就会创建一个无限循环,例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (;;) &#123;</span><br><span class="line">    methods1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5，for-in语句"><a href="#5，for-in语句" class="headerlink" title="5，for-in语句"></a>5，for-in语句</h4><p>for-in语句是一种迭代语句，可以用来枚举对象的属性。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i in arr) &#123;</span><br><span class="line">    methods1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6，label语句"><a href="#6，label语句" class="headerlink" title="6，label语句"></a>6，label语句</h4><p>label语句可以在代码中添加标签，以便将来使用，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start: for (var i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">    alert(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7，break和continue语句"><a href="#7，break和continue语句" class="headerlink" title="7，break和continue语句"></a>7，break和continue语句</h4><p>break和continue语句用于在循环中精确的控制代码的执行。其中break语句会立即退出循环，强制继续执行循环后面的语句。而continue语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。</p><p>break例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 0;</span><br><span class="line">for (var i &#x3D; 1; i &lt; 10; i++) &#123;</span><br><span class="line">    if (i % 5 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br><span class="line">alert(num); &#x2F;&#x2F; 4</span><br></pre></td></tr></table></figure><p>continue例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 0;</span><br><span class="line">for(var i &#x3D; 1; i &lt; 10; i++) &#123;</span><br><span class="line">    if (i % 5 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br><span class="line">alert(num); &#x2F;&#x2F; 8</span><br></pre></td></tr></table></figure><h4 id="8，with语句"><a href="#8，with语句" class="headerlink" title="8，with语句"></a>8，with语句</h4><p>with语句的作用是将代码的作用域设置到一个特定的对象中。定义with语句的目的主要是为了简化多次编写同一个对象的工作，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var qs &#x3D; location.search.substring(1);</span><br><span class="line">var hostName &#x3D; location.hostname;</span><br><span class="line">var url &#x3D; location.href;</span><br></pre></td></tr></table></figure><p>上面几行代码都包含location对象，如果使用with语句，可以把上面的代码改写成如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">with(location) &#123;</span><br><span class="line">    var qs &#x3D; search.substring(1);</span><br><span class="line">    var hostName  &#x3D; hostname;</span><br><span class="line">    var url &#x3D; href;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">严格模式下不允许使用with语句，否则将视为语法错误。</span><br></pre></td></tr></table></figure><h4 id="9，switch语句"><a href="#9，switch语句" class="headerlink" title="9，switch语句"></a>9，switch语句</h4><p>switch语句与if语句的关系最为密切，而且也是在其他语言中普遍使用的一种流控制语句。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">switch(expression) &#123;</span><br><span class="line">    case value: statement</span><br><span class="line">        break;</span><br><span class="line">    case value: statement</span><br><span class="line">        break;</span><br><span class="line">    default: statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch语句中的每一种情形的含义是“如果表达式等于这个值，则执行后面的语句”，而break关键字会导致代码执行流跳出switch语句。如果省略break关键字就会导致执行完当前case后，继续执行下一个case，最后的default关键字则用于在表达式不匹配前面任何一种情形的时候，执行激动代码。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-4-操作符</title>
      <link href="/2019/08/23/Javascript-4-%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2019/08/23/Javascript-4-%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>操作符，用于操作数据值，包括算术操作符、位操作符、关系操作符和相等操作符。它们能够适用于很多值，例如字符串、数字值、布尔值、甚至对象。不过，在应用于对象时，相应的操作符通常都会调用对象的valueOf()或toString()方法，以便取得可以操作的值。</p><a id="more"></a><h4 id="1，一元操作符"><a href="#1，一元操作符" class="headerlink" title="1，一元操作符"></a>1，一元操作符</h4><p>只能操作一个值的操作符叫一元操作符。</p><h6 id="a，递增和递减操作符"><a href="#a，递增和递减操作符" class="headerlink" title="a，递增和递减操作符"></a>a，递增和递减操作符</h6><p>递增和递减操作符各有两个版本：前置型和后置型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var age1 &#x3D; 1;</span><br><span class="line">++age1;</span><br><span class="line">var age2 &#x3D; 1;</span><br><span class="line">age2 &#x3D; age2 + 1;</span><br></pre></td></tr></table></figure><p>这两个操作的效果相同。<br>执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var age &#x3D; 10;</span><br><span class="line">var age1 &#x3D; --age + 2;</span><br><span class="line">alert(age); &#x2F;&#x2F; 9</span><br><span class="line">alert(age1); &#x2F;&#x2F; 11</span><br></pre></td></tr></table></figure><p>由于前置递增和递减操作与执行语句的优先级相等，因此整个语句会从左至右被求值。<br>在应用于不同的值时，递增和递减操作符遵循下列规则：</p><ul><li><p>在应用于一个包含有效数字字符的字符串时，先将其转换位数字值，再执行加减操作。字符串变量变成数值变量。</p></li><li><p>在应用于一个不包含有效数字字符的字符串时，将变量的值设置为NaN。字符串变量变成数值变量。</p></li><li><p>在应用于布尔值false时，先将其转换为0再执行加减操作。布尔值变量变成数值变量。</p></li><li><p>在应用于布尔值true时，先将其转换为1再执行加减操作，布尔值变量变成数值变量。</p></li><li><p>在应用于浮点数值时，执行加减操作。</p></li><li><p>在应用于对象时，先调用对象的valueOf()方法，取得一个可操作的值，然后对该值应用前述规则。如果结果时NaN，则在调用toString()方法后再应用前述规则。对象变量变成数值变量。</p><h6 id="b，一元加减操作符"><a href="#b，一元加减操作符" class="headerlink" title="b，一元加减操作符"></a>b，一元加减操作符</h6><p>一元加操作符以一个+表示，当在数值前面，对数值不会产生任何影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">a &#x3D; +a; &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>在对非数值应用一元加操作符时，该操作符会像Number()转型函数一样对这个值执行转换。<br>一元减操作符主要用于表示负数，在将一元减操作符应用于数值时，该值会变成负数。而当应用于非数值时，一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数。</p><h4 id="2，位操作符"><a href="#2，位操作符" class="headerlink" title="2，位操作符"></a>2，位操作符</h4><p>位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。</p><p>对于有符号的整数，32位中的前31位用于表示整数的值。第32位用于表示数值的符号：0表示正式，1表示负数。这个表示符号的位叫做符号位。符号位的值决定了其他位数值的格式。其中，整数以纯二进制格式存储，31位中的每一位都表示2的幂。第一位(位0)表示2^0，第二位表示2^1,以此类推。没有用到的位用0填充，即忽略不计。</p><p>负数同样以二进制码存储，但使用的格式是二进制补码。</p><h6 id="a，按位非-NOT"><a href="#a，按位非-NOT" class="headerlink" title="a，按位非(NOT)"></a>a，按位非(NOT)</h6><p>按位非操作符由一个～表示，执行按位非的结果就是返回数值的反码。</p><h6 id="b，按位与-AND"><a href="#b，按位与-AND" class="headerlink" title="b，按位与(AND)"></a>b，按位与(AND)</h6><p>按位与操作符由一个和号字符&amp;表示，它有两个操作数。遵循下面这个真值表：</p></li></ul><table style="text-align:center"><thead><tr style="text-align:center"><th>第一个数值的位</th><th>第二个数值的位</th><th>结果</th></tr></thead><tbody><tr><td><code>1</code></td><td><code>1</code></td><td><code>1</code></td></tr><tr><td><code>1</code></td><td><code>0</code></td><td><code>0</code></td></tr><tr><td><code>0</td><td><code>1</code></td><td><code>0</code></td></tr><tr><td><code>0</code></td><td><code>0</code></td><td><code>0</code></td></tr></tbody></table><h6 id="c，按位或-OR"><a href="#c，按位或-OR" class="headerlink" title="c，按位或(OR)"></a>c，按位或(OR)</h6><p> 按位或操作符由一个竖线符号 | 表示，同样也有两个操作数。遵循下面这个真值表：</p><table style="text-align:center"><thead><tr style="text-align:center"><th>第一个数值的位</th><th>第二个数值的位</th><th>结果</th></tr></thead><tbody><tr><td><code>1</code></td><td><code>1</code></td><td><code>1</code></td></tr><tr><td><code>1</code></td><td><code>0</code></td><td><code>1</code></td></tr><tr><td><code>0></td><td><code>1</code></td><td><code>1</code></td></tr><tr><td><code>0</code></td><td><code>0</code></td><td><code>0</code></td></tr></tbody></table><h6 id="d，按位异或-XOR"><a href="#d，按位异或-XOR" class="headerlink" title="d，按位异或(XOR)"></a>d，按位异或(XOR)</h6><p> 按位异或操作符由一个 ^ 表示，也有两个操作数。遵循下面这个真值表：</p><table style="text-align:center"><thead><tr style="text-align:center"><th>第一个数值的位</th><th>第二个数值的位</th><th>结果</th></tr></thead><tbody><tr><td><code>1</code></td><td><code>1</code></td><td><code>0</code></td></tr><tr><td><code>1</code></td><td><code>0</code></td><td><code>1</code></td></tr><tr><td><code>0></td><td><code>1</code></td><td><code>1</code></td></tr><tr><td><code>0</code></td><td><code>0</code></td><td><code>0</code></td></tr></tbody></table><p>按位异或与按位或的不同之处在于，这个操作符在两个数值对应位上只有一个1时才返回1，如果对应的两位都是1或都是0，返回0.</p><h6 id="e，左移"><a href="#e，左移" class="headerlink" title="e，左移"></a>e，左移</h6><p>左移操作符由两个 &lt;&lt; 表示，这个操作符会将数值的所有位向左移动指定的位数。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var oldNum &#x3D; 2; &#x2F;&#x2F; 等于二进制的10</span><br><span class="line">var newNum &#x3D; oldNum &lt;&lt; 5; &#x2F;&#x2F; 等于二进制的1000000，十进制的64</span><br></pre></td></tr></table></figure><h6 id="f，有符号的右移"><a href="#f，有符号的右移" class="headerlink" title="f，有符号的右移"></a>f，有符号的右移</h6><p>右移操作符由两个 &gt;&gt; 表示，这个操作符会将数值向右移动，但保留符号位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var oldNum &#x3D; 64; &#x2F;&#x2F; 等于二进制的1000000</span><br><span class="line">var newNum &#x3D; oldNum &gt;&gt; 5; &#x2F;&#x2F; 等于二进制的10，即十进制的2</span><br></pre></td></tr></table></figure><h6 id="g，无符号右移"><a href="#g，无符号右移" class="headerlink" title="g，无符号右移"></a>g，无符号右移</h6><p>无符号右移操作（&gt;&gt;&gt;）,这个操作符会将数值的32位都向右移动<br>对正数来说，无符号右移的结果与有符号右移相同<br>对负数来说：</p><ul><li><p>无符号右移是0来填充空位，而不是向有符号右移那样以符号位的值来填充空位</p></li><li><p>对正数的无符号右移与有符号右移结果相同，但对负数的结果就不一样了</p></li><li><p>无符号右移操作符会把负数的二进制码当成正数的二进制码</p></li><li><p>由于负数以其绝对值的二进制补码来表示，因此会导致无符号右移后的结果非常大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;(1)正数</span><br><span class="line">var oldNum &#x3D; 64; &#x2F;&#x2F; 等于二进制的1000000</span><br><span class="line">var newNum &#x3D; oldNum &gt;&gt;&gt; 5; &#x2F;&#x2F; 等于二进制的10</span><br><span class="line">&#x2F;&#x2F;(2)负数</span><br><span class="line">var oldNum &#x3D; -64; &#x2F;&#x2F; 二进制1111 1111 1111 1111 1111 1111 1100 0000</span><br><span class="line">var newNum &#x3D; oldNum &gt;&gt;&gt; 5; &#x2F;&#x2F; 等于十进制134217726</span><br></pre></td></tr></table></figure></li></ul><h4 id="3，布尔操作符"><a href="#3，布尔操作符" class="headerlink" title="3，布尔操作符"></a>3，布尔操作符</h4><p>在一门编程语言中，布尔操作符的重要性堪比相等操作符。有了它，流控制语句、循环语句才有作用。</p><h6 id="a，逻辑非"><a href="#a，逻辑非" class="headerlink" title="a，逻辑非"></a>a，逻辑非</h6><p>逻辑非操作符由一个 ！表示，可以应用于JavaScript中的任何值。无论这个值是什么类型，都将会返回一个布尔值。</p><p>逻辑非操作符会先将它的操作数转换为一个布尔值，然后在对其求反。</p><p>遵循下列规则：</p><ul><li>操作数是一个对象，则返回false</li><li>操作数是一个空字符串，返回true</li><li>操作符是一个非空字符串，返回flase</li><li>操作数是数值0，返回true</li><li>操作数是任意非0数值（包括Infinity），返回false</li><li>操作数是null，返回true</li><li>操作数是NaN，返回true</li><li>操作数是undefined，返回true<br>例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> alert(!false);&#x2F;&#x2F;true</span><br><span class="line">alert(!&quot;blue&quot;);&#x2F;&#x2F;false</span><br><span class="line">alert(!0);&#x2F;&#x2F;true</span><br><span class="line">alert(!NaN);&#x2F;&#x2F;true</span><br><span class="line">alert(!&quot;&quot;);&#x2F;&#x2F;true</span><br><span class="line">alert(!12345);&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure></li></ul><p>同时使用两个逻辑非操作符，实际上就会模拟Boolean()转型函数的行为。其中，第一个逻辑非操作会基于无论什么操作数返回一个布尔值，而第二个逻辑非操作则会对该布尔值取反，于是得到了这个值真正对应的布尔值。最终结果与对这个值使用Boolean()函数相，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alert(!!&quot;blue&quot;);&#x2F;&#x2F;true</span><br><span class="line">alert(!!0);&#x2F;&#x2F;false</span><br><span class="line">alert(!!NaN);&#x2F;&#x2F;false</span><br><span class="line">alert(!!&quot;&quot;);&#x2F;&#x2F;false</span><br><span class="line">alert(!!12345);&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><h6 id="b，逻辑与"><a href="#b，逻辑与" class="headerlink" title="b，逻辑与"></a>b，逻辑与</h6><p>逻辑与操作符由 &amp;&amp; 表示,它有两个操作数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; true &amp;&amp; false;</span><br></pre></td></tr></table></figure><p>真值表如下：</p><table style="text-align:center"><thead><tr style="text-align:center"><th>第一个操作数</th><th>第二个操作数</th><th>结果</th></tr></thead><tbody><tr><td><code>true</code></td><td><code>true</code></td><td><code>true</code></td></tr><tr><td><code>true</code></td><td><code>false</code></td><td><code>false</code></td></tr><tr><td><code>false></td><td><code>true</code></td><td><code>false</code></td></tr><tr><td><code>false</code></td><td><code>false</code></td><td><code>false</code></td></tr></tbody></table><p>逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下。逻辑与操作就不一定返回布尔值。遵循下列规则：</p><ul><li>如果第一个操作数是对象，则返回第二个操作数</li><li>如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象</li><li>如果两个操作数都是对象，则返回第二个操作数</li><li>如果第一个操作数是null，则返回null</li><li>如果第一个操作数是NaN，则返回NaN</li><li>如果第一个操作数是undefined，则返回undefined</li></ul><p>逻辑与操作属于短路操作。即第一个操作数能决定结果，那就不会在对第二个操作数求值，对于逻辑与操作而言，如果第一个操作数是false，则不会继续对第二个操作数求值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var found&#x3D;true;</span><br><span class="line">var result&#x3D;(found&amp;&amp;someUndefinedVar);&#x2F;&#x2F;发生错误</span><br><span class="line">alert(result);&#x2F;&#x2F;这一行不会执行</span><br></pre></td></tr></table></figure><p>不能在逻辑与操作中使用未定义的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var found&#x3D;false;</span><br><span class="line">var result&#x3D;(found&amp;&amp;someUndefinedVar);</span><br><span class="line">alert(result);&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure><h6 id="c，逻辑或"><a href="#c，逻辑或" class="headerlink" title="c，逻辑或"></a>c，逻辑或</h6><p>逻辑或操作符由 || 表示，它有两个操作数，例如；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; true || false;</span><br></pre></td></tr></table></figure><p>真值表如下：</p><table style="text-align:center"><thead><tr style="text-align:center"><th>第一个操作数</th><th>第二个操作数</th><th>结果</th></tr></thead><tbody><tr><td><code>true</code></td><td><code>true</code></td><td><code>true</code></td></tr><tr><td><code>true</code></td><td><code>false</code></td><td><code>true</code></td></tr><tr><td><code>false></td><td><code>true</code></td><td><code>true</code></td></tr><tr><td><code>false</code></td><td><code>false</code></td><td><code>false</code></td></tr></tbody></table><p>遵循下列规则：</p><ul><li>如果第一个操作数是对象，则返回第一个操作对象</li><li>如果第一个操作数的求值结果是false，则返回第二个操作数</li><li>如果两个操作数都是对象，则返回第一个操作数</li><li>如果两个操作数都是null，则返回null</li><li>如果两个数都是NaN，则返回NaN</li><li>如果两个数都是undefined，则返回undefined</li></ul><p>与逻辑与操作相似，逻辑或操作符也是短路操作符 。如果第一个操作数的求值结果是true，就不会对第二个操作数求值，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var found&#x3D;true;</span><br><span class="line">var result&#x3D;(found||someUndefinedVar);&#x2F;&#x2F;不会发生错误</span><br><span class="line">alert(result);&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><p>可以利用逻辑或来避免为变量赋值null或undefined值</p><h4 id="4，乘性操作符"><a href="#4，乘性操作符" class="headerlink" title="4，乘性操作符"></a>4，乘性操作符</h4><p>在操作数为非数值时，会执行自动的类型转换.如果参与乘性计算的某个操作数不是数值，后台会先使用Number()转型函数将其转化为数值。即空字符串被当做0，布尔值true被当做为1</p><h6 id="a，乘法"><a href="#a，乘法" class="headerlink" title="a，乘法"></a>a，乘法</h6><p>乘法操作符由 * 表示，用于计算两个数值的乘积<br>在处理特殊值时，遵循下列规则</p><ul><li>如果操作数都是数值，执行常规的乘法计算。如果乘积超过了JavaScript数值的表示范围，则返回Infinity或-Infinity</li><li>如果一个操作数是NaN，则结果是NaN</li><li>如果Infinity与0相乘，则结果是NaN</li><li>如果Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号</li><li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则</li></ul><h6 id="b，除法"><a href="#b，除法" class="headerlink" title="b，除法"></a>b，除法</h6><p>除法操作符由 / 表示,执行第二个操作数除以第一个操作数的计算<br>在处理特殊值时，遵循下列规则</p><ul><li>如果操作数都是数值，执行常规的除法计算。如果商超过了JavaScript数值的表示范围，则返回Infinity或-Infinity</li><li>如果一个操作数是NaN，则结果是NaN</li><li>如果是Infinity被Infinity除，则结果是NaN</li><li>如果是零被零除，则结果是NaN</li><li>如果是非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号</li><li>如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity，取决于有符号操作数的符号</li><li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后应用上面的规则</li></ul><h6 id="c，求模"><a href="#c，求模" class="headerlink" title="c，求模"></a>c，求模</h6><p>求模（余数）操作符由 % 表示<br>在处理特殊值时，遵循下列规则</p><ul><li>如果操作数都是数值，执行常规的除法计算，返回除得的余数</li><li>如果被除数是无穷大值而除数是有限大的数值，则结果是NaN</li><li>如果被除数是有限大的数值而除数是零，则结果是NaN</li><li>如果是Infinity被Infinity除，则结果是NaN</li><li>如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数</li><li>如果被除数是零，则结果是零</li><li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则</li></ul><h4 id="5，加性操作符"><a href="#5，加性操作符" class="headerlink" title="5，加性操作符"></a>5，加性操作符</h4><p>与乘性操作符类似，加性操作符也会在后台转换不同的数据类型。对于加性操作符来说，相应的转化规则还有些复杂</p><h6 id="a，加法"><a href="#a，加法" class="headerlink" title="a，加法(+)"></a>a，加法(+)</h6><p>如果两个操作符都是数值，则执行常规的加法计算<br>遵循下列规则：</p><ul><li>如果有一个操作数是NaN，则结果是NaN</li><li>如果是Infinity加Infinity，则结果是Infinity</li><li>如果是-Infinity加-Infinity，则结果是-Infinity</li><li>如果是Infinity加-Infinity，则结果是NaN</li><li>如果是+0加+0，则结果是+0</li><li>如果是-0加-0，则结果是-0</li><li>如果是+0加-0，则结果是+0</li><li>如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来</li><li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来</li><li>如果一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于undefined和null，则分别调用String()函数并取得字符串”undefined”和”null”<br>例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var result1&#x3D;5+5;&#x2F;&#x2F;两个数值相加</span><br><span class="line">alert(result1);&#x2F;&#x2F;10</span><br><span class="line">var result2&#x3D;5+&quot;5&quot;;&#x2F;&#x2F;一个数值和一个字符串相加</span><br><span class="line">alert(result2);&#x2F;&#x2F;&quot;55&quot;</span><br></pre></td></tr></table></figure></li></ul><h6 id="b，减法"><a href="#b，减法" class="headerlink" title="b，减法(-)"></a>b，减法(-)</h6><p>遵循下列规则：</p><ul><li>如果两个操作数都是数值，则执行常规的算术减法操作并返回结果</li><li>如果一个操作数是NaN,则结果是NaN</li><li>如果是Infinity减Infinity，则结果是NaN</li><li>如果是-Infinity减-Infinity，则结果是NaN</li><li>如果是Infinity减-Infinity，则结果是Infinity</li><li>如果是-Infinity减Infinity，则结果是-Infinity</li><li>如果是+0减+0，则结果是+0</li><li>如果是-0减+0，则结果是-0</li><li>如果是-0减-0，则结果是+0</li><li>如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN</li><li>如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象 的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值<br>例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var result1&#x3D;5-true;&#x2F;&#x2F;4</span><br><span class="line">var result2&#x3D;NaN-1;&#x2F;&#x2F;NaN</span><br><span class="line">var result3&#x3D;5-3;&#x2F;&#x2F;2</span><br><span class="line">var result4&#x3D;5-&quot;&quot;;&#x2F;&#x2F;5</span><br><span class="line">var result&#x3D;5-&quot;2&quot;;&#x2F;&#x2F;3</span><br><span class="line">var result&#x3D;5-null;&#x2F;&#x2F;5</span><br></pre></td></tr></table></figure></li></ul><h4 id="6，关系操作符"><a href="#6，关系操作符" class="headerlink" title="6，关系操作符"></a>6，关系操作符</h4><p>小于（&lt;）、大于（&gt;）、小于等于（&lt;=）和大于等于（&gt;=）这几个关系操作符用于对两个值进行比较。这几个操作符都返回一个布尔值<br>操作非数值时，遵循下列规则：</p><ul><li>如果这两个操作数都是数值，则执行数值比较</li><li>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值</li><li>如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较</li><li>如果一个操作数是对象，则调用这个对象的valueOf()方法，并用得到的结果根据前面的规则执行比较</li><li>如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较</li></ul><h4 id="7，相等操作符"><a href="#7，相等操作符" class="headerlink" title="7，相等操作符"></a>7，相等操作符</h4><h6 id="a，相等和不相等"><a href="#a，相等和不相等" class="headerlink" title="a，相等和不相等(==)"></a>a，相等和不相等(==)</h6><p>相等操作符（==），如果两个操作数相等，则返回true<br>不相等操作符（!=），如果两个操作数不相等，则返回true<br>这两个操作符都会先转换操作数（强制转型），然后再比较它们的相等性<br>转换不同经数据类型时，遵循下列规则：</p><ul><li>如果一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换 为0，true转换为1</li><li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值</li><li>如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较</li></ul><p>这两个操作符进行比较时，遵循下列规则：</p><ul><li>null和undefined是相等的</li><li>要比较相等性之前，不能将null和undefined转换成其它任何值</li><li>如果一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true（即使两个操作数都是NaN，相等操作符返回false,因为按照规则，NaN不等于NaN）</li><li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false</li></ul><table style="text-align:center"><thead><tr style="text-align:center"><th>表达式</th><th>值</th><th>表达式</th><th>值</th></tr></thead><tbody><tr><td><code>null==undefined</code></td><td><code>true</code></td><td><code>true==1</code></td><td><code>true</code></td></tr><tr><td><code>"NaN"==NaN</code></td><td><code>false</code></td><td><code>true==2</code></td><td><code>false</code></td></tr><tr><td><code>5==NaN</code></td><td><code>false</code></td><td><code>undefined==0</code></td><td><code>false</code></td></tr><tr><td><code>NaN==NaN</code></td><td><code>false</code></td><td><code>null==0</code></td><td><code>false</code></td></tr><tr><td><code>NaN!=NaN</code></td><td><code>true</code></td><td><code>"5"==5</code></td><td><code>true</code></td></tr><tr><td><code>false==0</code></td><td><code>true</code></td><td></td><td></td></tr></tbody></table><h6 id="b，全等和不全等"><a href="#b，全等和不全等" class="headerlink" title="b，全等和不全等(===)"></a>b，全等和不全等(===)</h6><p>比较不转换操作数，全等和不全等操作符相同<br>全等操作符（===），只在两个操作数未经转换就相等的情况下返回true<br>不全等操作符（！==），在两个操作数未经转换就不相等的情况下返回true<br>null==undeifned会返回true，因为它们是类似的值；但null===undefined会返回false，因为它们是不同类型的值</p><h4 id="8，条件操作符"><a href="#8，条件操作符" class="headerlink" title="8，条件操作符"></a>8，条件操作符</h4><p>条件操作符非常灵活，即 三元运算符</p><p>表达式？true:false;</p><h4 id="9，赋值操作符"><a href="#9，赋值操作符" class="headerlink" title="9，赋值操作符"></a>9，赋值操作符</h4><p>赋值操作符（=），将右侧的值赋给左侧的变量<br>在（=）前面在添加乘性操作符、加性操作符或位操作符，就可以完成复核赋值操作</p><p>复合赋值操作符：</p><ul><li>乘（<em>）赋值：</em>=</li><li>除（/）赋值：/=</li><li>模（%）赋值：%=</li><li>加（+）赋值：+=</li><li>减（-）赋值：-=</li><li>左移（&lt;&lt;）:&lt;&lt;=</li><li>有符号右移（&gt;&gt;）赋值：&gt;&gt;=</li><li>无符号右移（&gt;&gt;&gt;）赋值：&gt;&gt;&gt;=</li></ul><p>复合操作符主要目的是简化赋值运算，使用它们不会有任何性能的提升</p><h4 id="10，逗号操作符"><a href="#10，逗号操作符" class="headerlink" title="10，逗号操作符"></a>10，逗号操作符</h4><p>使用逗号操作符(,)可以在一条语句中执行多个操作</p><p>逗号操作符多用于声明多个变量</p><p>在用于赋值时，逗号操作符总会返回表达式中的最后一项</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-3-数据类型</title>
      <link href="/2019/08/20/Javascript-3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/08/20/Javascript-3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>ECMAScript中有5种简单数据类型(基本数据类型):Undefined、Null、Boolean、Number、String。1种复杂数据类型：Object。Object本质上是由一组无序的名值对组成的。EMCAScript不支持任何创建自定义类型的机制，而所有值最终都将是上述6种数据类型之一。</p><a id="more"></a><h4 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h4><p>  鉴于ECMAScript是松散类型的，因此需要有一种手段来检测给定变量的数据类型，而typeof就是负责提供这方面信息的操作符。</p><p>  对一个值使用typeof操作符可能返回以下内容：</p><ul><li>undefined—未定义；</li><li>boolean—布尔值；</li><li>string—字符串；  </li><li>number—数值；</li><li>object—对象或null； </li><li>function—函数；</li></ul><h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><p>  undefined类型只有一个值，即undefined，使用var声明变量但未对其加以初始化时，这个变量的值就是undefined，例如：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">alert(a &#x3D;&#x3D; undefined); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></p><h4 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h4><p>  Null类型也只有一个值，即null，从逻辑来看，null表示一个空对象指针，所以使用typeof操作符检测null值时会返回object，例如：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var b &#x3D; null;</span><br><span class="line">alert(typeof b); &#x2F;&#x2F; &quot;object&quot;</span><br></pre></td></tr></table></figure><br>  实际上undefined的值是派生自null值的，因此ECMA规定对它们的相等性测试要返回true。</p><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><p>  Boolean类型是ECMAScript中使用最多的一种类型，该类型有两个字面值：true和false，这两个值与数字值不是一回事。</p><p>  需要注意的是，Boolean类型的字面值true和false是区分大小写的。也就是说，True和False(以及其它的混合大小写形式)都不是Boolean的值，只是标识符。</p><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>  Number类型使用IEEE754格式来表示整数和浮点数值(双精度数值).</p><h6 id="浮点数值"><a href="#浮点数值" class="headerlink" title="浮点数值"></a>浮点数值</h6><pre><code>浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字，虽然小数点前面可以没有整数，但是不推荐这种写法。由于保存浮点数值需要的内存空间是保存整数值的两部，因此ECMAScript会不失时机地将浮点数值转换为整数值。对于极大或极小的数值，可以用e(科学计数法)表示的浮点数值表示。用e表示法表示的数值等于e前面的数值乘以10的指数次幂。</code></pre><h5 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h5><pre><code>由于内存的限制，ECMAScript不能保存所有的数值，它所能够表示的最小数值保存在Numbe.MIN_VALUE中(在大多数浏览器中这个值是5e-324).能够表示的最大数值保存在Number.MAX_VALUE中(在大多数浏览器中这个值是1.7976931348623157e+308)。如果计算的值超出Javascript数值范围，这个数值会被自动转换成特殊的Infinity值。</code></pre><h5 id="Nan"><a href="#Nan" class="headerlink" title="Nan"></a>Nan</h5><pre><code>Nan，即非数值。用来表示一个本来要返回数值的操作数未返回数值的情况。任何涉及NaN的操作都会返回NaN，这个特点在多步计算中有可能导致问题。NaN与任何值都不相等，包括NaN本身。isNaN()函数可以帮我们确定一个数是否“不是数值”，这个函数接受一个参数</code></pre><h5 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h5><pre><code>有三个函数可以把非数值转换为数值：Number()，可以用于任何数据类型。parseInt()、parseFloat()专门用于把字符串转换成数值。由于Number()函数在转换字符串时比较复杂而且不够合理，因此在处理数值时更常用parseInt()。parseInt()在转换字符串时，更多的是看其是否符合数值模式。它会忽律字符串前面的空格，直到找到一个非空格字符。如果第一个字符不是数字字符或者符号，parseInt()会返回NaN。与parseInt()函数类似，parseFloat()也是从第一个字符开始解析，而且一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。</code></pre><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><pre><code>String类型用于表示由零或者多个16位Unicode字符组成的字符序列，即字符串。ECMAScript中的字符串是不可变的，也就是说字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。可以使用toString()来把一个值转换为字符串，对于不知道要转换的值是不是null或undefined的情况下，可以使用转型函数String()，这个函数能够将任何类型的值转换为字符串。</code></pre><h5 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h5><pre><code>Objec其实就是一组数据和功能的集合。可以通过执行new操作符来创建，创建Object类型的示例并为其添加属性和方法，就可以创建自定义对象。在Javascript中Object类型是所有它的实例的基础，Object的每个实例都具有下列属性和方法：constructor：保存着用于创建当前对象的函数。hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中是否存在。其中，propertyName必须以字符串形式指定。isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型。propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串的形式制定。toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。toString()：返回对象的字符串表示。valueOf()：返回对象的字符串、数值或布尔值表示。</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-2-script</title>
      <link href="/2019/08/15/Javascript-2-script/"/>
      <url>/2019/08/15/Javascript-2-script/</url>
      
        <content type="html"><![CDATA[<h3 id="1、-lt-script-gt-元素"><a href="#1、-lt-script-gt-元素" class="headerlink" title="1、&lt;script&gt;元素"></a>1、<code>&lt;script&gt;</code>元素</h3><p>向HTML页面中引入Javascript的主要方法就是使用script元素。</p><p>HTML4.01为script定义了下面6个属性：<br>    1，async：可选。表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其它资源或等待加载其它脚本。只对外部脚本文件有效。<br>    2，charset：可选。表示通过src属性指定的代码的字符集。<br>    3，defer：可选。表示脚本可以延迟到文档完全被解析和现实之后再执行。只对外部脚本文件有效。<br>    4，language：已废弃。原来用于表示编写代码使用的脚本语言。大多数浏览器会忽略这个属性，因此也没必要再用了。<br>    5，src：可选。表示包含要执行代码的外部文件。<br>    6，type：可选。可以看成是language的替代属性；表示编写代码使用的脚本语言的内容类型。</p><a id="more"></a><p>使用script元素的方式有两种：直接在页面中嵌入Javascript代码和包含外部Javascript文件。</p><p>包含在script闭合标签内部的Javascript代码将被从上至下依次解释。在解释器对script元素内部的所有代码求值完毕之前，页面中的其余内容都不会被浏览器加载或显示。</p><p>在使用script标签嵌入Javascript代码时，记住不要在代码中的任何地方出现<code>&quot;&lt;/script&gt;&quot;</code>字符串。例如，浏览器在加载下面所示的代码时就会产生一个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">function printScript() &#123;</span><br><span class="line">    alert(&quot;&lt;&#x2F;script&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>因为按照解析嵌入式代码的规则，当浏览器遇到字符串<code>&quot;&lt;/script&gt;&quot;</code>标签时，会认为是结束的<code>&lt;script&gt;</code>标签。可以通过转义符来解决这个问题，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    function printScript() &#123;</span><br><span class="line">        alert(&quot;&lt;\&#x2F;script&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="2、标签位置"><a href="#2、标签位置" class="headerlink" title="2、标签位置"></a>2、标签位置</h3><p>按照传统的做法，所有<code>&lt;script&gt;</code>元素都应该放在页面的<code>&lt;head&gt;</code>元素中，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;example.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>这种做法的目的就是把所有外部文件(包括CSS文件和Javascript文件)的引用都放在相同的地方。可是把所有的Javascript文件都放在<code>&lt;head&gt;</code>元素中，意味着必须等到全部Javascript代码都被下载、解析、执行完成之后。才开始呈现页面的内容。对于那些需要很多Javascript代码的页面来说，会导致浏览器窗口在呈现页面是出现明显的延迟，浏览器窗口一片空白。</p><p>为了避免这个问题，现代web一般都把全部Javascript引用放到<code>&lt;body&gt;</code>元素中页面内容之后，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;example.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>这样在解析包含的Javascript代码之前，页面的内容将完全呈现在浏览器中。</p><h3 id="3、延迟脚本"><a href="#3、延迟脚本" class="headerlink" title="3、延迟脚本"></a>3、延迟脚本</h3><p>HTML4.01为<code>&lt;script&gt;</code>标签定义了defer属性。这个属性的用途是表明脚本在执行时不会影响页面的构照。也就是说，脚本会被延迟到整个页面都解析完毕之后再运行，因此，在<code>&lt;script&gt;</code>元素中设置defer属性，相当于告诉浏览器立即下载，但延迟执行。</p><p>前面提到defer属性只适用于外部脚本文件。这一点在HTML5中已经明确规定，因此支持HTML5的实现会忽略嵌入脚本设置的defer属性。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-1-DOM</title>
      <link href="/2019/08/13/Javascript-1-DOM/"/>
      <url>/2019/08/13/Javascript-1-DOM/</url>
      
        <content type="html"><![CDATA[<p>DOM(Document Object Model)即文档对象模型，是针对XML但经过拓展用于HTML的应用程序编程接口。DOM把整个页面映射为一个多层节点结构。</p><a id="more"></a> <p>DOM1由两个模块组成：DOM核心(DOM Core)和DOM HTML。DOM核心规定的是如何映射基于XML的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML模块则在DOM核心的基础上加以拓展，添加了针对HTML的对象和方法。</p><p>DOM2在DOM1的基础上扩充了鼠标和用户界面事件、范围、遍历等细分模块。而且通过对象接口增加了对CSS(Cascading Style Sheets, 层叠样式表)的支持。</p><p>DOM3则进一步拓展了DOM，引入了以统一方式加载和保存文档的方法–在DOM加载和保存(DOM Load and Save)模块中定义；增加了验证文档的方法–在DOM验证(DOM Validation)模块中定义。DOM3也对DOM核心进行了拓展，开始支持XML1.0规范。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS一些易忘的常用点</title>
      <link href="/2019/08/12/CSS%E4%B8%80%E4%BA%9B%E6%98%93%E5%BF%98%E7%9A%84%E5%B8%B8%E7%94%A8%E7%82%B9/"/>
      <url>/2019/08/12/CSS%E4%B8%80%E4%BA%9B%E6%98%93%E5%BF%98%E7%9A%84%E5%B8%B8%E7%94%A8%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>1，解决inline-block元素设置overflow:hidden属性导致相邻行内元素向下偏移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.wrap &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  overflow: hidden</span><br><span class="line">vertical-align: bottom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a> <p>2，超出部分显示省略号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 单行文本</span><br><span class="line">.wrap &#123;</span><br><span class="line">overflow:hidden;&#x2F;*超出部分隐藏*&#x2F;</span><br><span class="line">text-overflow:ellipsis;&#x2F;*超出部分显示省略号*&#x2F;</span><br><span class="line">white-space:nowrap;&#x2F;*规定段落中的文本不进行换行 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 多行文本</span><br><span class="line">.wrap &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    display: -webkit-box;   &#x2F;&#x2F;将对象作为弹性伸缩盒子模型显示  *必须结合的属性*</span><br><span class="line">    -webkit-box-orient: vertical;   &#x2F;&#x2F;设置伸缩盒对象的子元素的排列方式  *必须结合的属性*</span><br><span class="line">    -webkit-line-clamp: 3;   &#x2F;&#x2F;用来限制在一个块元素中显示的文本的行数</span><br><span class="line">    word-break: break-all;   &#x2F;&#x2F;让浏览器实现在任意位置的换行 *break-all为允许在单词内换行*</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3，css实现不换行、自动换行、强制换行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;不换行</span><br><span class="line">.wrap &#123;</span><br><span class="line">  white-space:nowrap;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;自动换行</span><br><span class="line">.wrap &#123;</span><br><span class="line">  word-wrap: break-word;</span><br><span class="line">  word-break: normal;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;强制换行</span><br><span class="line">.wrap &#123;</span><br><span class="line">  word-break:break-all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4，CSS实现文本两端对齐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.wrap &#123;</span><br><span class="line">    text-align: justify;</span><br><span class="line">    text-justify: distribute-all-lines;  &#x2F;&#x2F;ie6-8</span><br><span class="line">    text-align-last: justify;  &#x2F;&#x2F;一个块或行的最后一行对齐方式</span><br><span class="line">    -moz-text-align-last: justify;</span><br><span class="line">    -webkit-text-align-last: justify;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5，实现文字竖向排版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 单列展示时</span><br><span class="line">.wrap &#123;</span><br><span class="line">    width: 25px;</span><br><span class="line">    line-height: 18px;</span><br><span class="line">    height: auto;</span><br><span class="line">    font-size: 12px;</span><br><span class="line">    padding: 8px 5px;</span><br><span class="line">    word-wrap: break-word;&#x2F;*英文的时候需要加上这句，自动换行*&#x2F;  </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 多列展示时</span><br><span class="line">.wrap &#123;</span><br><span class="line">    height: 210px;</span><br><span class="line">    line-height: 30px;</span><br><span class="line">    text-align: justify;</span><br><span class="line">    writing-mode: vertical-lr;  &#x2F;&#x2F;从左向右    </span><br><span class="line">    writing-mode: tb-lr;        &#x2F;&#x2F;IE从左向右</span><br><span class="line">    &#x2F;&#x2F;writing-mode: vertical-rl;  -- 从右向左</span><br><span class="line">    &#x2F;&#x2F;writing-mode: tb-rl;        -- 从右向左</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6，使元素鼠标事件失效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.wrap &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果按tab能选中该元素，如button，然后按回车还是能执行对应的事件，如click。</span><br><span class="line">pointer-events: none;</span><br><span class="line">    cursor: default;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7，禁止用户选择</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.wrap &#123;</span><br><span class="line">  -webkit-touch-callout: none;</span><br><span class="line">  -webkit-user-select: none;</span><br><span class="line">  -khtml-user-select: none;</span><br><span class="line">  -moz-user-select: none;</span><br><span class="line">  -ms-user-select: none;</span><br><span class="line">  user-select: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8，cursor属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.wrap &#123;</span><br><span class="line">  cursor：pointer; &#x2F;&#x2F;小手指；</span><br><span class="line">  cursor：help; &#x2F;&#x2F;箭头加问号；</span><br><span class="line">  cursor：wait; &#x2F;&#x2F;转圈圈；</span><br><span class="line">  cursor：move; &#x2F;&#x2F;移动光标；</span><br><span class="line">  cursor：crosshair; &#x2F;&#x2F;十字光标</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9，使用硬件加速</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.wrap &#123;</span><br><span class="line">    transform: translateZ(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10，Text-transform和Font Variant</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p &#123;text-transform: uppercase&#125;  &#x2F;&#x2F; 将所有字母变成大写字母</span><br><span class="line">p &#123;text-transform: lowercase&#125;  &#x2F;&#x2F; 将所有字母变成小写字母</span><br><span class="line">p &#123;text-transform: capitalize&#125; &#x2F;&#x2F; 首字母大写</span><br><span class="line">p &#123;font-variant: small-caps&#125;   &#x2F;&#x2F; 将字体变成小型的大写字母</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript数组工具函数</title>
      <link href="/2019/08/09/Javascript%E6%95%B0%E7%BB%84%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/"/>
      <url>/2019/08/09/Javascript%E6%95%B0%E7%BB%84%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>1，all：布尔全等判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const all &#x3D; (arr, fn &#x3D; Boolean) &#x3D;&gt; arr.every(fn);</span><br><span class="line"></span><br><span class="line">all([4, 2, 3], x &#x3D;&gt; x &gt; 1); &#x2F;&#x2F; true</span><br><span class="line">all([1, 2, 3]); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><a id="more"></a>  <p>2，allEqual：检查数组各项相等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const allEqual &#x3D; arr &#x3D;&gt; arr.every(val &#x3D;&gt; val &#x3D;&#x3D;&#x3D; arr[0]);</span><br><span class="line"></span><br><span class="line">allEqual([1, 2, 3, 4, 5, 6]); &#x2F;&#x2F; false</span><br><span class="line">allEqual([1, 1, 1, 1]); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>3，approximatelyEqual：约等于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const approximatelyEqual &#x3D; (v1, v2, epsilon &#x3D; 0.001) &#x3D;&gt; Math.abs(v1 - v2) &lt; epsilon;</span><br><span class="line"></span><br><span class="line">approximatelyEqual(Math.PI &#x2F; 2.0, 1.5708); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>4，arrayToCSV：数组转CSV格式（带空格的字符串）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const arrayToCSV &#x3D; (arr, delimiter &#x3D; &#39;,&#39;) &#x3D;&gt;</span><br><span class="line">  arr.map(v &#x3D;&gt; v.map(x &#x3D;&gt; &#96;&quot;$&#123;x&#125;&quot;&#96;).join(delimiter)).join(&#39;\n&#39;);</span><br><span class="line">  </span><br><span class="line">arrayToCSV([[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]); &#x2F;&#x2F; &#39;&quot;a&quot;,&quot;b&quot;\n&quot;c&quot;,&quot;d&quot;&#39;</span><br><span class="line">arrayToCSV([[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]], &#39;;&#39;); &#x2F;&#x2F; &#39;&quot;a&quot;;&quot;b&quot;\n&quot;c&quot;;&quot;d&quot;&#39;</span><br></pre></td></tr></table></figure><p>5，arrayToHtmlList：数组转li列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">此代码段将数组的元素转换为&lt;li&gt;标签，并将其附加到给定ID的列表中。</span><br><span class="line">const arrayToHtmlList &#x3D; (arr, listID) &#x3D;&gt;</span><br><span class="line">  (el &#x3D;&gt; (</span><br><span class="line">    (el &#x3D; document.querySelector(&#39;#&#39; + listID)),</span><br><span class="line">    (el.innerHTML +&#x3D; arr.map(item &#x3D;&gt; &#96;&lt;li&gt;$&#123;item&#125;&lt;&#x2F;li&gt;&#96;).join(&#39;&#39;))</span><br><span class="line">  ))();</span><br><span class="line">  </span><br><span class="line">arrayToHtmlList([&#39;item 1&#39;, &#39;item 2&#39;], &#39;myListID&#39;);</span><br></pre></td></tr></table></figure><p>6，average：平均数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const average &#x3D; (...nums) &#x3D;&gt; nums.reduce((acc, val) &#x3D;&gt; acc + val, 0) &#x2F; nums.length;</span><br><span class="line">average(...[1, 2, 3]); &#x2F;&#x2F; 2</span><br><span class="line">average(1, 2, 3); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure><p>7，averageBy：数组对象属性平均数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const averageBy &#x3D; (arr, fn) &#x3D;&gt;</span><br><span class="line">  arr.map(typeof fn &#x3D;&#x3D;&#x3D; &#39;function&#39; ? fn : val &#x3D;&gt; val[fn]).reduce((acc, val) &#x3D;&gt; acc + val, 0) &#x2F;</span><br><span class="line">  arr.length;</span><br><span class="line">  </span><br><span class="line">averageBy([&#123; n: 4 &#125;, &#123; n: 2 &#125;, &#123; n: 8 &#125;, &#123; n: 6 &#125;], o &#x3D;&gt; o.n); &#x2F;&#x2F; 5</span><br><span class="line">averageBy([&#123; n: 4 &#125;, &#123; n: 2 &#125;, &#123; n: 8 &#125;, &#123; n: 6 &#125;], &#39;n&#39;); &#x2F;&#x2F; 5</span><br></pre></td></tr></table></figure><p>8，bifurcate：拆分断言后的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以根据每个元素返回的值，使用reduce()和push() 将元素添加到第二次参数fn中 。</span><br><span class="line">const bifurcate &#x3D; (arr, filter) &#x3D;&gt;</span><br><span class="line">  arr.reduce((acc, val, i) &#x3D;&gt; (acc[filter[i] ? 0 : 1].push(val), acc), [[], []]);</span><br><span class="line">bifurcate([&#39;beep&#39;, &#39;boop&#39;, &#39;foo&#39;, &#39;bar&#39;], [true, true, false, true]); </span><br><span class="line">&#x2F;&#x2F; [ [&#39;beep&#39;, &#39;boop&#39;, &#39;bar&#39;], [&#39;foo&#39;] ]</span><br></pre></td></tr></table></figure><p>9，castArray：其它类型转数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const castArray &#x3D; val &#x3D;&gt; (Array.isArray(val) ? val : [val]);</span><br><span class="line"></span><br><span class="line">castArray(&#39;foo&#39;); &#x2F;&#x2F; [&#39;foo&#39;]</span><br><span class="line">castArray([1]); &#x2F;&#x2F; [1]</span><br><span class="line">castArray(1); &#x2F;&#x2F; [1]</span><br></pre></td></tr></table></figure><p>10，compact：去除数组中的无效/无用值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const compact &#x3D; arr &#x3D;&gt; arr.filter(Boolean);</span><br><span class="line"></span><br><span class="line">compact([0, 1, false, 2, &#39;&#39;, 3, &#39;a&#39;, &#39;e&#39; * 23, NaN, &#39;s&#39;, 34]); </span><br><span class="line">&#x2F;&#x2F; [ 1, 2, 3, &#39;a&#39;, &#39;s&#39;, 34 ]</span><br></pre></td></tr></table></figure><p>11，countOccurrences：检测数值出现次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const countOccurrences &#x3D; (arr, val) &#x3D;&gt; arr.reduce((a, v) &#x3D;&gt; (v &#x3D;&#x3D;&#x3D; val ? a + 1 : a), 0);</span><br><span class="line">countOccurrences([1, 1, 2, 1, 2, 3], 1); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><p>12，deepFlatten：递归扁平化数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const deepFlatten &#x3D; arr &#x3D;&gt; [].concat(...arr.map(v &#x3D;&gt; (Array.isArray(v) ? deepFlatten(v) : v)));</span><br><span class="line"></span><br><span class="line">deepFlatten([1, [2], [[3], 4], 5]); &#x2F;&#x2F; [1,2,3,4,5]</span><br></pre></td></tr></table></figure><p>13，difference：寻找差异<br>此代码段查找两个数组之间的差异。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const difference &#x3D; (a, b) &#x3D;&gt; &#123;</span><br><span class="line">  const s &#x3D; new Set(b);</span><br><span class="line">  return a.filter(x &#x3D;&gt; !s.has(x));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">difference([1, 2, 3], [1, 2, 4]); &#x2F;&#x2F; [3]</span><br></pre></td></tr></table></figure><p>14，differenceBy：先执行再寻找差异<br>在将给定函数应用于两个列表的每个元素之后，此方法返回两个数组之间的差异。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const differenceBy &#x3D; (a, b, fn) &#x3D;&gt; &#123;</span><br><span class="line">  const s &#x3D; new Set(b.map(fn));</span><br><span class="line">  return a.filter(x &#x3D;&gt; !s.has(fn(x)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor); &#x2F;&#x2F; [1.2]</span><br><span class="line">differenceBy([&#123; x: 2 &#125;, &#123; x: 1 &#125;], [&#123; x: 1 &#125;], v &#x3D;&gt; v.x); &#x2F;&#x2F; [ &#123; x: 2 &#125; ]</span><br></pre></td></tr></table></figure><p>15，dropWhile：删除不符合条件的值<br>此代码段从数组顶部开始删除元素，直到传递的函数返回为true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const dropWhile &#x3D; (arr, func) &#x3D;&gt; &#123;</span><br><span class="line">  while (arr.length &gt; 0 &amp;&amp; !func(arr[0])) arr &#x3D; arr.slice(1);</span><br><span class="line">  return arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dropWhile([1, 2, 3, 4], n &#x3D;&gt; n &gt;&#x3D; 3); &#x2F;&#x2F; [3,4]</span><br></pre></td></tr></table></figure><p>16，flatten：指定深度扁平化数组<br>此代码段第二参数可指定深度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const flatten &#x3D; (arr, depth &#x3D; 1) &#x3D;&gt;</span><br><span class="line">  arr.reduce((a, v) &#x3D;&gt; a.concat(depth &gt; 1 &amp;&amp; Array.isArray(v) ? flatten(v, depth - 1) : v), []);</span><br><span class="line"></span><br><span class="line">flatten([1, [2], 3, 4]); &#x2F;&#x2F; [1, 2, 3, 4]</span><br><span class="line">flatten([1, [2, [3, [4, 5], 6], 7], 8], 2); &#x2F;&#x2F; [1, 2, 3, [4, 5], 6, 7, 8]</span><br></pre></td></tr></table></figure><p>17，indexOfAll：返回数组中某值的所有索引<br>此代码段可用于获取数组中某个值的所有索引，如果此值中未包含该值，则返回一个空数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const indexOfAll &#x3D; (arr, val) &#x3D;&gt; arr.reduce((acc, el, i) &#x3D;&gt; (el &#x3D;&#x3D;&#x3D; val ? [...acc, i] : acc), []);</span><br><span class="line"></span><br><span class="line">indexOfAll([1, 2, 3, 1, 2, 3], 1); &#x2F;&#x2F; [0,3]</span><br><span class="line">indexOfAll([1, 2, 3], 4); &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure><p>18，intersection：两数组的交集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const intersection &#x3D; (a, b) &#x3D;&gt; &#123;</span><br><span class="line">  const s &#x3D; new Set(b);</span><br><span class="line">  return a.filter(x &#x3D;&gt; s.has(x));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">intersection([1, 2, 3], [4, 3, 2]); &#x2F;&#x2F; [2, 3]</span><br></pre></td></tr></table></figure><p>19，intersectionWith：两数组都符合条件的交集<br>此片段可用于在对两个数组的每个元素执行了函数之后，返回两个数组中存在的元素列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const intersectionBy &#x3D; (a, b, fn) &#x3D;&gt; &#123;</span><br><span class="line">  const s &#x3D; new Set(b.map(fn));</span><br><span class="line">  return a.filter(x &#x3D;&gt; s.has(fn(x)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor); &#x2F;&#x2F; [2.1]</span><br></pre></td></tr></table></figure><p>20，intersectionWith：先比较后返回交集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const intersectionWith &#x3D; (a, b, comp) &#x3D;&gt; a.filter(x &#x3D;&gt; b.findIndex(y &#x3D;&gt; comp(x, y)) !&#x3D;&#x3D; -1);</span><br><span class="line"></span><br><span class="line">intersectionWith([1, 1.2, 1.5, 3, 0], [1.9, 3, 0, 3.9], (a, b) &#x3D;&gt; Math.round(a) &#x3D;&#x3D;&#x3D; Math.round(b)); &#x2F;&#x2F; [1.5, 3, 0]</span><br></pre></td></tr></table></figure><p>21，minN：返回指定长度的升序数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const minN &#x3D; (arr, n &#x3D; 1) &#x3D;&gt; [...arr].sort((a, b) &#x3D;&gt; a - b).slice(0, n);</span><br><span class="line"></span><br><span class="line">minN([1, 2, 3]); &#x2F;&#x2F; [1]</span><br><span class="line">minN([1, 2, 3], 2); &#x2F;&#x2F; [1,2]</span><br></pre></td></tr></table></figure><p>22，negate：根据条件反向筛选</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const negate &#x3D; func &#x3D;&gt; (...args) &#x3D;&gt; !func(...args);</span><br><span class="line"></span><br><span class="line">[1, 2, 3, 4, 5, 6].filter(negate(n &#x3D;&gt; n % 2 &#x3D;&#x3D;&#x3D; 0)); &#x2F;&#x2F; [ 1, 3, 5 ]</span><br></pre></td></tr></table></figure><p>23，randomIntArrayInRange：生成两数之间指定长度的随机数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const randomIntArrayInRange &#x3D; (min, max, n &#x3D; 1) &#x3D;&gt;</span><br><span class="line">  Array.from(&#123; length: n &#125;, () &#x3D;&gt; Math.floor(Math.random() * (max - min + 1)) + min);</span><br><span class="line">  </span><br><span class="line">randomIntArrayInRange(12, 35, 10); &#x2F;&#x2F; [ 34, 14, 27, 17, 30, 27, 20, 26, 21, 14 ]</span><br></pre></td></tr></table></figure><p>24，sample：在指定数组中获取随机数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const sample &#x3D; arr &#x3D;&gt; arr[Math.floor(Math.random() * arr.length)];</span><br><span class="line"></span><br><span class="line">sample([3, 7, 9, 11]); &#x2F;&#x2F; 9</span><br></pre></td></tr></table></figure><p>25，sampleSize：在指定数组中获取指定长度的随机数<br>此代码段可用于从数组中获取指定长度的随机数，直至穷尽数组。 使用Fisher-Yates算法对数组中的元素进行随机选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const sampleSize &#x3D; ([...arr], n &#x3D; 1) &#x3D;&gt; &#123;</span><br><span class="line">  let m &#x3D; arr.length;</span><br><span class="line">  while (m) &#123;</span><br><span class="line">    const i &#x3D; Math.floor(Math.random() * m--);</span><br><span class="line">    [arr[m], arr[i]] &#x3D; [arr[i], arr[m]];</span><br><span class="line">  &#125;</span><br><span class="line">  return arr.slice(0, n);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sampleSize([1, 2, 3], 2); &#x2F;&#x2F; [3,1]</span><br><span class="line">sampleSize([1, 2, 3], 4); &#x2F;&#x2F; [2,3,1]</span><br></pre></td></tr></table></figure><p>26，shuffle：“洗牌” 数组<br>此代码段使用Fisher-Yates算法随机排序数组的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const shuffle &#x3D; ([...arr]) &#x3D;&gt; &#123;</span><br><span class="line">  let m &#x3D; arr.length;</span><br><span class="line">  while (m) &#123;</span><br><span class="line">    const i &#x3D; Math.floor(Math.random() * m--);</span><br><span class="line">    [arr[m], arr[i]] &#x3D; [arr[i], arr[m]];</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const foo &#x3D; [1, 2, 3];</span><br><span class="line">shuffle(foo); &#x2F;&#x2F; [2, 3, 1], foo &#x3D; [1, 2, 3]</span><br></pre></td></tr></table></figure><p>27，nest：根据parent_id生成树结构（阿里一面真题）<br>根据每项的parent_id，生成具体树形结构的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const nest &#x3D; (items, id &#x3D; null, link &#x3D; &#39;parent_id&#39;) &#x3D;&gt;</span><br><span class="line">  items</span><br><span class="line">    .filter(item &#x3D;&gt; item[link] &#x3D;&#x3D;&#x3D; id)</span><br><span class="line">    .map(item &#x3D;&gt; (&#123; ...item, children: nest(items, item.id) &#125;));</span><br></pre></td></tr></table></figure><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const comments &#x3D; [</span><br><span class="line">  &#123; id: 1, parent_id: null &#125;,</span><br><span class="line">  &#123; id: 2, parent_id: 1 &#125;,</span><br><span class="line">  &#123; id: 3, parent_id: 1 &#125;,</span><br><span class="line">  &#123; id: 4, parent_id: 2 &#125;,</span><br><span class="line">  &#123; id: 5, parent_id: 4 &#125;</span><br><span class="line">];</span><br><span class="line">const nestedComments &#x3D; nest(comments); &#x2F;&#x2F; [&#123; id: 1, parent_id: null, children: [...] &#125;]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿拉伯数字转中文</title>
      <link href="/2019/08/05/%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E8%BD%AC%E4%B8%AD%E6%96%87/"/>
      <url>/2019/08/05/%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E8%BD%AC%E4%B8%AD%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>最近在项目中用到要将阿拉伯数字转为中文的需求</p><a id="more"></a>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function numberToChinese()&#123;</span><br><span class="line">var chnNumChar &#x3D; [&#39;零&#39;, &#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;]</span><br><span class="line">  var chnUnitChar &#x3D; [&#39;&#39;, &#39;十&#39;, &#39;百&#39;, &#39;千&#39;]</span><br><span class="line">  var strIns &#x3D; &#39;&#39;</span><br><span class="line">  var chnStr &#x3D; &#39;&#39;</span><br><span class="line">  var unitPos &#x3D; 0</span><br><span class="line">  var zero &#x3D; true</span><br><span class="line">  while (num &gt; 0) &#123;</span><br><span class="line">    var v &#x3D; num % 10</span><br><span class="line">    if (v &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      if (!zero) &#123;</span><br><span class="line">        zero &#x3D; true</span><br><span class="line">        chnStr &#x3D; chnNumChar[v] + chnStr</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      zero &#x3D; false</span><br><span class="line">      strIns &#x3D; chnNumChar[v]</span><br><span class="line">      strIns +&#x3D; chnUnitChar[unitPos]</span><br><span class="line">      chnStr &#x3D; strIns + chnStr</span><br><span class="line">    &#125;</span><br><span class="line">    unitPos++</span><br><span class="line">    num &#x3D; Math.floor(num &#x2F; 10)</span><br><span class="line">  &#125;</span><br><span class="line">  return chnStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在使用中发现10-19会转换成‘一十’，‘一十一’这种情况，这当然不是我们想要的<br>所以对于字符串做判断替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (chnStr[0] &#x3D;&#x3D;&#x3D; &#39;一&#39; &amp;&amp; chnStr[1] &#x3D;&#x3D;&#x3D; &#39;十&#39;) &#123;</span><br><span class="line">        chnStr &#x3D; chnStr.replace(&#39;一十&#39;, &#39;十&#39;)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>最终代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function numberToChinese()&#123;</span><br><span class="line">var chnNumChar &#x3D; [&#39;零&#39;, &#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;]</span><br><span class="line">  var chnUnitChar &#x3D; [&#39;&#39;, &#39;十&#39;, &#39;百&#39;, &#39;千&#39;]</span><br><span class="line">  var strIns &#x3D; &#39;&#39;</span><br><span class="line">  var chnStr &#x3D; &#39;&#39;</span><br><span class="line">  var unitPos &#x3D; 0</span><br><span class="line">  var zero &#x3D; true</span><br><span class="line">  while (num &gt; 0) &#123;</span><br><span class="line">    var v &#x3D; num % 10</span><br><span class="line">    if (v &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      if (!zero) &#123;</span><br><span class="line">        zero &#x3D; true</span><br><span class="line">        chnStr &#x3D; chnNumChar[v] + chnStr</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      zero &#x3D; false</span><br><span class="line">      strIns &#x3D; chnNumChar[v]</span><br><span class="line">      strIns +&#x3D; chnUnitChar[unitPos]</span><br><span class="line">      chnStr &#x3D; strIns + chnStr</span><br><span class="line">      if (chnStr[0] &#x3D;&#x3D;&#x3D; &#39;一&#39; &amp;&amp; chnStr[1] &#x3D;&#x3D;&#x3D; &#39;十&#39;) &#123;</span><br><span class="line">        chnStr &#x3D; chnStr.replace(&#39;一十&#39;, &#39;十&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unitPos++</span><br><span class="line">    num &#x3D; Math.floor(num &#x2F; 10)</span><br><span class="line">  &#125;</span><br><span class="line">  return chnStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H5移动端开发中一些小技巧</title>
      <link href="/2019/08/04/H5%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/08/04/H5%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>1，不想要原始键盘，tel类型的话包含数字和*#号，用pattern来匹配就只有数字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 有&quot;#&quot; &quot;*&quot;符号输入 --&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;tel&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 纯数字 --&gt;</span><br><span class="line">&lt;input pattern&#x3D;&quot;\d*&quot;&gt;</span><br></pre></td></tr></table></figure><a id="more"></a>   <p>2，调用系统功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 拨号 --&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;tel:123&quot;&gt;打电话给: 123&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 发送短信 --&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;sms:123&quot;&gt;发短信给: 123&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 发送邮件 --&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;mailto:123@qq.com&quot;&gt;发邮件给：123@qq.com&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 选择照片或者拍摄照片 --&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;file&quot; accept&#x3D;&quot;image&#x2F;*&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 选择视频或者拍摄视频 --&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;file&quot; accept&#x3D;&quot;video&#x2F;*&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 多选 --&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;file&quot; multiple&gt;</span><br></pre></td></tr></table></figure><p>3，打开系统应用</p><p>我们采用的URL Scheme，是一种协议，一般用来访问APP或者APP中的某个功能/页面（如唤醒APP后打开指定页面或者使用某些功能。<br>基本格式：<br>     行为(应用的某个功能/页面)<br>            |<br>scheme://[path][?query]<br>   |               |<br>应用标识       功能需要的参数<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;weixin:&#x2F;&#x2F;&quot;&gt;打开微信&lt;&#x2F;a&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;alipays:&#x2F;&#x2F;&quot;&gt;打开支付宝&lt;&#x2F;a&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;alipays:&#x2F;&#x2F;platformapi&#x2F;startapp?saId&#x3D;10000007&quot;&gt;打开支付宝的扫一扫功能&lt;&#x2F;a&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;alipays:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;60000002&quot;&gt;打开支付宝的蚂蚁森林&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><p>唤醒APP的条件是你的手机已经安装了该APP<br>某些浏览器会禁用此协议，比如微信内部浏览器（除非开了白名单）<br>4，active伪类无效<br>body注册空事件</p><p>5，自动识别<br>在H5开发过程中经常会遇到浏览器自动识别手机号和邮箱，转为可点击的链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 忽略浏览器自动识别数字为电话号码 --&gt;</span><br><span class="line">&lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 忽略浏览器自动识别邮箱账号 --&gt;</span><br><span class="line">&lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;email&#x3D;no&quot;&gt;</span><br></pre></td></tr></table></figure><p>6，input框失焦后页面没有回弹<br>通常出现在IOS设备内置的微信浏览器中，由于页面高度过小<br>聚焦时，页面需要往上移动的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;text&quot; @focus&#x3D;&quot;focus&quot; @blur&#x3D;&quot;blur&quot;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        scrollTop: 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      focus() &#123;</span><br><span class="line">        this.scrollTop &#x3D; document.scrollingElement.scrollTop;</span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">      blur() &#123;</span><br><span class="line">        document.scrollingElement.scrollTo(0, this.scrollTop);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>7，禁止浏览器的一些默认行为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 禁止长按图片保存</span><br><span class="line">img &#123;</span><br><span class="line">  -webkit-touch-callout: none;</span><br><span class="line">  pointer-events: none; &#x2F;&#x2F; 像微信浏览器还是无法禁止，加上这行样式即可</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 禁止长按选择文字</span><br><span class="line">div &#123;</span><br><span class="line">  -webkit-user-select: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 禁止长按呼出菜单</span><br><span class="line">div &#123;</span><br><span class="line">  -webkit-touch-callout: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8，滑动不顺畅<br>一般出现在IOS设备中，自定义盒子使用了overflow: auto || scroll后出现的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  -webkit-overflow-scrolling: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9，rem自适应</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">html &#123;</span><br><span class="line"> font-size: calc(100vw &#x2F; 3.75);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">  font-size: .14rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> H5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> H5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue中监听浏览器关闭方法</title>
      <link href="/2019/08/04/vue%E4%B8%AD%E7%9B%91%E5%90%AC%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%B3%E9%97%AD%E6%96%B9%E6%B3%95/"/>
      <url>/2019/08/04/vue%E4%B8%AD%E7%9B%91%E5%90%AC%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%B3%E9%97%AD%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1，直接执行</span><br><span class="line">mounted () &#123;</span><br><span class="line">    window.addEventListener(&#39;beforeunload&#39;, e &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; window.localStorage.removeItem(&#39;userInfo&#39;)</span><br><span class="line">      console.log(&#39;浏览器刷新了&#39;)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"> 2，调用函数</span><br><span class="line"> mounted () &#123;</span><br><span class="line">    window.addEventListener( &#39;beforeunload&#39;, e &#x3D;&gt; this.browerStatus() );</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">browerStatus()&#123;</span><br><span class="line">console.log(&#39;浏览器刷新了&#39;)</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通用字体重量对应的font-weight值</title>
      <link href="/2019/08/03/%E9%80%9A%E7%94%A8%E5%AD%97%E4%BD%93%E9%87%8D%E9%87%8F%E5%AF%B9%E5%BA%94%E7%9A%84font-weight%E5%80%BC/"/>
      <url>/2019/08/03/%E9%80%9A%E7%94%A8%E5%AD%97%E4%BD%93%E9%87%8D%E9%87%8F%E5%AF%B9%E5%BA%94%E7%9A%84font-weight%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>常见的CSS通用字体</p><a id="more"></a>   <p>字体粗细：‘font-weight’<br>属性<br>名称： font-weight</p><p>取值： normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900</p><p>初始： normal</p><p>适用于：    所有元素</p><p>继承： 是</p><p>百分比：    （不适用）</p><p>媒介： 视觉</p><p>计算值：    详见描述</p><p>动画： -<br>‘<br>font-weight’属性执行字体中字形的重量，这取决于黑度等级或笔划粗细。</p><p>其值的意义如下：</p><p>100至900</p><p>这些有序排列中的每个值，表示至少与其起身拥有相同黑度的重量。其大致符合下列通用重量名称：</p><p>100 - Thin</p><p>200 - Extra Light (Ultra Light)</p><p>300 - Light</p><p>400 - Regular (Normal、Book、Roman)</p><p>500 - Medium</p><p>600 - Semi Bold (Demi Bold)</p><p>700 - Bold</p><p>800 - Extra Bold (Ultra Bold)</p><p>900 - Black (Heavy)</p><p>normal、regular与’400’相同。</p><p>bold与’700’相同。</p><p>bolder指定外观的重量大于继承的值。</p><p>lighter 指定外观的重量小于继承的值</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用正则表达式</title>
      <link href="/2019/08/02/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/08/02/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>((?=[\x21-\x7e]+)[^A-Za-z0-9])<br>这个匹配所有键盘上可见的非字母和数字的符号</p><p>var patrn = /[`<del>!@#$%^&amp;*()_-+=&lt;&gt;?:”{}|,./;’\[]·</del>！@#￥%……&amp;*（）——-+={}|《》？：“”【】、；‘’，。、]/im;</p><a id="more"></a>   <p>if (!patrn.test(str))<br>{// 如果包含特殊字符返回false</p><p>return false;</p><p>}</p><p>return true;</p><p>这个是输入框防止特殊字符勿输入验证，包括键盘上所有特殊字符的英文和中文状态。需要者可以根据自身需求而定！<br>谢谢！</p><p>[^\w\s]+<br>匹配非空 非字母 非数字 即可</p><p>1 数字：^[0-9]*$ </p><p>2 n位的数字：^\d{n}$</p><p>3 至少n位的数字：^\d{n,}$ </p><p>4 m-n位的数字：^\d{m,n}$ </p><p>5 零和非零开头的数字：^(0|[1-9][0-9]*)$ </p><p>6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ </p><p>7 带1-2位小数的正数或负数：^(-)?\d+(.\d{1,2})?$ </p><p>8 正数、负数、和小数：^(-|+)?\d+(.\d+)?$ </p><p>9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$</p><p>10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$</p><p>11 非零的正整数：^[1-9]\d<em>$ 或 ^([1-9][0-9]</em>){1,3}$ 或 ^+?[1-9][0-9]*$</p><p>12 非零的负整数：^-[1-9][]0-9”<em>$ 或 ^-[1-9]\d</em>$</p><p>13 非负整数：^\d+$ 或 ^[1-9]\d*|0$</p><p>14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</p><p>15 非负浮点数：^\d+(.\d+)?$ 或 ^[1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>|0?.0+|0$</p><p>16 非正浮点数：^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>))|0?.0+|0$</p><p>17 正浮点数：^[1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>$ 或 ^(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]*.[0-9]+)|([0-9]</em>[1-9][0-9]*))$</p><p>18 负浮点数：^-([1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>)$ 或 ^(-(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]*.[0-9]+)|([0-9]</em>[1-9][0-9]*)))$</p><p>19 浮点数：^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>|0?.0+|0)$</p><p>二、校验字符的表达式</p><p>1 汉字：^[\u4e00-\u9fa5]{0,}$ </p><p>2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ </p><p>3 长度为3-20的所有字符：^.{3,20}$ </p><p>4 由26个英文字母组成的字符串：^[A-Za-z]+$ </p><p>5 由26个大写英文字母组成的字符串：^[A-Z]+$ </p><p>6 由26个小写英文字母组成的字符串：^[a-z]+$ </p><p>7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ </p><p>8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ </p><p>9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$</p><p>10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$</p><p>11 可以输入含有^%&amp;’,;=?$&quot;等字符：[^%&amp;’,;=?$\x22]+</p><p>12 禁止输入含有<del>的字符：[^</del>\x22]+<br>三、特殊需求表达式</p><p>1 Email地址：^\w+([-+.]\w+)<em>@\w+([-.]\w+)*.\w+([-.]\w+)</em>$ </p><p>2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? </p><p>3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$ </p><p>4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ </p><p>5 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$  </p><p>6 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} </p><p>7 身份证号(15位、18位数字)：^\d{15}|\d{18}$ </p><p>8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ </p><p>9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$</p><p>10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$</p><p>11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.<em>\d)(?=.</em>[a-z])(?=.*[A-Z]).{8,10}$</p><p>12 日期格式：^\d{4}-\d{1,2}-\d{1,2}</p><p>13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</p><p>14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</p><p>15 钱的输入格式：</p><p>16 1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$</p><p>17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$</p><p>18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$</p><p>19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$</p><p>20 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$</p><p>21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$</p><p>22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$</p><p>23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$</p><p>24 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</p><p>25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$</p><p>26 中文字符的正则表达式：[\u4e00-\u9fa5]</p><p>27 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</p><p>28 空白行的正则表达式：\n\s*\r (可以用来删除空白行)</p><p>29 HTML标记的正则表达式：&lt;(\S<em>?)[^&gt;]</em>&gt;.<em>?&lt;/\1&gt;|&lt;.</em>? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</p><p>30 首尾空白字符的正则表达式：^\s<em>|\s</em>$或(^\s<em>)|(\s</em>$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</p><p>31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)</p><p>32 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)<br>33 IP地址：\d+.\d+.\d+.\d+ (提取IP地址时有用)<br>34 IP地址：((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d)) </p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="/2019/08/01/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/08/01/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>Git远程新建分支之后，本地看不到最新分支<br>git remote update origin</p><p>git checkout -b abc origin/abc<br>这个命令的意思是：checkout远程的分支abc，在本地命名为abc分支，并进入本地的abc分支</p><p>有必要作些测试，确保修补是成功的，然后回到 master 分支并把它合并进来，然后发布到生产服务器。<br>用 git merge 命令来进行合并：<br>git checkout master<br>git merge hotfix</p><p>删除分支<br>git branch -d hotfix</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/31/hello-world/"/>
      <url>/2019/07/31/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
